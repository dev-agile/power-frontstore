"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately";
exports.ids = ["vendor-chunks/@react-stately"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/checkbox/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCheckboxGroupState: () => (/* binding */ $587d3ad58be6d31f$export$daff6da51032a415)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $587d3ad58be6d31f$export$daff6da51032a415(props = {}) {\n    let [selectedValues, setValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, props.defaultValue || [], props.onChange);\n    let isRequired = !!props.isRequired && selectedValues.length === 0;\n    let invalidValues = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.useFormValidationState)({\n        ...props,\n        value: selectedValues\n    });\n    let isInvalid = validation.displayValidation.isInvalid;\n    var _props_validationState;\n    const state = {\n        ...validation,\n        value: selectedValues,\n        setValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            setValue(value);\n        },\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isSelected (value) {\n            return selectedValues.includes(value);\n        },\n        addValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (!selectedValues.includes(value)) setValue(selectedValues.concat(value));\n        },\n        removeValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n        },\n        toggleValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n            else setValue(selectedValues.concat(value));\n        },\n        setInvalid (value, v) {\n            let s = new Map(invalidValues.current);\n            if (v.isInvalid) s.set(value, v);\n            else s.delete(value);\n            invalidValues.current = s;\n            validation.updateValidation((0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.mergeValidation)(...s.values()));\n        },\n        validationState: (_props_validationState = props.validationState) !== null && _props_validationState !== void 0 ? _props_validationState : isInvalid ? \"invalid\" : null,\n        isInvalid: isInvalid,\n        isRequired: isRequired\n    };\n    return state;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY2hlY2tib3gvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUk7QUFDbEQ7QUFDdkM7QUFFOUM7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FHRCxTQUFTUSwwQ0FBMENDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pELElBQUksQ0FBQ0MsZ0JBQWdCQyxTQUFTLEdBQUcsQ0FBQyxHQUFHTixvRUFBd0IsRUFBR0ksTUFBTUcsS0FBSyxFQUFFSCxNQUFNSSxZQUFZLElBQUksRUFBRSxFQUFFSixNQUFNSyxRQUFRO0lBQ3JILElBQUlDLGFBQWEsQ0FBQyxDQUFDTixNQUFNTSxVQUFVLElBQUlMLGVBQWVNLE1BQU0sS0FBSztJQUNqRSxJQUFJQyxnQkFBZ0IsQ0FBQyxHQUFHVix5Q0FBWSxFQUFHLElBQUlXO0lBQzNDLElBQUlDLGFBQWEsQ0FBQyxHQUFHbEIsdUVBQTRCLEVBQUc7UUFDaEQsR0FBR1EsS0FBSztRQUNSRyxPQUFPRjtJQUNYO0lBQ0EsSUFBSVUsWUFBWUQsV0FBV0UsaUJBQWlCLENBQUNELFNBQVM7SUFDdEQsSUFBSUU7SUFDSixNQUFNQyxRQUFRO1FBQ1YsR0FBR0osVUFBVTtRQUNiUCxPQUFPRjtRQUNQQyxVQUFVQyxLQUFLO1lBQ1gsSUFBSUgsTUFBTWUsVUFBVSxJQUFJZixNQUFNZ0IsVUFBVSxFQUFFO1lBQzFDZCxTQUFTQztRQUNiO1FBQ0FhLFlBQVloQixNQUFNZ0IsVUFBVSxJQUFJO1FBQ2hDRCxZQUFZZixNQUFNZSxVQUFVLElBQUk7UUFDaENFLFlBQVlkLEtBQUs7WUFDYixPQUFPRixlQUFlaUIsUUFBUSxDQUFDZjtRQUNuQztRQUNBZ0IsVUFBVWhCLEtBQUs7WUFDWCxJQUFJSCxNQUFNZSxVQUFVLElBQUlmLE1BQU1nQixVQUFVLEVBQUU7WUFDMUMsSUFBSSxDQUFDZixlQUFlaUIsUUFBUSxDQUFDZixRQUFRRCxTQUFTRCxlQUFlbUIsTUFBTSxDQUFDakI7UUFDeEU7UUFDQWtCLGFBQWFsQixLQUFLO1lBQ2QsSUFBSUgsTUFBTWUsVUFBVSxJQUFJZixNQUFNZ0IsVUFBVSxFQUFFO1lBQzFDLElBQUlmLGVBQWVpQixRQUFRLENBQUNmLFFBQVFELFNBQVNELGVBQWVxQixNQUFNLENBQUMsQ0FBQ0MsZ0JBQWdCQSxrQkFBa0JwQjtRQUMxRztRQUNBcUIsYUFBYXJCLEtBQUs7WUFDZCxJQUFJSCxNQUFNZSxVQUFVLElBQUlmLE1BQU1nQixVQUFVLEVBQUU7WUFDMUMsSUFBSWYsZUFBZWlCLFFBQVEsQ0FBQ2YsUUFBUUQsU0FBU0QsZUFBZXFCLE1BQU0sQ0FBQyxDQUFDQyxnQkFBZ0JBLGtCQUFrQnBCO2lCQUNqR0QsU0FBU0QsZUFBZW1CLE1BQU0sQ0FBQ2pCO1FBQ3hDO1FBQ0FzQixZQUFZdEIsS0FBSyxFQUFFdUIsQ0FBQztZQUNoQixJQUFJQyxJQUFJLElBQUlsQixJQUFJRCxjQUFjb0IsT0FBTztZQUNyQyxJQUFJRixFQUFFZixTQUFTLEVBQUVnQixFQUFFRSxHQUFHLENBQUMxQixPQUFPdUI7aUJBQ3pCQyxFQUFFRyxNQUFNLENBQUMzQjtZQUNkSyxjQUFjb0IsT0FBTyxHQUFHRDtZQUN4QmpCLFdBQVdxQixnQkFBZ0IsQ0FBQyxDQUFDLEdBQUdyQyxnRUFBcUIsS0FBTWlDLEVBQUVLLE1BQU07UUFDdkU7UUFDQUMsaUJBQWlCLENBQUNwQix5QkFBeUJiLE1BQU1pQyxlQUFlLE1BQU0sUUFBUXBCLDJCQUEyQixLQUFLLElBQUlBLHlCQUF5QkYsWUFBWSxZQUFZO1FBQ25LQSxXQUFXQTtRQUNYTCxZQUFZQTtJQUNoQjtJQUNBLE9BQU9RO0FBQ1g7QUFLNEUsQ0FDNUUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY2hlY2tib3gvZGlzdC9pbXBvcnQubWpzP2E5YTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VGb3JtVmFsaWRhdGlvblN0YXRlIGFzICRiM251TyR1c2VGb3JtVmFsaWRhdGlvblN0YXRlLCBtZXJnZVZhbGlkYXRpb24gYXMgJGIzbnVPJG1lcmdlVmFsaWRhdGlvbn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2Zvcm1cIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICRiM251TyR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuaW1wb3J0IHt1c2VSZWYgYXMgJGIzbnVPJHVzZVJlZn0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuZnVuY3Rpb24gJDU4N2QzYWQ1OGJlNmQzMWYkZXhwb3J0JGRhZmY2ZGE1MTAzMmE0MTUocHJvcHMgPSB7fSkge1xuICAgIGxldCBbc2VsZWN0ZWRWYWx1ZXMsIHNldFZhbHVlXSA9ICgwLCAkYjNudU8kdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy52YWx1ZSwgcHJvcHMuZGVmYXVsdFZhbHVlIHx8IFtdLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgbGV0IGlzUmVxdWlyZWQgPSAhIXByb3BzLmlzUmVxdWlyZWQgJiYgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoID09PSAwO1xuICAgIGxldCBpbnZhbGlkVmFsdWVzID0gKDAsICRiM251TyR1c2VSZWYpKG5ldyBNYXAoKSk7XG4gICAgbGV0IHZhbGlkYXRpb24gPSAoMCwgJGIzbnVPJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlc1xuICAgIH0pO1xuICAgIGxldCBpc0ludmFsaWQgPSB2YWxpZGF0aW9uLmRpc3BsYXlWYWxpZGF0aW9uLmlzSW52YWxpZDtcbiAgICB2YXIgX3Byb3BzX3ZhbGlkYXRpb25TdGF0ZTtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgLi4udmFsaWRhdGlvbixcbiAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVzLFxuICAgICAgICBzZXRWYWx1ZSAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5pc1JlYWRPbmx5IHx8IHByb3BzLmlzRGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNEaXNhYmxlZDogcHJvcHMuaXNEaXNhYmxlZCB8fCBmYWxzZSxcbiAgICAgICAgaXNSZWFkT25seTogcHJvcHMuaXNSZWFkT25seSB8fCBmYWxzZSxcbiAgICAgICAgaXNTZWxlY3RlZCAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFZhbHVlICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmlzUmVhZE9ubHkgfHwgcHJvcHMuaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHNldFZhbHVlKHNlbGVjdGVkVmFsdWVzLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVWYWx1ZSAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5pc1JlYWRPbmx5IHx8IHByb3BzLmlzRGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHNldFZhbHVlKHNlbGVjdGVkVmFsdWVzLmZpbHRlcigoZXhpc3RpbmdWYWx1ZSk9PmV4aXN0aW5nVmFsdWUgIT09IHZhbHVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZVZhbHVlICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmlzUmVhZE9ubHkgfHwgcHJvcHMuaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkgc2V0VmFsdWUoc2VsZWN0ZWRWYWx1ZXMuZmlsdGVyKChleGlzdGluZ1ZhbHVlKT0+ZXhpc3RpbmdWYWx1ZSAhPT0gdmFsdWUpKTtcbiAgICAgICAgICAgIGVsc2Ugc2V0VmFsdWUoc2VsZWN0ZWRWYWx1ZXMuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludmFsaWQgKHZhbHVlLCB2KSB7XG4gICAgICAgICAgICBsZXQgcyA9IG5ldyBNYXAoaW52YWxpZFZhbHVlcy5jdXJyZW50KTtcbiAgICAgICAgICAgIGlmICh2LmlzSW52YWxpZCkgcy5zZXQodmFsdWUsIHYpO1xuICAgICAgICAgICAgZWxzZSBzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBpbnZhbGlkVmFsdWVzLmN1cnJlbnQgPSBzO1xuICAgICAgICAgICAgdmFsaWRhdGlvbi51cGRhdGVWYWxpZGF0aW9uKCgwLCAkYjNudU8kbWVyZ2VWYWxpZGF0aW9uKSguLi5zLnZhbHVlcygpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRpb25TdGF0ZTogKF9wcm9wc192YWxpZGF0aW9uU3RhdGUgPSBwcm9wcy52YWxpZGF0aW9uU3RhdGUpICE9PSBudWxsICYmIF9wcm9wc192YWxpZGF0aW9uU3RhdGUgIT09IHZvaWQgMCA/IF9wcm9wc192YWxpZGF0aW9uU3RhdGUgOiBpc0ludmFsaWQgPyBcImludmFsaWRcIiA6IG51bGwsXG4gICAgICAgIGlzSW52YWxpZDogaXNJbnZhbGlkLFxuICAgICAgICBpc1JlcXVpcmVkOiBpc1JlcXVpcmVkXG4gICAgfTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5cblxuXG5cbmV4cG9ydCB7JDU4N2QzYWQ1OGJlNmQzMWYkZXhwb3J0JGRhZmY2ZGE1MTAzMmE0MTUgYXMgdXNlQ2hlY2tib3hHcm91cFN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VGb3JtVmFsaWRhdGlvblN0YXRlIiwiJGIzbnVPJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCJtZXJnZVZhbGlkYXRpb24iLCIkYjNudU8kbWVyZ2VWYWxpZGF0aW9uIiwidXNlQ29udHJvbGxlZFN0YXRlIiwiJGIzbnVPJHVzZUNvbnRyb2xsZWRTdGF0ZSIsInVzZVJlZiIsIiRiM251TyR1c2VSZWYiLCIkNTg3ZDNhZDU4YmU2ZDMxZiRleHBvcnQkZGFmZjZkYTUxMDMyYTQxNSIsInByb3BzIiwic2VsZWN0ZWRWYWx1ZXMiLCJzZXRWYWx1ZSIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwib25DaGFuZ2UiLCJpc1JlcXVpcmVkIiwibGVuZ3RoIiwiaW52YWxpZFZhbHVlcyIsIk1hcCIsInZhbGlkYXRpb24iLCJpc0ludmFsaWQiLCJkaXNwbGF5VmFsaWRhdGlvbiIsIl9wcm9wc192YWxpZGF0aW9uU3RhdGUiLCJzdGF0ZSIsImlzUmVhZE9ubHkiLCJpc0Rpc2FibGVkIiwiaXNTZWxlY3RlZCIsImluY2x1ZGVzIiwiYWRkVmFsdWUiLCJjb25jYXQiLCJyZW1vdmVWYWx1ZSIsImZpbHRlciIsImV4aXN0aW5nVmFsdWUiLCJ0b2dnbGVWYWx1ZSIsInNldEludmFsaWQiLCJ2IiwicyIsImN1cnJlbnQiLCJzZXQiLCJkZWxldGUiLCJ1cGRhdGVWYWxpZGF0aW9uIiwidmFsdWVzIiwidmFsaWRhdGlvblN0YXRlIiwidXNlQ2hlY2tib3hHcm91cFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/collections/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/collections/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollectionBuilder: () => (/* binding */ $eb2240fc39a57fa5$export$bf788dd355e3a401),\n/* harmony export */   Item: () => (/* binding */ $c1d7fb2ec91bae71$export$6d08773d2e66f8f2),\n/* harmony export */   Section: () => (/* binding */ $9fc4852771d079eb$export$6e2c8f0811a474ce),\n/* harmony export */   compareNodeOrder: () => (/* binding */ $c5a24bc478652b5f$export$8c434b3a7a4dad6),\n/* harmony export */   getChildNodes: () => (/* binding */ $c5a24bc478652b5f$export$1005530eda016c13),\n/* harmony export */   getFirstItem: () => (/* binding */ $c5a24bc478652b5f$export$fbdeaa6a76694f71),\n/* harmony export */   getItemCount: () => (/* binding */ $453cc9f0df89c0a5$export$77d5aafae4e095b2),\n/* harmony export */   getLastItem: () => (/* binding */ $c5a24bc478652b5f$export$7475b2c64539e4cf),\n/* harmony export */   getNthItem: () => (/* binding */ $c5a24bc478652b5f$export$5f3398f8733f90e2),\n/* harmony export */   useCollection: () => (/* binding */ $7613b1592d41b092$export$6cd28814d92fa9c9)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c1d7fb2ec91bae71$var$Item(props) {\n    return null;\n}\n$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {\n    let { childItems: childItems, title: title, children: children } = props;\n    let rendered = props.title || props.children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"] || \"\";\n    // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.\n    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn(\"<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.\");\n    yield {\n        type: \"item\",\n        props: props,\n        rendered: rendered,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),\n        *childNodes () {\n            if (childItems) for (let child of childItems)yield {\n                type: \"item\",\n                value: child\n            };\n            else if (title) {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\nfunction $c1d7fb2ec91bae71$var$hasChildItems(props) {\n    if (props.hasChildItems != null) return props.hasChildItems;\n    if (props.childItems) return true;\n    if (props.title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(props.children) > 0) return true;\n    return false;\n}\n// We don't want getCollectionNode to show up in the type definition\nlet $c1d7fb2ec91bae71$export$6d08773d2e66f8f2 = $c1d7fb2ec91bae71$var$Item;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $9fc4852771d079eb$var$Section(props) {\n    return null;\n}\n$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, title: title, items: items } = props;\n    yield {\n        type: \"section\",\n        props: props,\n        hasChildNodes: true,\n        rendered: title,\n        \"aria-label\": props[\"aria-label\"],\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n// We don't want getCollectionNode to show up in the type definition\nlet $9fc4852771d079eb$export$6e2c8f0811a474ce = $9fc4852771d079eb$var$Section;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $eb2240fc39a57fa5$export$bf788dd355e3a401 {\n    build(props, context) {\n        this.context = context;\n        return $eb2240fc39a57fa5$var$iterable(()=>this.iterateCollection(props));\n    }\n    *iterateCollection(props) {\n        let { children: children, items: items } = props;\n        if (typeof children === \"function\") {\n            if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n            for (let item of props.items)yield* this.getFullNode({\n                value: item\n            }, {\n                renderer: children\n            });\n        } else {\n            let items = [];\n            (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                items.push(child);\n            });\n            let index = 0;\n            for (let item of items){\n                let nodes = this.getFullNode({\n                    element: item,\n                    index: index\n                }, {});\n                for (let node of nodes){\n                    index++;\n                    yield node;\n                }\n            }\n        }\n    }\n    getKey(item, partialNode, state, parentKey) {\n        if (item.key != null) return item.key;\n        if (partialNode.type === \"cell\" && partialNode.key != null) return `${parentKey}${partialNode.key}`;\n        let v = partialNode.value;\n        if (v != null) {\n            var _v_key;\n            let key = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;\n            if (key == null) throw new Error(\"No key found for item\");\n            return key;\n        }\n        return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;\n    }\n    getChildState(state, partialNode) {\n        return {\n            renderer: partialNode.renderer || state.renderer\n        };\n    }\n    *getFullNode(partialNode, state, parentKey, parentNode) {\n        // If there's a value instead of an element on the node, and a parent renderer function is available,\n        // use it to render an element for the value.\n        let element = partialNode.element;\n        if (!element && partialNode.value && state && state.renderer) {\n            let cached = this.cache.get(partialNode.value);\n            if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {\n                cached.index = partialNode.index;\n                cached.parentKey = parentNode ? parentNode.key : null;\n                yield cached;\n                return;\n            }\n            element = state.renderer(partialNode.value);\n        }\n        // If there's an element with a getCollectionNode function on its type, then it's a supported component.\n        // Call this function to get a partial node, and recursively build a full node from there.\n        if ((0, react__WEBPACK_IMPORTED_MODULE_0__).isValidElement(element)) {\n            let type = element.type;\n            if (typeof type !== \"function\" && typeof type.getCollectionNode !== \"function\") {\n                let name = typeof element.type === \"function\" ? element.type.name : element.type;\n                throw new Error(`Unknown element <${name}> in collection.`);\n            }\n            let childNodes = type.getCollectionNode(element.props, this.context);\n            let index = partialNode.index;\n            let result = childNodes.next();\n            while(!result.done && result.value){\n                let childNode = result.value;\n                partialNode.index = index;\n                let nodeKey = childNode.key;\n                if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);\n                let nodes = this.getFullNode({\n                    ...childNode,\n                    key: nodeKey,\n                    index: index,\n                    wrapper: $eb2240fc39a57fa5$var$compose(partialNode.wrapper, childNode.wrapper)\n                }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);\n                let children = [\n                    ...nodes\n                ];\n                for (let node of children){\n                    // Cache the node based on its value\n                    node.value = childNode.value || partialNode.value;\n                    if (node.value) this.cache.set(node.value, node);\n                    // The partial node may have specified a type for the child in order to specify a constraint.\n                    // Verify that the full node that was built recursively matches this type.\n                    if (partialNode.type && node.type !== partialNode.type) throw new Error(`Unsupported type <${$eb2240fc39a57fa5$var$capitalize(node.type)}> in <${$eb2240fc39a57fa5$var$capitalize(parentNode.type)}>. Only <${$eb2240fc39a57fa5$var$capitalize(partialNode.type)}> is supported.`);\n                    index++;\n                    yield node;\n                }\n                result = childNodes.next(children);\n            }\n            return;\n        }\n        // Ignore invalid elements\n        if (partialNode.key == null) return;\n        // Create full node\n        let builder = this;\n        let node = {\n            type: partialNode.type,\n            props: partialNode.props,\n            key: partialNode.key,\n            parentKey: parentNode ? parentNode.key : null,\n            value: partialNode.value,\n            level: parentNode ? parentNode.level + 1 : 0,\n            index: partialNode.index,\n            rendered: partialNode.rendered,\n            textValue: partialNode.textValue,\n            \"aria-label\": partialNode[\"aria-label\"],\n            wrapper: partialNode.wrapper,\n            shouldInvalidate: partialNode.shouldInvalidate,\n            hasChildNodes: partialNode.hasChildNodes,\n            childNodes: $eb2240fc39a57fa5$var$iterable(function*() {\n                if (!partialNode.hasChildNodes) return;\n                let index = 0;\n                for (let child of partialNode.childNodes()){\n                    // Ensure child keys are globally unique by prepending the parent node's key\n                    if (child.key != null) // Currently this line will have issues when a parent has a key `a` and a child with key `bc`\n                    // but another parent has key `ab` and its child has a key `c`. The combined keys would result in both\n                    // children having a key of `abc`.\n                    child.key = `${node.key}${child.key}`;\n                    child.index = index;\n                    let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);\n                    for (let node of nodes){\n                        index++;\n                        yield node;\n                    }\n                }\n            })\n        };\n        yield node;\n    }\n    constructor(){\n        this.cache = new WeakMap();\n    }\n}\n// Wraps an iterator function as an iterable object, and caches the results.\nfunction $eb2240fc39a57fa5$var$iterable(iterator) {\n    let cache = [];\n    let iterable = null;\n    return {\n        *[Symbol.iterator] () {\n            for (let item of cache)yield item;\n            if (!iterable) iterable = iterator();\n            for (let item of iterable){\n                cache.push(item);\n                yield item;\n            }\n        }\n    };\n}\nfunction $eb2240fc39a57fa5$var$compose(outer, inner) {\n    if (outer && inner) return (element)=>outer(inner(element));\n    if (outer) return outer;\n    if (inner) return inner;\n}\nfunction $eb2240fc39a57fa5$var$capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nfunction $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context) {\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $eb2240fc39a57fa5$export$bf788dd355e3a401)(), []);\n    let { children: children, items: items, collection: collection } = props;\n    let result = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (collection) return collection;\n        let nodes = builder.build({\n            children: children,\n            items: items\n        }, context);\n        return factory(nodes);\n    }, [\n        builder,\n        children,\n        items,\n        collection,\n        context,\n        factory\n    ]);\n    return result;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {\n    // New API: call collection.getChildren with the node key.\n    if (typeof collection.getChildren === \"function\") return collection.getChildren(node.key);\n    // Old API: access childNodes directly.\n    return node.childNodes;\n}\nfunction $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {\n    return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);\n}\nfunction $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {\n    if (index < 0) return undefined;\n    let i = 0;\n    for (let item of iterable){\n        if (i === index) return item;\n        i++;\n    }\n}\nfunction $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {\n    let lastItem = undefined;\n    for (let value of iterable)lastItem = value;\n    return lastItem;\n}\nfunction $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {\n    // If the two nodes have the same parent, compare their indices.\n    if (a.parentKey === b.parentKey) return a.index - b.index;\n    // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.\n    // Include the base nodes in case we are comparing nodes of different levels so that we can compare the higher node to the lower level node's\n    // ancestor of the same level\n    let aAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, a),\n        a\n    ];\n    let bAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, b),\n        b\n    ];\n    let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i)=>a !== bAncestors[i]);\n    if (firstNonMatchingAncestor !== -1) {\n        // Compare the indices of two children within the common ancestor.\n        a = aAncestors[firstNonMatchingAncestor];\n        b = bAncestors[firstNonMatchingAncestor];\n        return a.index - b.index;\n    }\n    // If there isn't a non matching ancestor, we might be in a case where one of the nodes is the ancestor of the other.\n    if (aAncestors.findIndex((node)=>node === b) >= 0) return 1;\n    else if (bAncestors.findIndex((node)=>node === a) >= 0) return -1;\n    // ðŸ¤·\n    return -1;\n}\nfunction $c5a24bc478652b5f$var$getAncestors(collection, node) {\n    let parents = [];\n    while((node === null || node === void 0 ? void 0 : node.parentKey) != null){\n        node = collection.getItem(node.parentKey);\n        parents.unshift(node);\n    }\n    return parents;\n}\nconst $453cc9f0df89c0a5$var$cache = new WeakMap();\nfunction $453cc9f0df89c0a5$export$77d5aafae4e095b2(collection) {\n    let count = $453cc9f0df89c0a5$var$cache.get(collection);\n    if (count != null) return count;\n    count = 0;\n    let countItems = (items)=>{\n        for (let item of items)if (item.type === \"section\") countItems((0, $c5a24bc478652b5f$export$1005530eda016c13)(item, collection));\n        else count++;\n    };\n    countItems(collection);\n    $453cc9f0df89c0a5$var$cache.set(collection, count);\n    return count;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBRTlEOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsU0FBU0csMkJBQTJCQyxLQUFLO0lBQ3JDLE9BQU87QUFDWDtBQUNBRCwyQkFBMkJFLGlCQUFpQixHQUFHLFVBQVVBLGtCQUFrQkQsS0FBSyxFQUFFRSxPQUFPO0lBQ3JGLElBQUksRUFBRUMsWUFBWUEsVUFBVSxFQUFFQyxPQUFPQSxLQUFLLEVBQUVDLFVBQVVBLFFBQVEsRUFBRSxHQUFHTDtJQUNuRSxJQUFJTSxXQUFXTixNQUFNSSxLQUFLLElBQUlKLE1BQU1LLFFBQVE7SUFDNUMsSUFBSUUsWUFBWVAsTUFBTU8sU0FBUyxJQUFLLFFBQU9ELGFBQWEsV0FBV0EsV0FBVyxFQUFDLEtBQU1OLEtBQUssQ0FBQyxhQUFhLElBQUk7SUFDNUcscUdBQXFHO0lBQ3JHLElBQUksQ0FBQ08sYUFBYSxDQUFFTCxDQUFBQSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUU0sd0JBQXdCLEdBQUdDLFFBQVFDLElBQUksQ0FBQztJQUN0SCxNQUFNO1FBQ0ZDLE1BQU07UUFDTlgsT0FBT0E7UUFDUE0sVUFBVUE7UUFDVkMsV0FBV0E7UUFDWCxjQUFjUCxLQUFLLENBQUMsYUFBYTtRQUNqQ1ksZUFBZUMsb0NBQW9DYjtRQUNuRCxDQUFDYztZQUNHLElBQUlYLFlBQVksS0FBSyxJQUFJWSxTQUFTWixXQUFXLE1BQU07Z0JBQy9DUSxNQUFNO2dCQUNOSyxPQUFPRDtZQUNYO2lCQUNLLElBQUlYLE9BQU87Z0JBQ1osSUFBSWEsUUFBUSxFQUFFO2dCQUNiLElBQUdyQixrQ0FBVyxFQUFHc0IsUUFBUSxDQUFDQyxPQUFPLENBQUNkLFVBQVUsQ0FBQ1U7b0JBQzFDRSxNQUFNRyxJQUFJLENBQUM7d0JBQ1BULE1BQU07d0JBQ05VLFNBQVNOO29CQUNiO2dCQUNKO2dCQUNBLE9BQU9FO1lBQ1g7UUFDSjtJQUNKO0FBQ0o7QUFDQSxTQUFTSixvQ0FBb0NiLEtBQUs7SUFDOUMsSUFBSUEsTUFBTXNCLGFBQWEsSUFBSSxNQUFNLE9BQU90QixNQUFNc0IsYUFBYTtJQUMzRCxJQUFJdEIsTUFBTUcsVUFBVSxFQUFFLE9BQU87SUFDN0IsSUFBSUgsTUFBTUksS0FBSyxJQUFJLENBQUMsR0FBR1Isa0NBQVcsRUFBR3NCLFFBQVEsQ0FBQ0ssS0FBSyxDQUFDdkIsTUFBTUssUUFBUSxJQUFJLEdBQUcsT0FBTztJQUNoRixPQUFPO0FBQ1g7QUFDQSxvRUFBb0U7QUFDcEUsSUFBSW1CLDRDQUE0Q3pCO0FBR2hEOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTMEIsOEJBQThCekIsS0FBSztJQUN4QyxPQUFPO0FBQ1g7QUFDQXlCLDhCQUE4QnhCLGlCQUFpQixHQUFHLFVBQVVBLGtCQUFrQkQsS0FBSztJQUMvRSxJQUFJLEVBQUVLLFVBQVVBLFFBQVEsRUFBRUQsT0FBT0EsS0FBSyxFQUFFYSxPQUFPQSxLQUFLLEVBQUUsR0FBR2pCO0lBQ3pELE1BQU07UUFDRlcsTUFBTTtRQUNOWCxPQUFPQTtRQUNQWSxlQUFlO1FBQ2ZOLFVBQVVGO1FBQ1YsY0FBY0osS0FBSyxDQUFDLGFBQWE7UUFDakMsQ0FBQ2M7WUFDRyxJQUFJLE9BQU9ULGFBQWEsWUFBWTtnQkFDaEMsSUFBSSxDQUFDWSxPQUFPLE1BQU0sSUFBSVMsTUFBTTtnQkFDNUIsS0FBSyxJQUFJQyxRQUFRVixNQUFNLE1BQU07b0JBQ3pCTixNQUFNO29CQUNOSyxPQUFPVztvQkFDUEMsVUFBVXZCO2dCQUNkO1lBQ0osT0FBTztnQkFDSCxJQUFJWSxRQUFRLEVBQUU7Z0JBQ2IsSUFBR3JCLGtDQUFXLEVBQUdzQixRQUFRLENBQUNDLE9BQU8sQ0FBQ2QsVUFBVSxDQUFDVTtvQkFDMUNFLE1BQU1HLElBQUksQ0FBQzt3QkFDUFQsTUFBTTt3QkFDTlUsU0FBU047b0JBQ2I7Z0JBQ0o7Z0JBQ0EsT0FBT0U7WUFDWDtRQUNKO0lBQ0o7QUFDSjtBQUNBLG9FQUFvRTtBQUNwRSxJQUFJWSw0Q0FBNENKO0FBR2hEOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsTUFBTUs7SUFDRkMsTUFBTS9CLEtBQUssRUFBRUUsT0FBTyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtRQUNmLE9BQU84QiwrQkFBK0IsSUFBSSxJQUFJLENBQUNDLGlCQUFpQixDQUFDakM7SUFDckU7SUFDQSxDQUFDaUMsa0JBQWtCakMsS0FBSyxFQUFFO1FBQ3RCLElBQUksRUFBRUssVUFBVUEsUUFBUSxFQUFFWSxPQUFPQSxLQUFLLEVBQUUsR0FBR2pCO1FBQzNDLElBQUksT0FBT0ssYUFBYSxZQUFZO1lBQ2hDLElBQUksQ0FBQ1ksT0FBTyxNQUFNLElBQUlTLE1BQU07WUFDNUIsS0FBSyxJQUFJQyxRQUFRM0IsTUFBTWlCLEtBQUssQ0FBQyxPQUFPLElBQUksQ0FBQ2lCLFdBQVcsQ0FBQztnQkFDakRsQixPQUFPVztZQUNYLEdBQUc7Z0JBQ0NDLFVBQVV2QjtZQUNkO1FBQ0osT0FBTztZQUNILElBQUlZLFFBQVEsRUFBRTtZQUNiLElBQUdyQixrQ0FBVyxFQUFHc0IsUUFBUSxDQUFDQyxPQUFPLENBQUNkLFVBQVUsQ0FBQ1U7Z0JBQzFDRSxNQUFNRyxJQUFJLENBQUNMO1lBQ2Y7WUFDQSxJQUFJb0IsUUFBUTtZQUNaLEtBQUssSUFBSVIsUUFBUVYsTUFBTTtnQkFDbkIsSUFBSW1CLFFBQVEsSUFBSSxDQUFDRixXQUFXLENBQUM7b0JBQ3pCYixTQUFTTTtvQkFDVFEsT0FBT0E7Z0JBQ1gsR0FBRyxDQUFDO2dCQUNKLEtBQUssSUFBSUUsUUFBUUQsTUFBTTtvQkFDbkJEO29CQUNBLE1BQU1FO2dCQUNWO1lBQ0o7UUFDSjtJQUNKO0lBQ0FDLE9BQU9YLElBQUksRUFBRVksV0FBVyxFQUFFQyxLQUFLLEVBQUVDLFNBQVMsRUFBRTtRQUN4QyxJQUFJZCxLQUFLZSxHQUFHLElBQUksTUFBTSxPQUFPZixLQUFLZSxHQUFHO1FBQ3JDLElBQUlILFlBQVk1QixJQUFJLEtBQUssVUFBVTRCLFlBQVlHLEdBQUcsSUFBSSxNQUFNLE9BQU8sQ0FBQyxFQUFFRCxVQUFVLEVBQUVGLFlBQVlHLEdBQUcsQ0FBQyxDQUFDO1FBQ25HLElBQUlDLElBQUlKLFlBQVl2QixLQUFLO1FBQ3pCLElBQUkyQixLQUFLLE1BQU07WUFDWCxJQUFJQztZQUNKLElBQUlGLE1BQU0sQ0FBQ0UsU0FBU0QsRUFBRUQsR0FBRyxNQUFNLFFBQVFFLFdBQVcsS0FBSyxJQUFJQSxTQUFTRCxFQUFFRSxFQUFFO1lBQ3hFLElBQUlILE9BQU8sTUFBTSxNQUFNLElBQUloQixNQUFNO1lBQ2pDLE9BQU9nQjtRQUNYO1FBQ0EsT0FBT0QsWUFBWSxDQUFDLEVBQUVBLFVBQVUsQ0FBQyxFQUFFRixZQUFZSixLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFSSxZQUFZSixLQUFLLENBQUMsQ0FBQztJQUNyRjtJQUNBVyxjQUFjTixLQUFLLEVBQUVELFdBQVcsRUFBRTtRQUM5QixPQUFPO1lBQ0hYLFVBQVVXLFlBQVlYLFFBQVEsSUFBSVksTUFBTVosUUFBUTtRQUNwRDtJQUNKO0lBQ0EsQ0FBQ00sWUFBWUssV0FBVyxFQUFFQyxLQUFLLEVBQUVDLFNBQVMsRUFBRU0sVUFBVSxFQUFFO1FBQ3BELHFHQUFxRztRQUNyRyw2Q0FBNkM7UUFDN0MsSUFBSTFCLFVBQVVrQixZQUFZbEIsT0FBTztRQUNqQyxJQUFJLENBQUNBLFdBQVdrQixZQUFZdkIsS0FBSyxJQUFJd0IsU0FBU0EsTUFBTVosUUFBUSxFQUFFO1lBQzFELElBQUlvQixTQUFTLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHLENBQUNYLFlBQVl2QixLQUFLO1lBQzdDLElBQUlnQyxVQUFXLEVBQUNBLE9BQU9HLGdCQUFnQixJQUFJLENBQUNILE9BQU9HLGdCQUFnQixDQUFDLElBQUksQ0FBQ2pELE9BQU8sSUFBSTtnQkFDaEY4QyxPQUFPYixLQUFLLEdBQUdJLFlBQVlKLEtBQUs7Z0JBQ2hDYSxPQUFPUCxTQUFTLEdBQUdNLGFBQWFBLFdBQVdMLEdBQUcsR0FBRztnQkFDakQsTUFBTU07Z0JBQ047WUFDSjtZQUNBM0IsVUFBVW1CLE1BQU1aLFFBQVEsQ0FBQ1csWUFBWXZCLEtBQUs7UUFDOUM7UUFDQSx3R0FBd0c7UUFDeEcsMEZBQTBGO1FBQzFGLElBQUksQ0FBQyxHQUFHcEIsa0NBQVcsRUFBR3dELGNBQWMsQ0FBQy9CLFVBQVU7WUFDM0MsSUFBSVYsT0FBT1UsUUFBUVYsSUFBSTtZQUN2QixJQUFJLE9BQU9BLFNBQVMsY0FBYyxPQUFPQSxLQUFLVixpQkFBaUIsS0FBSyxZQUFZO2dCQUM1RSxJQUFJb0QsT0FBTyxPQUFPaEMsUUFBUVYsSUFBSSxLQUFLLGFBQWFVLFFBQVFWLElBQUksQ0FBQzBDLElBQUksR0FBR2hDLFFBQVFWLElBQUk7Z0JBQ2hGLE1BQU0sSUFBSWUsTUFBTSxDQUFDLGlCQUFpQixFQUFFMkIsS0FBSyxnQkFBZ0IsQ0FBQztZQUM5RDtZQUNBLElBQUl2QyxhQUFhSCxLQUFLVixpQkFBaUIsQ0FBQ29CLFFBQVFyQixLQUFLLEVBQUUsSUFBSSxDQUFDRSxPQUFPO1lBQ25FLElBQUlpQyxRQUFRSSxZQUFZSixLQUFLO1lBQzdCLElBQUltQixTQUFTeEMsV0FBV3lDLElBQUk7WUFDNUIsTUFBTSxDQUFDRCxPQUFPRSxJQUFJLElBQUlGLE9BQU90QyxLQUFLLENBQUM7Z0JBQy9CLElBQUl5QyxZQUFZSCxPQUFPdEMsS0FBSztnQkFDNUJ1QixZQUFZSixLQUFLLEdBQUdBO2dCQUNwQixJQUFJdUIsVUFBVUQsVUFBVWYsR0FBRztnQkFDM0IsSUFBSSxDQUFDZ0IsU0FBU0EsVUFBVUQsVUFBVXBDLE9BQU8sR0FBRyxPQUFPLElBQUksQ0FBQ2lCLE1BQU0sQ0FBQ2pCLFNBQVNrQixhQUFhQyxPQUFPQztnQkFDNUYsSUFBSUwsUUFBUSxJQUFJLENBQUNGLFdBQVcsQ0FBQztvQkFDekIsR0FBR3VCLFNBQVM7b0JBQ1pmLEtBQUtnQjtvQkFDTHZCLE9BQU9BO29CQUNQd0IsU0FBU0MsOEJBQThCckIsWUFBWW9CLE9BQU8sRUFBRUYsVUFBVUUsT0FBTztnQkFDakYsR0FBRyxJQUFJLENBQUNiLGFBQWEsQ0FBQ04sT0FBT2lCLFlBQVloQixZQUFZLENBQUMsRUFBRUEsVUFBVSxFQUFFcEIsUUFBUXFCLEdBQUcsQ0FBQyxDQUFDLEdBQUdyQixRQUFRcUIsR0FBRyxFQUFFSztnQkFDakcsSUFBSTFDLFdBQVc7dUJBQ1IrQjtpQkFDTjtnQkFDRCxLQUFLLElBQUlDLFFBQVFoQyxTQUFTO29CQUN0QixvQ0FBb0M7b0JBQ3BDZ0MsS0FBS3JCLEtBQUssR0FBR3lDLFVBQVV6QyxLQUFLLElBQUl1QixZQUFZdkIsS0FBSztvQkFDakQsSUFBSXFCLEtBQUtyQixLQUFLLEVBQUUsSUFBSSxDQUFDaUMsS0FBSyxDQUFDWSxHQUFHLENBQUN4QixLQUFLckIsS0FBSyxFQUFFcUI7b0JBQzNDLDZGQUE2RjtvQkFDN0YsMEVBQTBFO29CQUMxRSxJQUFJRSxZQUFZNUIsSUFBSSxJQUFJMEIsS0FBSzFCLElBQUksS0FBSzRCLFlBQVk1QixJQUFJLEVBQUUsTUFBTSxJQUFJZSxNQUFNLENBQUMsa0JBQWtCLEVBQUVvQyxpQ0FBaUN6QixLQUFLMUIsSUFBSSxFQUFFLE1BQU0sRUFBRW1ELGlDQUFpQ2YsV0FBV3BDLElBQUksRUFBRSxTQUFTLEVBQUVtRCxpQ0FBaUN2QixZQUFZNUIsSUFBSSxFQUFFLGVBQWUsQ0FBQztvQkFDalJ3QjtvQkFDQSxNQUFNRTtnQkFDVjtnQkFDQWlCLFNBQVN4QyxXQUFXeUMsSUFBSSxDQUFDbEQ7WUFDN0I7WUFDQTtRQUNKO1FBQ0EsMEJBQTBCO1FBQzFCLElBQUlrQyxZQUFZRyxHQUFHLElBQUksTUFBTTtRQUM3QixtQkFBbUI7UUFDbkIsSUFBSXFCLFVBQVUsSUFBSTtRQUNsQixJQUFJMUIsT0FBTztZQUNQMUIsTUFBTTRCLFlBQVk1QixJQUFJO1lBQ3RCWCxPQUFPdUMsWUFBWXZDLEtBQUs7WUFDeEIwQyxLQUFLSCxZQUFZRyxHQUFHO1lBQ3BCRCxXQUFXTSxhQUFhQSxXQUFXTCxHQUFHLEdBQUc7WUFDekMxQixPQUFPdUIsWUFBWXZCLEtBQUs7WUFDeEJnRCxPQUFPakIsYUFBYUEsV0FBV2lCLEtBQUssR0FBRyxJQUFJO1lBQzNDN0IsT0FBT0ksWUFBWUosS0FBSztZQUN4QjdCLFVBQVVpQyxZQUFZakMsUUFBUTtZQUM5QkMsV0FBV2dDLFlBQVloQyxTQUFTO1lBQ2hDLGNBQWNnQyxXQUFXLENBQUMsYUFBYTtZQUN2Q29CLFNBQVNwQixZQUFZb0IsT0FBTztZQUM1QlIsa0JBQWtCWixZQUFZWSxnQkFBZ0I7WUFDOUN2QyxlQUFlMkIsWUFBWTNCLGFBQWE7WUFDeENFLFlBQVlrQiwrQkFBK0I7Z0JBQ3ZDLElBQUksQ0FBQ08sWUFBWTNCLGFBQWEsRUFBRTtnQkFDaEMsSUFBSXVCLFFBQVE7Z0JBQ1osS0FBSyxJQUFJcEIsU0FBU3dCLFlBQVl6QixVQUFVLEdBQUc7b0JBQ3ZDLDRFQUE0RTtvQkFDNUUsSUFBSUMsTUFBTTJCLEdBQUcsSUFBSSxNQUNqQiw2RkFBNkY7b0JBQzdGLHNHQUFzRztvQkFDdEcsa0NBQWtDO29CQUNsQzNCLE1BQU0yQixHQUFHLEdBQUcsQ0FBQyxFQUFFTCxLQUFLSyxHQUFHLENBQUMsRUFBRTNCLE1BQU0yQixHQUFHLENBQUMsQ0FBQztvQkFDckMzQixNQUFNb0IsS0FBSyxHQUFHQTtvQkFDZCxJQUFJQyxRQUFRMkIsUUFBUTdCLFdBQVcsQ0FBQ25CLE9BQU9nRCxRQUFRakIsYUFBYSxDQUFDTixPQUFPekIsUUFBUXNCLEtBQUtLLEdBQUcsRUFBRUw7b0JBQ3RGLEtBQUssSUFBSUEsUUFBUUQsTUFBTTt3QkFDbkJEO3dCQUNBLE1BQU1FO29CQUNWO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLE1BQU1BO0lBQ1Y7SUFDQTRCLGFBQWE7UUFDVCxJQUFJLENBQUNoQixLQUFLLEdBQUcsSUFBSWlCO0lBQ3JCO0FBQ0o7QUFDQSw0RUFBNEU7QUFDNUUsU0FBU2xDLCtCQUErQm1DLFFBQVE7SUFDNUMsSUFBSWxCLFFBQVEsRUFBRTtJQUNkLElBQUltQixXQUFXO0lBQ2YsT0FBTztRQUNILENBQUMsQ0FBQ0MsT0FBT0YsUUFBUSxDQUFDO1lBQ2QsS0FBSyxJQUFJeEMsUUFBUXNCLE1BQU0sTUFBTXRCO1lBQzdCLElBQUksQ0FBQ3lDLFVBQVVBLFdBQVdEO1lBQzFCLEtBQUssSUFBSXhDLFFBQVF5QyxTQUFTO2dCQUN0Qm5CLE1BQU03QixJQUFJLENBQUNPO2dCQUNYLE1BQU1BO1lBQ1Y7UUFDSjtJQUNKO0FBQ0o7QUFDQSxTQUFTaUMsOEJBQThCVSxLQUFLLEVBQUVDLEtBQUs7SUFDL0MsSUFBSUQsU0FBU0MsT0FBTyxPQUFPLENBQUNsRCxVQUFVaUQsTUFBTUMsTUFBTWxEO0lBQ2xELElBQUlpRCxPQUFPLE9BQU9BO0lBQ2xCLElBQUlDLE9BQU8sT0FBT0E7QUFDdEI7QUFDQSxTQUFTVCxpQ0FBaUNVLEdBQUc7SUFDekMsT0FBT0EsR0FBRyxDQUFDLEVBQUUsQ0FBQ0MsV0FBVyxLQUFLRCxJQUFJRSxLQUFLLENBQUM7QUFDNUM7QUFJQSxTQUFTQywwQ0FBMEMzRSxLQUFLLEVBQUU0RSxPQUFPLEVBQUUxRSxPQUFPO0lBQ3RFLElBQUk2RCxVQUFVLENBQUMsR0FBR2pFLDBDQUFhLEVBQUcsSUFBSSxJQUFLLElBQUdnQyx5Q0FBd0MsS0FBTSxFQUFFO0lBQzlGLElBQUksRUFBRXpCLFVBQVVBLFFBQVEsRUFBRVksT0FBT0EsS0FBSyxFQUFFNEQsWUFBWUEsVUFBVSxFQUFFLEdBQUc3RTtJQUNuRSxJQUFJc0QsU0FBUyxDQUFDLEdBQUd4RCwwQ0FBYSxFQUFHO1FBQzdCLElBQUkrRSxZQUFZLE9BQU9BO1FBQ3ZCLElBQUl6QyxRQUFRMkIsUUFBUWhDLEtBQUssQ0FBQztZQUN0QjFCLFVBQVVBO1lBQ1ZZLE9BQU9BO1FBQ1gsR0FBR2Y7UUFDSCxPQUFPMEUsUUFBUXhDO0lBQ25CLEdBQUc7UUFDQzJCO1FBQ0ExRDtRQUNBWTtRQUNBNEQ7UUFDQTNFO1FBQ0EwRTtLQUNIO0lBQ0QsT0FBT3RCO0FBQ1g7QUFHQTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHLFNBQVN3QiwwQ0FBMEN6QyxJQUFJLEVBQUV3QyxVQUFVO0lBQ25FLDBEQUEwRDtJQUMxRCxJQUFJLE9BQU9BLFdBQVdFLFdBQVcsS0FBSyxZQUFZLE9BQU9GLFdBQVdFLFdBQVcsQ0FBQzFDLEtBQUtLLEdBQUc7SUFDeEYsdUNBQXVDO0lBQ3ZDLE9BQU9MLEtBQUt2QixVQUFVO0FBQzFCO0FBQ0EsU0FBU2tFLDBDQUEwQ1osUUFBUTtJQUN2RCxPQUFPYSwwQ0FBMENiLFVBQVU7QUFDL0Q7QUFDQSxTQUFTYSwwQ0FBMENiLFFBQVEsRUFBRWpDLEtBQUs7SUFDOUQsSUFBSUEsUUFBUSxHQUFHLE9BQU8rQztJQUN0QixJQUFJQyxJQUFJO0lBQ1IsS0FBSyxJQUFJeEQsUUFBUXlDLFNBQVM7UUFDdEIsSUFBSWUsTUFBTWhELE9BQU8sT0FBT1I7UUFDeEJ3RDtJQUNKO0FBQ0o7QUFDQSxTQUFTQywwQ0FBMENoQixRQUFRO0lBQ3ZELElBQUlpQixXQUFXSDtJQUNmLEtBQUssSUFBSWxFLFNBQVNvRCxTQUFTaUIsV0FBV3JFO0lBQ3RDLE9BQU9xRTtBQUNYO0FBQ0EsU0FBU0MseUNBQXlDVCxVQUFVLEVBQUVVLENBQUMsRUFBRUMsQ0FBQztJQUM5RCxnRUFBZ0U7SUFDaEUsSUFBSUQsRUFBRTlDLFNBQVMsS0FBSytDLEVBQUUvQyxTQUFTLEVBQUUsT0FBTzhDLEVBQUVwRCxLQUFLLEdBQUdxRCxFQUFFckQsS0FBSztJQUN6RCw0SEFBNEg7SUFDNUgsNklBQTZJO0lBQzdJLDZCQUE2QjtJQUM3QixJQUFJc0QsYUFBYTtXQUNWQyxtQ0FBbUNiLFlBQVlVO1FBQ2xEQTtLQUNIO0lBQ0QsSUFBSUksYUFBYTtXQUNWRCxtQ0FBbUNiLFlBQVlXO1FBQ2xEQTtLQUNIO0lBQ0QsSUFBSUksMkJBQTJCSCxXQUFXZixLQUFLLENBQUMsR0FBR2lCLFdBQVdFLE1BQU0sRUFBRUMsU0FBUyxDQUFDLENBQUNQLEdBQUdKLElBQUlJLE1BQU1JLFVBQVUsQ0FBQ1IsRUFBRTtJQUMzRyxJQUFJUyw2QkFBNkIsQ0FBQyxHQUFHO1FBQ2pDLGtFQUFrRTtRQUNsRUwsSUFBSUUsVUFBVSxDQUFDRyx5QkFBeUI7UUFDeENKLElBQUlHLFVBQVUsQ0FBQ0MseUJBQXlCO1FBQ3hDLE9BQU9MLEVBQUVwRCxLQUFLLEdBQUdxRCxFQUFFckQsS0FBSztJQUM1QjtJQUNBLHFIQUFxSDtJQUNySCxJQUFJc0QsV0FBV0ssU0FBUyxDQUFDLENBQUN6RCxPQUFPQSxTQUFTbUQsTUFBTSxHQUFHLE9BQU87U0FDckQsSUFBSUcsV0FBV0csU0FBUyxDQUFDLENBQUN6RCxPQUFPQSxTQUFTa0QsTUFBTSxHQUFHLE9BQU8sQ0FBQztJQUNoRSxLQUFLO0lBQ0wsT0FBTyxDQUFDO0FBQ1o7QUFDQSxTQUFTRyxtQ0FBbUNiLFVBQVUsRUFBRXhDLElBQUk7SUFDeEQsSUFBSTBELFVBQVUsRUFBRTtJQUNoQixNQUFNLENBQUMxRCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS0ksU0FBUyxLQUFLLEtBQUs7UUFDdkVKLE9BQU93QyxXQUFXbUIsT0FBTyxDQUFDM0QsS0FBS0ksU0FBUztRQUN4Q3NELFFBQVFFLE9BQU8sQ0FBQzVEO0lBQ3BCO0lBQ0EsT0FBTzBEO0FBQ1g7QUFHQSxNQUFNRyw4QkFBOEIsSUFBSWhDO0FBQ3hDLFNBQVNpQywwQ0FBMEN0QixVQUFVO0lBQ3pELElBQUl0RCxRQUFRMkUsNEJBQTRCaEQsR0FBRyxDQUFDMkI7SUFDNUMsSUFBSXRELFNBQVMsTUFBTSxPQUFPQTtJQUMxQkEsUUFBUTtJQUNSLElBQUk2RSxhQUFhLENBQUNuRjtRQUNkLEtBQUssSUFBSVUsUUFBUVYsTUFBTSxJQUFJVSxLQUFLaEIsSUFBSSxLQUFLLFdBQVd5RixXQUFXLENBQUMsR0FBR3RCLHlDQUF3QyxFQUFHbkQsTUFBTWtEO2FBQy9HdEQ7SUFDVDtJQUNBNkUsV0FBV3ZCO0lBQ1hxQiw0QkFBNEJyQyxHQUFHLENBQUNnQixZQUFZdEQ7SUFDNUMsT0FBT0E7QUFDWDtBQU9nbEIsQ0FDaGxCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zL2Rpc3QvaW1wb3J0Lm1qcz8xZTA2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkdHlXNkEkcmVhY3QsIHt1c2VNZW1vIGFzICR0eVc2QSR1c2VNZW1vfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICRjMWQ3ZmIyZWM5MWJhZTcxJHZhciRJdGVtKHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kYzFkN2ZiMmVjOTFiYWU3MSR2YXIkSXRlbS5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcywgY29udGV4dCkge1xuICAgIGxldCB7IGNoaWxkSXRlbXM6IGNoaWxkSXRlbXMsIHRpdGxlOiB0aXRsZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICBsZXQgcmVuZGVyZWQgPSBwcm9wcy50aXRsZSB8fCBwcm9wcy5jaGlsZHJlbjtcbiAgICBsZXQgdGV4dFZhbHVlID0gcHJvcHMudGV4dFZhbHVlIHx8ICh0eXBlb2YgcmVuZGVyZWQgPT09IFwic3RyaW5nXCIgPyByZW5kZXJlZCA6IFwiXCIpIHx8IHByb3BzW1wiYXJpYS1sYWJlbFwiXSB8fCBcIlwiO1xuICAgIC8vIHN1cHByZXNzVGV4dFZhbHVlV2FybmluZyBpcyB1c2VkIGluIGNvbXBvbmVudHMgbGlrZSBUYWJzLCB3aGljaCBkb24ndCBoYXZlIHR5cGUgdG8gc2VsZWN0IHN1cHBvcnQuXG4gICAgaWYgKCF0ZXh0VmFsdWUgJiYgIShjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuc3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nKSkgY29uc29sZS53YXJuKFwiPEl0ZW0+IHdpdGggbm9uLXBsYWluIHRleHQgY29udGVudHMgaXMgdW5zdXBwb3J0ZWQgYnkgdHlwZSB0byBzZWxlY3QgZm9yIGFjY2Vzc2liaWxpdHkuIFBsZWFzZSBhZGQgYSBgdGV4dFZhbHVlYCBwcm9wLlwiKTtcbiAgICB5aWVsZCB7XG4gICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIHJlbmRlcmVkOiByZW5kZXJlZCxcbiAgICAgICAgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6ICRjMWQ3ZmIyZWM5MWJhZTcxJHZhciRoYXNDaGlsZEl0ZW1zKHByb3BzKSxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkSXRlbXMpIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkSXRlbXMpeWllbGQge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaGlsZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgKDAsICR0eVc2QSRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGNoaWxkKT0+e1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIGl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG5mdW5jdGlvbiAkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkaGFzQ2hpbGRJdGVtcyhwcm9wcykge1xuICAgIGlmIChwcm9wcy5oYXNDaGlsZEl0ZW1zICE9IG51bGwpIHJldHVybiBwcm9wcy5oYXNDaGlsZEl0ZW1zO1xuICAgIGlmIChwcm9wcy5jaGlsZEl0ZW1zKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAocHJvcHMudGl0bGUgJiYgKDAsICR0eVc2QSRyZWFjdCkuQ2hpbGRyZW4uY291bnQocHJvcHMuY2hpbGRyZW4pID4gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkYzFkN2ZiMmVjOTFiYWU3MSRleHBvcnQkNmQwODc3M2QyZTY2ZjhmMiA9ICRjMWQ3ZmIyZWM5MWJhZTcxJHZhciRJdGVtO1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQ5ZmM0ODUyNzcxZDA3OWViJHZhciRTZWN0aW9uKHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kOWZjNDg1Mjc3MWQwNzllYiR2YXIkU2VjdGlvbi5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcykge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgdGl0bGU6IHRpdGxlLCBpdGVtczogaXRlbXMgfSA9IHByb3BzO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJzZWN0aW9uXCIsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcbiAgICAgICAgcmVuZGVyZWQ6IHRpdGxlLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogcHJvcHNbXCJhcmlhLWxhYmVsXCJdLFxuICAgICAgICAqY2hpbGROb2RlcyAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zKSB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wcy5jaGlsZHJlbiB3YXMgYSBmdW5jdGlvbiBidXQgcHJvcHMuaXRlbXMgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlcjogY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCogaXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJDlmYzQ4NTI3NzFkMDc5ZWIkZXhwb3J0JDZlMmM4ZjA4MTFhNDc0Y2UgPSAkOWZjNDg1Mjc3MWQwNzllYiR2YXIkU2VjdGlvbjtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY2xhc3MgJGViMjI0MGZjMzlhNTdmYTUkZXhwb3J0JGJmNzg4ZGQzNTVlM2E0MDEge1xuICAgIGJ1aWxkKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHJldHVybiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkaXRlcmFibGUoKCk9PnRoaXMuaXRlcmF0ZUNvbGxlY3Rpb24ocHJvcHMpKTtcbiAgICB9XG4gICAgKml0ZXJhdGVDb2xsZWN0aW9uKHByb3BzKSB7XG4gICAgICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgaXRlbXM6IGl0ZW1zIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW1zKSB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wcy5jaGlsZHJlbiB3YXMgYSBmdW5jdGlvbiBidXQgcHJvcHMuaXRlbXMgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgcHJvcHMuaXRlbXMpeWllbGQqIHRoaXMuZ2V0RnVsbE5vZGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IGNoaWxkcmVuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgKDAsICR0eVc2QSRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGNoaWxkKT0+e1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcyl7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5nZXRGdWxsTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0S2V5KGl0ZW0sIHBhcnRpYWxOb2RlLCBzdGF0ZSwgcGFyZW50S2V5KSB7XG4gICAgICAgIGlmIChpdGVtLmtleSAhPSBudWxsKSByZXR1cm4gaXRlbS5rZXk7XG4gICAgICAgIGlmIChwYXJ0aWFsTm9kZS50eXBlID09PSBcImNlbGxcIiAmJiBwYXJ0aWFsTm9kZS5rZXkgIT0gbnVsbCkgcmV0dXJuIGAke3BhcmVudEtleX0ke3BhcnRpYWxOb2RlLmtleX1gO1xuICAgICAgICBsZXQgdiA9IHBhcnRpYWxOb2RlLnZhbHVlO1xuICAgICAgICBpZiAodiAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX3Zfa2V5O1xuICAgICAgICAgICAgbGV0IGtleSA9IChfdl9rZXkgPSB2LmtleSkgIT09IG51bGwgJiYgX3Zfa2V5ICE9PSB2b2lkIDAgPyBfdl9rZXkgOiB2LmlkO1xuICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBrZXkgZm91bmQgZm9yIGl0ZW1cIik7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnRLZXkgPyBgJHtwYXJlbnRLZXl9LiR7cGFydGlhbE5vZGUuaW5kZXh9YCA6IGAkLiR7cGFydGlhbE5vZGUuaW5kZXh9YDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRTdGF0ZShzdGF0ZSwgcGFydGlhbE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlbmRlcmVyOiBwYXJ0aWFsTm9kZS5yZW5kZXJlciB8fCBzdGF0ZS5yZW5kZXJlclxuICAgICAgICB9O1xuICAgIH1cbiAgICAqZ2V0RnVsbE5vZGUocGFydGlhbE5vZGUsIHN0YXRlLCBwYXJlbnRLZXksIHBhcmVudE5vZGUpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIHZhbHVlIGluc3RlYWQgb2YgYW4gZWxlbWVudCBvbiB0aGUgbm9kZSwgYW5kIGEgcGFyZW50IHJlbmRlcmVyIGZ1bmN0aW9uIGlzIGF2YWlsYWJsZSxcbiAgICAgICAgLy8gdXNlIGl0IHRvIHJlbmRlciBhbiBlbGVtZW50IGZvciB0aGUgdmFsdWUuXG4gICAgICAgIGxldCBlbGVtZW50ID0gcGFydGlhbE5vZGUuZWxlbWVudDtcbiAgICAgICAgaWYgKCFlbGVtZW50ICYmIHBhcnRpYWxOb2RlLnZhbHVlICYmIHN0YXRlICYmIHN0YXRlLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5jYWNoZS5nZXQocGFydGlhbE5vZGUudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiAoIWNhY2hlZC5zaG91bGRJbnZhbGlkYXRlIHx8ICFjYWNoZWQuc2hvdWxkSW52YWxpZGF0ZSh0aGlzLmNvbnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZC5pbmRleCA9IHBhcnRpYWxOb2RlLmluZGV4O1xuICAgICAgICAgICAgICAgIGNhY2hlZC5wYXJlbnRLZXkgPSBwYXJlbnROb2RlID8gcGFyZW50Tm9kZS5rZXkgOiBudWxsO1xuICAgICAgICAgICAgICAgIHlpZWxkIGNhY2hlZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50ID0gc3RhdGUucmVuZGVyZXIocGFydGlhbE5vZGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYW4gZWxlbWVudCB3aXRoIGEgZ2V0Q29sbGVjdGlvbk5vZGUgZnVuY3Rpb24gb24gaXRzIHR5cGUsIHRoZW4gaXQncyBhIHN1cHBvcnRlZCBjb21wb25lbnQuXG4gICAgICAgIC8vIENhbGwgdGhpcyBmdW5jdGlvbiB0byBnZXQgYSBwYXJ0aWFsIG5vZGUsIGFuZCByZWN1cnNpdmVseSBidWlsZCBhIGZ1bGwgbm9kZSBmcm9tIHRoZXJlLlxuICAgICAgICBpZiAoKDAsICR0eVc2QSRyZWFjdCkuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHR5cGUuZ2V0Q29sbGVjdGlvbk5vZGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJmdW5jdGlvblwiID8gZWxlbWVudC50eXBlLm5hbWUgOiBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGVsZW1lbnQgPCR7bmFtZX0+IGluIGNvbGxlY3Rpb24uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHR5cGUuZ2V0Q29sbGVjdGlvbk5vZGUoZWxlbWVudC5wcm9wcywgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHBhcnRpYWxOb2RlLmluZGV4O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGNoaWxkTm9kZXMubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUoIXJlc3VsdC5kb25lICYmIHJlc3VsdC52YWx1ZSl7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsTm9kZS5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGxldCBub2RlS2V5ID0gY2hpbGROb2RlLmtleTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVLZXkpIG5vZGVLZXkgPSBjaGlsZE5vZGUuZWxlbWVudCA/IG51bGwgOiB0aGlzLmdldEtleShlbGVtZW50LCBwYXJ0aWFsTm9kZSwgc3RhdGUsIHBhcmVudEtleSk7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5nZXRGdWxsTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkTm9kZSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBub2RlS2V5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXI6ICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjb21wb3NlKHBhcnRpYWxOb2RlLndyYXBwZXIsIGNoaWxkTm9kZS53cmFwcGVyKVxuICAgICAgICAgICAgICAgIH0sIHRoaXMuZ2V0Q2hpbGRTdGF0ZShzdGF0ZSwgY2hpbGROb2RlKSwgcGFyZW50S2V5ID8gYCR7cGFyZW50S2V5fSR7ZWxlbWVudC5rZXl9YCA6IGVsZW1lbnQua2V5LCBwYXJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGVzXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIGNoaWxkcmVuKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIG5vZGUgYmFzZWQgb24gaXRzIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBjaGlsZE5vZGUudmFsdWUgfHwgcGFydGlhbE5vZGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnZhbHVlKSB0aGlzLmNhY2hlLnNldChub2RlLnZhbHVlLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHBhcnRpYWwgbm9kZSBtYXkgaGF2ZSBzcGVjaWZpZWQgYSB0eXBlIGZvciB0aGUgY2hpbGQgaW4gb3JkZXIgdG8gc3BlY2lmeSBhIGNvbnN0cmFpbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBmdWxsIG5vZGUgdGhhdCB3YXMgYnVpbHQgcmVjdXJzaXZlbHkgbWF0Y2hlcyB0aGlzIHR5cGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsTm9kZS50eXBlICYmIG5vZGUudHlwZSAhPT0gcGFydGlhbE5vZGUudHlwZSkgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIDwkeyRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjYXBpdGFsaXplKG5vZGUudHlwZSl9PiBpbiA8JHskZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZShwYXJlbnROb2RlLnR5cGUpfT4uIE9ubHkgPCR7JGViMjI0MGZjMzlhNTdmYTUkdmFyJGNhcGl0YWxpemUocGFydGlhbE5vZGUudHlwZSl9PiBpcyBzdXBwb3J0ZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNoaWxkTm9kZXMubmV4dChjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIGludmFsaWQgZWxlbWVudHNcbiAgICAgICAgaWYgKHBhcnRpYWxOb2RlLmtleSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIC8vIENyZWF0ZSBmdWxsIG5vZGVcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSB0aGlzO1xuICAgICAgICBsZXQgbm9kZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHBhcnRpYWxOb2RlLnR5cGUsXG4gICAgICAgICAgICBwcm9wczogcGFydGlhbE5vZGUucHJvcHMsXG4gICAgICAgICAgICBrZXk6IHBhcnRpYWxOb2RlLmtleSxcbiAgICAgICAgICAgIHBhcmVudEtleTogcGFyZW50Tm9kZSA/IHBhcmVudE5vZGUua2V5IDogbnVsbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJ0aWFsTm9kZS52YWx1ZSxcbiAgICAgICAgICAgIGxldmVsOiBwYXJlbnROb2RlID8gcGFyZW50Tm9kZS5sZXZlbCArIDEgOiAwLFxuICAgICAgICAgICAgaW5kZXg6IHBhcnRpYWxOb2RlLmluZGV4LFxuICAgICAgICAgICAgcmVuZGVyZWQ6IHBhcnRpYWxOb2RlLnJlbmRlcmVkLFxuICAgICAgICAgICAgdGV4dFZhbHVlOiBwYXJ0aWFsTm9kZS50ZXh0VmFsdWUsXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGFydGlhbE5vZGVbXCJhcmlhLWxhYmVsXCJdLFxuICAgICAgICAgICAgd3JhcHBlcjogcGFydGlhbE5vZGUud3JhcHBlcixcbiAgICAgICAgICAgIHNob3VsZEludmFsaWRhdGU6IHBhcnRpYWxOb2RlLnNob3VsZEludmFsaWRhdGUsXG4gICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBwYXJ0aWFsTm9kZS5oYXNDaGlsZE5vZGVzLFxuICAgICAgICAgICAgY2hpbGROb2RlczogJGViMjI0MGZjMzlhNTdmYTUkdmFyJGl0ZXJhYmxlKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnRpYWxOb2RlLmhhc0NoaWxkTm9kZXMpIHJldHVybjtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHBhcnRpYWxOb2RlLmNoaWxkTm9kZXMoKSl7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBjaGlsZCBrZXlzIGFyZSBnbG9iYWxseSB1bmlxdWUgYnkgcHJlcGVuZGluZyB0aGUgcGFyZW50IG5vZGUncyBrZXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSAvLyBUT0RPOiBSZW1vdmUgdGhpcyBsaW5lIGVudGlyZWx5IGFuZCBlbmZvcmNlIHRoYXQgdXNlcnMgYWx3YXlzIHByb3ZpZGUgdW5pcXVlIGtleXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnJlbnRseSB0aGlzIGxpbmUgd2lsbCBoYXZlIGlzc3VlcyB3aGVuIGEgcGFyZW50IGhhcyBhIGtleSBgYWAgYW5kIGEgY2hpbGQgd2l0aCBrZXkgYGJjYFxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgYW5vdGhlciBwYXJlbnQgaGFzIGtleSBgYWJgIGFuZCBpdHMgY2hpbGQgaGFzIGEga2V5IGBjYC4gVGhlIGNvbWJpbmVkIGtleXMgd291bGQgcmVzdWx0IGluIGJvdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hpbGRyZW4gaGF2aW5nIGEga2V5IG9mIGBhYmNgLlxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5rZXkgPSBgJHtub2RlLmtleX0ke2NoaWxkLmtleX1gO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSBidWlsZGVyLmdldEZ1bGxOb2RlKGNoaWxkLCBidWlsZGVyLmdldENoaWxkU3RhdGUoc3RhdGUsIGNoaWxkKSwgbm9kZS5rZXksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgICAgeWllbGQgbm9kZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxufVxuLy8gV3JhcHMgYW4gaXRlcmF0b3IgZnVuY3Rpb24gYXMgYW4gaXRlcmFibGUgb2JqZWN0LCBhbmQgY2FjaGVzIHRoZSByZXN1bHRzLlxuZnVuY3Rpb24gJGViMjI0MGZjMzlhNTdmYTUkdmFyJGl0ZXJhYmxlKGl0ZXJhdG9yKSB7XG4gICAgbGV0IGNhY2hlID0gW107XG4gICAgbGV0IGl0ZXJhYmxlID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICAqW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBjYWNoZSl5aWVsZCBpdGVtO1xuICAgICAgICAgICAgaWYgKCFpdGVyYWJsZSkgaXRlcmFibGUgPSBpdGVyYXRvcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVyYWJsZSl7XG4gICAgICAgICAgICAgICAgY2FjaGUucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjb21wb3NlKG91dGVyLCBpbm5lcikge1xuICAgIGlmIChvdXRlciAmJiBpbm5lcikgcmV0dXJuIChlbGVtZW50KT0+b3V0ZXIoaW5uZXIoZWxlbWVudCkpO1xuICAgIGlmIChvdXRlcikgcmV0dXJuIG91dGVyO1xuICAgIGlmIChpbm5lcikgcmV0dXJuIGlubmVyO1xufVxuZnVuY3Rpb24gJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNhcGl0YWxpemUoc3RyKSB7XG4gICAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuXG5cblxuZnVuY3Rpb24gJDc2MTNiMTU5MmQ0MWIwOTIkZXhwb3J0JDZjZDI4ODE0ZDkyZmE5YzkocHJvcHMsIGZhY3RvcnksIGNvbnRleHQpIHtcbiAgICBsZXQgYnVpbGRlciA9ICgwLCAkdHlXNkEkdXNlTWVtbykoKCk9Pm5ldyAoMCwgJGViMjI0MGZjMzlhNTdmYTUkZXhwb3J0JGJmNzg4ZGQzNTVlM2E0MDEpKCksIFtdKTtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIGl0ZW1zOiBpdGVtcywgY29sbGVjdGlvbjogY29sbGVjdGlvbiB9ID0gcHJvcHM7XG4gICAgbGV0IHJlc3VsdCA9ICgwLCAkdHlXNkEkdXNlTWVtbykoKCk9PntcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24pIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICBsZXQgbm9kZXMgPSBidWlsZGVyLmJ1aWxkKHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICAgIGl0ZW1zOiBpdGVtc1xuICAgICAgICB9LCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhY3Rvcnkobm9kZXMpO1xuICAgIH0sIFtcbiAgICAgICAgYnVpbGRlcixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBmYWN0b3J5XG4gICAgXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQxMDA1NTMwZWRhMDE2YzEzKG5vZGUsIGNvbGxlY3Rpb24pIHtcbiAgICAvLyBOZXcgQVBJOiBjYWxsIGNvbGxlY3Rpb24uZ2V0Q2hpbGRyZW4gd2l0aCB0aGUgbm9kZSBrZXkuXG4gICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uLmdldENoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb2xsZWN0aW9uLmdldENoaWxkcmVuKG5vZGUua2V5KTtcbiAgICAvLyBPbGQgQVBJOiBhY2Nlc3MgY2hpbGROb2RlcyBkaXJlY3RseS5cbiAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzO1xufVxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JGZiZGVhYTZhNzY2OTRmNzEoaXRlcmFibGUpIHtcbiAgICByZXR1cm4gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDVmMzM5OGY4NzMzZjkwZTIoaXRlcmFibGUsIDApO1xufVxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDVmMzM5OGY4NzMzZjkwZTIoaXRlcmFibGUsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgaXRlbSBvZiBpdGVyYWJsZSl7XG4gICAgICAgIGlmIChpID09PSBpbmRleCkgcmV0dXJuIGl0ZW07XG4gICAgICAgIGkrKztcbiAgICB9XG59XG5mdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNzQ3NWIyYzY0NTM5ZTRjZihpdGVyYWJsZSkge1xuICAgIGxldCBsYXN0SXRlbSA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiBpdGVyYWJsZSlsYXN0SXRlbSA9IHZhbHVlO1xuICAgIHJldHVybiBsYXN0SXRlbTtcbn1cbmZ1bmN0aW9uICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ4YzQzNGIzYTdhNGRhZDYoY29sbGVjdGlvbiwgYSwgYikge1xuICAgIC8vIElmIHRoZSB0d28gbm9kZXMgaGF2ZSB0aGUgc2FtZSBwYXJlbnQsIGNvbXBhcmUgdGhlaXIgaW5kaWNlcy5cbiAgICBpZiAoYS5wYXJlbnRLZXkgPT09IGIucGFyZW50S2V5KSByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgLy8gT3RoZXJ3aXNlLCBjb2xsZWN0IGFsbCBvZiB0aGUgYW5jZXN0b3JzIGZyb20gZWFjaCBub2RlLCBhbmQgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgZG9lc24ndCBtYXRjaCBzdGFydGluZyBmcm9tIHRoZSByb290LlxuICAgIC8vIEluY2x1ZGUgdGhlIGJhc2Ugbm9kZXMgaW4gY2FzZSB3ZSBhcmUgY29tcGFyaW5nIG5vZGVzIG9mIGRpZmZlcmVudCBsZXZlbHMgc28gdGhhdCB3ZSBjYW4gY29tcGFyZSB0aGUgaGlnaGVyIG5vZGUgdG8gdGhlIGxvd2VyIGxldmVsIG5vZGUnc1xuICAgIC8vIGFuY2VzdG9yIG9mIHRoZSBzYW1lIGxldmVsXG4gICAgbGV0IGFBbmNlc3RvcnMgPSBbXG4gICAgICAgIC4uLiRjNWEyNGJjNDc4NjUyYjVmJHZhciRnZXRBbmNlc3RvcnMoY29sbGVjdGlvbiwgYSksXG4gICAgICAgIGFcbiAgICBdO1xuICAgIGxldCBiQW5jZXN0b3JzID0gW1xuICAgICAgICAuLi4kYzVhMjRiYzQ3ODY1MmI1ZiR2YXIkZ2V0QW5jZXN0b3JzKGNvbGxlY3Rpb24sIGIpLFxuICAgICAgICBiXG4gICAgXTtcbiAgICBsZXQgZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yID0gYUFuY2VzdG9ycy5zbGljZSgwLCBiQW5jZXN0b3JzLmxlbmd0aCkuZmluZEluZGV4KChhLCBpKT0+YSAhPT0gYkFuY2VzdG9yc1tpXSk7XG4gICAgaWYgKGZpcnN0Tm9uTWF0Y2hpbmdBbmNlc3RvciAhPT0gLTEpIHtcbiAgICAgICAgLy8gQ29tcGFyZSB0aGUgaW5kaWNlcyBvZiB0d28gY2hpbGRyZW4gd2l0aGluIHRoZSBjb21tb24gYW5jZXN0b3IuXG4gICAgICAgIGEgPSBhQW5jZXN0b3JzW2ZpcnN0Tm9uTWF0Y2hpbmdBbmNlc3Rvcl07XG4gICAgICAgIGIgPSBiQW5jZXN0b3JzW2ZpcnN0Tm9uTWF0Y2hpbmdBbmNlc3Rvcl07XG4gICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgaXNuJ3QgYSBub24gbWF0Y2hpbmcgYW5jZXN0b3IsIHdlIG1pZ2h0IGJlIGluIGEgY2FzZSB3aGVyZSBvbmUgb2YgdGhlIG5vZGVzIGlzIHRoZSBhbmNlc3RvciBvZiB0aGUgb3RoZXIuXG4gICAgaWYgKGFBbmNlc3RvcnMuZmluZEluZGV4KChub2RlKT0+bm9kZSA9PT0gYikgPj0gMCkgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoYkFuY2VzdG9ycy5maW5kSW5kZXgoKG5vZGUpPT5ub2RlID09PSBhKSA+PSAwKSByZXR1cm4gLTE7XG4gICAgLy8g8J+kt1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uICRjNWEyNGJjNDc4NjUyYjVmJHZhciRnZXRBbmNlc3RvcnMoY29sbGVjdGlvbiwgbm9kZSkge1xuICAgIGxldCBwYXJlbnRzID0gW107XG4gICAgd2hpbGUoKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5wYXJlbnRLZXkpICE9IG51bGwpe1xuICAgICAgICBub2RlID0gY29sbGVjdGlvbi5nZXRJdGVtKG5vZGUucGFyZW50S2V5KTtcbiAgICAgICAgcGFyZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbn1cblxuXG5jb25zdCAkNDUzY2M5ZjBkZjg5YzBhNSR2YXIkY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gJDQ1M2NjOWYwZGY4OWMwYTUkZXhwb3J0JDc3ZDVhYWZhZTRlMDk1YjIoY29sbGVjdGlvbikge1xuICAgIGxldCBjb3VudCA9ICQ0NTNjYzlmMGRmODljMGE1JHZhciRjYWNoZS5nZXQoY29sbGVjdGlvbik7XG4gICAgaWYgKGNvdW50ICE9IG51bGwpIHJldHVybiBjb3VudDtcbiAgICBjb3VudCA9IDA7XG4gICAgbGV0IGNvdW50SXRlbXMgPSAoaXRlbXMpPT57XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlbXMpaWYgKGl0ZW0udHlwZSA9PT0gXCJzZWN0aW9uXCIpIGNvdW50SXRlbXMoKDAsICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQxMDA1NTMwZWRhMDE2YzEzKShpdGVtLCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIGVsc2UgY291bnQrKztcbiAgICB9O1xuICAgIGNvdW50SXRlbXMoY29sbGVjdGlvbik7XG4gICAgJDQ1M2NjOWYwZGY4OWMwYTUkdmFyJGNhY2hlLnNldChjb2xsZWN0aW9uLCBjb3VudCk7XG4gICAgcmV0dXJuIGNvdW50O1xufVxuXG5cblxuXG5cblxuZXhwb3J0IHskYzFkN2ZiMmVjOTFiYWU3MSRleHBvcnQkNmQwODc3M2QyZTY2ZjhmMiBhcyBJdGVtLCAkOWZjNDg1Mjc3MWQwNzllYiRleHBvcnQkNmUyYzhmMDgxMWE0NzRjZSBhcyBTZWN0aW9uLCAkNzYxM2IxNTkyZDQxYjA5MiRleHBvcnQkNmNkMjg4MTRkOTJmYTljOSBhcyB1c2VDb2xsZWN0aW9uLCAkNDUzY2M5ZjBkZjg5YzBhNSRleHBvcnQkNzdkNWFhZmFlNGUwOTViMiBhcyBnZXRJdGVtQ291bnQsICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQxMDA1NTMwZWRhMDE2YzEzIGFzIGdldENoaWxkTm9kZXMsICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCRmYmRlYWE2YTc2Njk0ZjcxIGFzIGdldEZpcnN0SXRlbSwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDc0NzViMmM2NDUzOWU0Y2YgYXMgZ2V0TGFzdEl0ZW0sICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ1ZjMzOThmODczM2Y5MGUyIGFzIGdldE50aEl0ZW0sICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ4YzQzNGIzYTdhNGRhZDYgYXMgY29tcGFyZU5vZGVPcmRlciwgJGViMjI0MGZjMzlhNTdmYTUkZXhwb3J0JGJmNzg4ZGQzNTVlM2E0MDEgYXMgQ29sbGVjdGlvbkJ1aWxkZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbIiR0eVc2QSRyZWFjdCIsInVzZU1lbW8iLCIkdHlXNkEkdXNlTWVtbyIsIiRjMWQ3ZmIyZWM5MWJhZTcxJHZhciRJdGVtIiwicHJvcHMiLCJnZXRDb2xsZWN0aW9uTm9kZSIsImNvbnRleHQiLCJjaGlsZEl0ZW1zIiwidGl0bGUiLCJjaGlsZHJlbiIsInJlbmRlcmVkIiwidGV4dFZhbHVlIiwic3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nIiwiY29uc29sZSIsIndhcm4iLCJ0eXBlIiwiaGFzQ2hpbGROb2RlcyIsIiRjMWQ3ZmIyZWM5MWJhZTcxJHZhciRoYXNDaGlsZEl0ZW1zIiwiY2hpbGROb2RlcyIsImNoaWxkIiwidmFsdWUiLCJpdGVtcyIsIkNoaWxkcmVuIiwiZm9yRWFjaCIsInB1c2giLCJlbGVtZW50IiwiaGFzQ2hpbGRJdGVtcyIsImNvdW50IiwiJGMxZDdmYjJlYzkxYmFlNzEkZXhwb3J0JDZkMDg3NzNkMmU2NmY4ZjIiLCIkOWZjNDg1Mjc3MWQwNzllYiR2YXIkU2VjdGlvbiIsIkVycm9yIiwiaXRlbSIsInJlbmRlcmVyIiwiJDlmYzQ4NTI3NzFkMDc5ZWIkZXhwb3J0JDZlMmM4ZjA4MTFhNDc0Y2UiLCIkZWIyMjQwZmMzOWE1N2ZhNSRleHBvcnQkYmY3ODhkZDM1NWUzYTQwMSIsImJ1aWxkIiwiJGViMjI0MGZjMzlhNTdmYTUkdmFyJGl0ZXJhYmxlIiwiaXRlcmF0ZUNvbGxlY3Rpb24iLCJnZXRGdWxsTm9kZSIsImluZGV4Iiwibm9kZXMiLCJub2RlIiwiZ2V0S2V5IiwicGFydGlhbE5vZGUiLCJzdGF0ZSIsInBhcmVudEtleSIsImtleSIsInYiLCJfdl9rZXkiLCJpZCIsImdldENoaWxkU3RhdGUiLCJwYXJlbnROb2RlIiwiY2FjaGVkIiwiY2FjaGUiLCJnZXQiLCJzaG91bGRJbnZhbGlkYXRlIiwiaXNWYWxpZEVsZW1lbnQiLCJuYW1lIiwicmVzdWx0IiwibmV4dCIsImRvbmUiLCJjaGlsZE5vZGUiLCJub2RlS2V5Iiwid3JhcHBlciIsIiRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjb21wb3NlIiwic2V0IiwiJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNhcGl0YWxpemUiLCJidWlsZGVyIiwibGV2ZWwiLCJjb25zdHJ1Y3RvciIsIldlYWtNYXAiLCJpdGVyYXRvciIsIml0ZXJhYmxlIiwiU3ltYm9sIiwib3V0ZXIiLCJpbm5lciIsInN0ciIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCIkNzYxM2IxNTkyZDQxYjA5MiRleHBvcnQkNmNkMjg4MTRkOTJmYTljOSIsImZhY3RvcnkiLCJjb2xsZWN0aW9uIiwiJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDEwMDU1MzBlZGEwMTZjMTMiLCJnZXRDaGlsZHJlbiIsIiRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCRmYmRlYWE2YTc2Njk0ZjcxIiwiJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDVmMzM5OGY4NzMzZjkwZTIiLCJ1bmRlZmluZWQiLCJpIiwiJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDc0NzViMmM2NDUzOWU0Y2YiLCJsYXN0SXRlbSIsIiRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ4YzQzNGIzYTdhNGRhZDYiLCJhIiwiYiIsImFBbmNlc3RvcnMiLCIkYzVhMjRiYzQ3ODY1MmI1ZiR2YXIkZ2V0QW5jZXN0b3JzIiwiYkFuY2VzdG9ycyIsImZpcnN0Tm9uTWF0Y2hpbmdBbmNlc3RvciIsImxlbmd0aCIsImZpbmRJbmRleCIsInBhcmVudHMiLCJnZXRJdGVtIiwidW5zaGlmdCIsIiQ0NTNjYzlmMGRmODljMGE1JHZhciRjYWNoZSIsIiQ0NTNjYzlmMGRmODljMGE1JGV4cG9ydCQ3N2Q1YWFmYWU0ZTA5NWIyIiwiY291bnRJdGVtcyIsIkl0ZW0iLCJTZWN0aW9uIiwidXNlQ29sbGVjdGlvbiIsImdldEl0ZW1Db3VudCIsImdldENoaWxkTm9kZXMiLCJnZXRGaXJzdEl0ZW0iLCJnZXRMYXN0SXRlbSIsImdldE50aEl0ZW0iLCJjb21wYXJlTm9kZU9yZGVyIiwiQ29sbGVjdGlvbkJ1aWxkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/combobox/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/combobox/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useComboBoxState: () => (/* binding */ $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/list */ \"(ssr)/./node_modules/@react-stately/list/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e(props) {\n    var _collection_getItem, _collection_getItem1;\n    let { defaultFilter: defaultFilter, menuTrigger: menuTrigger = \"input\", allowsEmptyCollection: allowsEmptyCollection = false, allowsCustomValue: allowsCustomValue, shouldCloseOnBlur: shouldCloseOnBlur = true } = props;\n    let [showAllItems, setShowAllItems] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isFocused, setFocusedState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let onSelectionChange = (key)=>{\n        if (props.onSelectionChange) props.onSelectionChange(key);\n        // If key is the same, reset the inputValue and close the menu\n        // (scenario: user clicks on already selected option)\n        if (key === selectedKey) {\n            resetInputValue();\n            closeMenu();\n        }\n    };\n    var _props_items;\n    let { collection: collection, selectionManager: selectionManager, selectedKey: selectedKey, setSelectedKey: setSelectedKey, selectedItem: selectedItem, disabledKeys: disabledKeys } = (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.useSingleSelectListState)({\n        ...props,\n        onSelectionChange: onSelectionChange,\n        items: (_props_items = props.items) !== null && _props_items !== void 0 ? _props_items : props.defaultItems\n    });\n    var _props_defaultInputValue, _ref;\n    let [inputValue, setInputValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__.useControlledState)(props.inputValue, (_ref = (_props_defaultInputValue = props.defaultInputValue) !== null && _props_defaultInputValue !== void 0 ? _props_defaultInputValue : (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _ref !== void 0 ? _ref : \"\", props.onInputChange);\n    // Preserve original collection so we can show all items on demand\n    let originalCollection = collection;\n    let filteredCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.items != null || !defaultFilter ? collection : $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, defaultFilter), [\n        collection,\n        inputValue,\n        defaultFilter,\n        props.items\n    ]);\n    let [lastCollection, setLastCollection] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(filteredCollection);\n    // Track what action is attempting to open the menu\n    let menuOpenTrigger = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"focus\");\n    let onOpenChange = (open)=>{\n        if (props.onOpenChange) props.onOpenChange(open, open ? menuOpenTrigger.current : undefined);\n        selectionManager.setFocused(open);\n        if (!open) selectionManager.setFocusedKey(null);\n    };\n    let triggerState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_3__.useOverlayTriggerState)({\n        ...props,\n        onOpenChange: onOpenChange,\n        isOpen: undefined,\n        defaultOpen: undefined\n    });\n    let open = (focusStrategy = null, trigger)=>{\n        let displayAllItems = trigger === \"manual\" || trigger === \"focus\" && menuTrigger === \"focus\";\n        // Prevent open operations from triggering if there is nothing to display\n        // Also prevent open operations from triggering if items are uncontrolled but defaultItems is empty, even if displayAllItems is true.\n        // This is to prevent comboboxes with empty defaultItems from opening but allow controlled items comboboxes to open even if the inital list is empty (assumption is user will provide swap the empty list with a base list via onOpenChange returning `menuTrigger` manual)\n        if (allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) {\n            if (displayAllItems && !triggerState.isOpen && props.items === undefined) setShowAllItems(true);\n            menuOpenTrigger.current = trigger;\n            setFocusStrategy(focusStrategy);\n            triggerState.open();\n        }\n    };\n    let toggle = (focusStrategy = null, trigger)=>{\n        let displayAllItems = trigger === \"manual\" || trigger === \"focus\" && menuTrigger === \"focus\";\n        // If the menu is closed and there is nothing to display, early return so toggle isn't called to prevent extraneous onOpenChange\n        if (!(allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) && !triggerState.isOpen) return;\n        if (displayAllItems && !triggerState.isOpen && props.items === undefined) setShowAllItems(true);\n        // Only update the menuOpenTrigger if menu is currently closed\n        if (!triggerState.isOpen) menuOpenTrigger.current = trigger;\n        toggleMenu(focusStrategy);\n    };\n    let updateLastCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setLastCollection(showAllItems ? originalCollection : filteredCollection);\n    }, [\n        showAllItems,\n        originalCollection,\n        filteredCollection\n    ]);\n    // If menu is going to close, save the current collection so we can freeze the displayed collection when the\n    // user clicks outside the popover to close the menu. Prevents the menu contents from updating as the menu closes.\n    let toggleMenu = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        if (triggerState.isOpen) updateLastCollection();\n        setFocusStrategy(focusStrategy);\n        triggerState.toggle();\n    }, [\n        triggerState,\n        updateLastCollection\n    ]);\n    let closeMenu = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (triggerState.isOpen) {\n            updateLastCollection();\n            triggerState.close();\n        }\n    }, [\n        triggerState,\n        updateLastCollection\n    ]);\n    let [lastValue, setLastValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(inputValue);\n    let resetInputValue = ()=>{\n        var _collection_getItem;\n        var _collection_getItem_textValue;\n        let itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n        setLastValue(itemText);\n        setInputValue(itemText);\n    };\n    var _props_selectedKey, _ref1;\n    let lastSelectedKey = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)((_ref1 = (_props_selectedKey = props.selectedKey) !== null && _props_selectedKey !== void 0 ? _props_selectedKey : props.defaultSelectedKey) !== null && _ref1 !== void 0 ? _ref1 : null);\n    var _collection_getItem_textValue;\n    let lastSelectedKeyText = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)((_collection_getItem_textValue = (_collection_getItem1 = collection.getItem(selectedKey)) === null || _collection_getItem1 === void 0 ? void 0 : _collection_getItem1.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\");\n    // intentional omit dependency array, want this to happen on every render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _collection_getItem;\n        // Open and close menu automatically when the input value changes if the input is focused,\n        // and there are items in the collection or allowEmptyCollection is true.\n        if (isFocused && (filteredCollection.size > 0 || allowsEmptyCollection) && !triggerState.isOpen && inputValue !== lastValue && menuTrigger !== \"manual\") open(null, \"input\");\n        // Close the menu if the collection is empty. Don't close menu if filtered collection size is 0\n        // but we are currently showing all items via button press\n        if (!showAllItems && !allowsEmptyCollection && triggerState.isOpen && filteredCollection.size === 0) closeMenu();\n        // Close when an item is selected.\n        if (selectedKey != null && selectedKey !== lastSelectedKey.current) closeMenu();\n        // Clear focused key when input value changes and display filtered collection again.\n        if (inputValue !== lastValue) {\n            selectionManager.setFocusedKey(null);\n            setShowAllItems(false);\n            // Set selectedKey to null when the user clears the input.\n            // If controlled, this is the application developer's responsibility.\n            if (inputValue === \"\" && (props.inputValue === undefined || props.selectedKey === undefined)) setSelectedKey(null);\n        }\n        // If the selectedKey changed, update the input value.\n        // Do nothing if both inputValue and selectedKey are controlled.\n        // In this case, it's the user's responsibility to update inputValue in onSelectionChange.\n        if (selectedKey !== lastSelectedKey.current && (props.inputValue === undefined || props.selectedKey === undefined)) resetInputValue();\n        else if (lastValue !== inputValue) setLastValue(inputValue);\n        var _collection_getItem_textValue;\n        // Update the inputValue if the selected item's text changes from its last tracked value.\n        // This is to handle cases where a selectedKey is specified but the items aren't available (async loading) or the selected item's text value updates.\n        // Only reset if the user isn't currently within the field so we don't erroneously modify user input.\n        // If inputValue is controlled, it is the user's responsibility to update the inputValue when items change.\n        let selectedItemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n        if (!isFocused && selectedKey != null && props.inputValue === undefined && selectedKey === lastSelectedKey.current) {\n            if (lastSelectedKeyText.current !== selectedItemText) {\n                setLastValue(selectedItemText);\n                setInputValue(selectedItemText);\n            }\n        }\n        lastSelectedKey.current = selectedKey;\n        lastSelectedKeyText.current = selectedItemText;\n    });\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_4__.useFormValidationState)({\n        ...props,\n        value: (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                inputValue: inputValue,\n                selectedKey: selectedKey\n            }), [\n            inputValue,\n            selectedKey\n        ])\n    });\n    // Revert input value and close menu\n    let revert = ()=>{\n        if (allowsCustomValue && selectedKey == null) commitCustomValue();\n        else commitSelection();\n    };\n    let commitCustomValue = ()=>{\n        lastSelectedKey.current = null;\n        setSelectedKey(null);\n        closeMenu();\n    };\n    let commitSelection = ()=>{\n        // If multiple things are controlled, call onSelectionChange\n        if (props.selectedKey !== undefined && props.inputValue !== undefined) {\n            var _collection_getItem;\n            props.onSelectionChange(selectedKey);\n            var _collection_getItem_textValue;\n            // Stop menu from reopening from useEffect\n            let itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n            setLastValue(itemText);\n            closeMenu();\n        } else {\n            // If only a single aspect of combobox is controlled, reset input value and close menu for the user\n            resetInputValue();\n            closeMenu();\n        }\n    };\n    const commitValue = ()=>{\n        if (allowsCustomValue) {\n            var _collection_getItem;\n            var _collection_getItem_textValue;\n            const itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n            inputValue === itemText ? commitSelection() : commitCustomValue();\n        } else commitSelection();\n    };\n    let commit = ()=>{\n        if (triggerState.isOpen && selectionManager.focusedKey != null) {\n            // Reset inputValue and close menu here if the selected key is already the focused key. Otherwise\n            // fire onSelectionChange to allow the application to control the closing.\n            if (selectedKey === selectionManager.focusedKey) commitSelection();\n            else setSelectedKey(selectionManager.focusedKey);\n        } else commitValue();\n    };\n    let valueOnFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(inputValue);\n    let setFocused = (isFocused)=>{\n        if (isFocused) {\n            valueOnFocus.current = inputValue;\n            if (menuTrigger === \"focus\") open(null, \"focus\");\n        } else {\n            if (shouldCloseOnBlur) commitValue();\n            if (inputValue !== valueOnFocus.current) validation.commitValidation();\n        }\n        setFocusedState(isFocused);\n    };\n    let displayedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (triggerState.isOpen) {\n            if (showAllItems) return originalCollection;\n            else return filteredCollection;\n        } else return lastCollection;\n    }, [\n        triggerState.isOpen,\n        originalCollection,\n        filteredCollection,\n        showAllItems,\n        lastCollection\n    ]);\n    return {\n        ...validation,\n        ...triggerState,\n        focusStrategy: focusStrategy,\n        toggle: toggle,\n        open: open,\n        close: commitValue,\n        selectionManager: selectionManager,\n        selectedKey: selectedKey,\n        setSelectedKey: setSelectedKey,\n        disabledKeys: disabledKeys,\n        isFocused: isFocused,\n        setFocused: setFocused,\n        selectedItem: selectedItem,\n        collection: displayedCollection,\n        inputValue: inputValue,\n        setInputValue: setInputValue,\n        commit: commit,\n        revert: revert\n    };\n}\nfunction $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, filter) {\n    return new (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.ListCollection)($a9e7382a7d111cb5$var$filterNodes(collection, collection, inputValue, filter));\n}\nfunction $a9e7382a7d111cb5$var$filterNodes(collection, nodes, inputValue, filter) {\n    let filteredNode = [];\n    for (let node of nodes){\n        if (node.type === \"section\" && node.hasChildNodes) {\n            let filtered = $a9e7382a7d111cb5$var$filterNodes(collection, (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_5__.getChildNodes)(node, collection), inputValue, filter);\n            if ([\n                ...filtered\n            ].some((node)=>node.type === \"item\")) filteredNode.push({\n                ...node,\n                childNodes: filtered\n            });\n        } else if (node.type === \"item\" && filter(node.textValue, inputValue)) filteredNode.push({\n            ...node\n        });\n        else if (node.type !== \"item\") filteredNode.push({\n            ...node\n        });\n    }\n    return filteredNode;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29tYm9ib3gvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEY7QUFDWDtBQUN3RDtBQUMrQjtBQUNuRjtBQUNXO0FBRWhHOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBTUQsU0FBU3NCLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJQyxxQkFBcUJDO0lBQ3pCLElBQUksRUFBRUMsZUFBZUEsYUFBYSxFQUFFQyxhQUFhQSxjQUFjLE9BQU8sRUFBRUMsdUJBQXVCQSx3QkFBd0IsS0FBSyxFQUFFQyxtQkFBbUJBLGlCQUFpQixFQUFFQyxtQkFBbUJBLG9CQUFvQixJQUFJLEVBQUUsR0FBR1A7SUFDcE4sSUFBSSxDQUFDUSxjQUFjQyxnQkFBZ0IsR0FBRyxDQUFDLEdBQUd2QiwyQ0FBYyxFQUFHO0lBQzNELElBQUksQ0FBQ3dCLFdBQVdDLGdCQUFnQixHQUFHLENBQUMsR0FBR3pCLDJDQUFjLEVBQUc7SUFDeEQsSUFBSSxDQUFDMEIsZUFBZUMsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHM0IsMkNBQWMsRUFBRztJQUM3RCxJQUFJNEIsb0JBQW9CLENBQUNDO1FBQ3JCLElBQUlmLE1BQU1jLGlCQUFpQixFQUFFZCxNQUFNYyxpQkFBaUIsQ0FBQ0M7UUFDckQsOERBQThEO1FBQzlELHFEQUFxRDtRQUNyRCxJQUFJQSxRQUFRQyxhQUFhO1lBQ3JCQztZQUNBQztRQUNKO0lBQ0o7SUFDQSxJQUFJQztJQUNKLElBQUksRUFBRUMsWUFBWUEsVUFBVSxFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFTCxhQUFhQSxXQUFXLEVBQUVNLGdCQUFnQkEsY0FBYyxFQUFFQyxjQUFjQSxZQUFZLEVBQUVDLGNBQWNBLFlBQVksRUFBRSxHQUFHLENBQUMsR0FBRzFDLHlFQUE4QixFQUFHO1FBQ3hOLEdBQUdrQixLQUFLO1FBQ1JjLG1CQUFtQkE7UUFDbkJXLE9BQU8sQ0FBQ04sZUFBZW5C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QUMsQ0FBQ0osT0FBT0EsS0FBS0MsSUFBSSxLQUFLLFNBQVNGLGFBQWFNLElBQUksQ0FBQztnQkFDcEQsR0FBR0wsSUFBSTtnQkFDUE0sWUFBWUg7WUFDaEI7UUFDSixPQUFPLElBQUlILEtBQUtDLElBQUksS0FBSyxVQUFVTCxPQUFPSSxLQUFLakQsU0FBUyxFQUFFSixhQUFhb0QsYUFBYU0sSUFBSSxDQUFDO1lBQ3JGLEdBQUdMLElBQUk7UUFDWDthQUNLLElBQUlBLEtBQUtDLElBQUksS0FBSyxRQUFRRixhQUFhTSxJQUFJLENBQUM7WUFDN0MsR0FBR0wsSUFBSTtRQUNYO0lBQ0o7SUFDQSxPQUFPRDtBQUNYO0FBS3VFLENBQ3ZFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2NvbWJvYm94L2Rpc3QvaW1wb3J0Lm1qcz9jYjgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlRm9ybVZhbGlkYXRpb25TdGF0ZSBhcyAkazZQcHUkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2Zvcm1cIjtcbmltcG9ydCB7Z2V0Q2hpbGROb2RlcyBhcyAkazZQcHUkZ2V0Q2hpbGROb2Rlc30gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQge3VzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSBhcyAkazZQcHUkdXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlLCBMaXN0Q29sbGVjdGlvbiBhcyAkazZQcHUkTGlzdENvbGxlY3Rpb259IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9saXN0XCI7XG5pbXBvcnQge3VzZVN0YXRlIGFzICRrNlBwdSR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkazZQcHUkdXNlTWVtbywgdXNlUmVmIGFzICRrNlBwdSR1c2VSZWYsIHVzZUNhbGxiYWNrIGFzICRrNlBwdSR1c2VDYWxsYmFjaywgdXNlRWZmZWN0IGFzICRrNlBwdSR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJGs2UHB1JHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZU92ZXJsYXlUcmlnZ2VyU3RhdGUgYXMgJGs2UHB1JHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9vdmVybGF5c1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKiBcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5cblxuXG5mdW5jdGlvbiAkYTllNzM4MmE3ZDExMWNiNSRleHBvcnQkYjQ1M2EzYmZkNGE1ZmE5ZShwcm9wcykge1xuICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtLCBfY29sbGVjdGlvbl9nZXRJdGVtMTtcbiAgICBsZXQgeyBkZWZhdWx0RmlsdGVyOiBkZWZhdWx0RmlsdGVyLCBtZW51VHJpZ2dlcjogbWVudVRyaWdnZXIgPSBcImlucHV0XCIsIGFsbG93c0VtcHR5Q29sbGVjdGlvbjogYWxsb3dzRW1wdHlDb2xsZWN0aW9uID0gZmFsc2UsIGFsbG93c0N1c3RvbVZhbHVlOiBhbGxvd3NDdXN0b21WYWx1ZSwgc2hvdWxkQ2xvc2VPbkJsdXI6IHNob3VsZENsb3NlT25CbHVyID0gdHJ1ZSB9ID0gcHJvcHM7XG4gICAgbGV0IFtzaG93QWxsSXRlbXMsIHNldFNob3dBbGxJdGVtc10gPSAoMCwgJGs2UHB1JHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IFtpc0ZvY3VzZWQsIHNldEZvY3VzZWRTdGF0ZV0gPSAoMCwgJGs2UHB1JHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IFtmb2N1c1N0cmF0ZWd5LCBzZXRGb2N1c1N0cmF0ZWd5XSA9ICgwLCAkazZQcHUkdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCBvblNlbGVjdGlvbkNoYW5nZSA9IChrZXkpPT57XG4gICAgICAgIGlmIChwcm9wcy5vblNlbGVjdGlvbkNoYW5nZSkgcHJvcHMub25TZWxlY3Rpb25DaGFuZ2Uoa2V5KTtcbiAgICAgICAgLy8gSWYga2V5IGlzIHRoZSBzYW1lLCByZXNldCB0aGUgaW5wdXRWYWx1ZSBhbmQgY2xvc2UgdGhlIG1lbnVcbiAgICAgICAgLy8gKHNjZW5hcmlvOiB1c2VyIGNsaWNrcyBvbiBhbHJlYWR5IHNlbGVjdGVkIG9wdGlvbilcbiAgICAgICAgaWYgKGtleSA9PT0gc2VsZWN0ZWRLZXkpIHtcbiAgICAgICAgICAgIHJlc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICAgICAgY2xvc2VNZW51KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBfcHJvcHNfaXRlbXM7XG4gICAgbGV0IHsgY29sbGVjdGlvbjogY29sbGVjdGlvbiwgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlciwgc2VsZWN0ZWRLZXk6IHNlbGVjdGVkS2V5LCBzZXRTZWxlY3RlZEtleTogc2V0U2VsZWN0ZWRLZXksIHNlbGVjdGVkSXRlbTogc2VsZWN0ZWRJdGVtLCBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyB9ID0gKDAsICRrNlBwdSR1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlOiBvblNlbGVjdGlvbkNoYW5nZSxcbiAgICAgICAgaXRlbXM6IChfcHJvcHNfaXRlbXMgPSBwcm9wcy5pdGVtcykgIT09IG51bGwgJiYgX3Byb3BzX2l0ZW1zICE9PSB2b2lkIDAgPyBfcHJvcHNfaXRlbXMgOiBwcm9wcy5kZWZhdWx0SXRlbXNcbiAgICB9KTtcbiAgICB2YXIgX3Byb3BzX2RlZmF1bHRJbnB1dFZhbHVlLCBfcmVmO1xuICAgIGxldCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSAoMCwgJGs2UHB1JHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMuaW5wdXRWYWx1ZSwgKF9yZWYgPSAoX3Byb3BzX2RlZmF1bHRJbnB1dFZhbHVlID0gcHJvcHMuZGVmYXVsdElucHV0VmFsdWUpICE9PSBudWxsICYmIF9wcm9wc19kZWZhdWx0SW5wdXRWYWx1ZSAhPT0gdm9pZCAwID8gX3Byb3BzX2RlZmF1bHRJbnB1dFZhbHVlIDogKF9jb2xsZWN0aW9uX2dldEl0ZW0gPSBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpKSA9PT0gbnVsbCB8fCBfY29sbGVjdGlvbl9nZXRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sbGVjdGlvbl9nZXRJdGVtLnRleHRWYWx1ZSkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IFwiXCIsIHByb3BzLm9uSW5wdXRDaGFuZ2UpO1xuICAgIC8vIFByZXNlcnZlIG9yaWdpbmFsIGNvbGxlY3Rpb24gc28gd2UgY2FuIHNob3cgYWxsIGl0ZW1zIG9uIGRlbWFuZFxuICAgIGxldCBvcmlnaW5hbENvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgIGxldCBmaWx0ZXJlZENvbGxlY3Rpb24gPSAoMCwgJGs2UHB1JHVzZU1lbW8pKCgpPT4vLyBObyBkZWZhdWx0IGZpbHRlciBpZiBpdGVtcyBhcmUgY29udHJvbGxlZC5cbiAgICAgICAgcHJvcHMuaXRlbXMgIT0gbnVsbCB8fCAhZGVmYXVsdEZpbHRlciA/IGNvbGxlY3Rpb24gOiAkYTllNzM4MmE3ZDExMWNiNSR2YXIkZmlsdGVyQ29sbGVjdGlvbihjb2xsZWN0aW9uLCBpbnB1dFZhbHVlLCBkZWZhdWx0RmlsdGVyKSwgW1xuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBpbnB1dFZhbHVlLFxuICAgICAgICBkZWZhdWx0RmlsdGVyLFxuICAgICAgICBwcm9wcy5pdGVtc1xuICAgIF0pO1xuICAgIGxldCBbbGFzdENvbGxlY3Rpb24sIHNldExhc3RDb2xsZWN0aW9uXSA9ICgwLCAkazZQcHUkdXNlU3RhdGUpKGZpbHRlcmVkQ29sbGVjdGlvbik7XG4gICAgLy8gVHJhY2sgd2hhdCBhY3Rpb24gaXMgYXR0ZW1wdGluZyB0byBvcGVuIHRoZSBtZW51XG4gICAgbGV0IG1lbnVPcGVuVHJpZ2dlciA9ICgwLCAkazZQcHUkdXNlUmVmKShcImZvY3VzXCIpO1xuICAgIGxldCBvbk9wZW5DaGFuZ2UgPSAob3Blbik9PntcbiAgICAgICAgaWYgKHByb3BzLm9uT3BlbkNoYW5nZSkgcHJvcHMub25PcGVuQ2hhbmdlKG9wZW4sIG9wZW4gPyBtZW51T3BlblRyaWdnZXIuY3VycmVudCA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXIuc2V0Rm9jdXNlZChvcGVuKTtcbiAgICAgICAgaWYgKCFvcGVuKSBzZWxlY3Rpb25NYW5hZ2VyLnNldEZvY3VzZWRLZXkobnVsbCk7XG4gICAgfTtcbiAgICBsZXQgdHJpZ2dlclN0YXRlID0gKDAsICRrNlBwdSR1c2VPdmVybGF5VHJpZ2dlclN0YXRlKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBvbk9wZW5DaGFuZ2U6IG9uT3BlbkNoYW5nZSxcbiAgICAgICAgaXNPcGVuOiB1bmRlZmluZWQsXG4gICAgICAgIGRlZmF1bHRPcGVuOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgICBsZXQgb3BlbiA9IChmb2N1c1N0cmF0ZWd5ID0gbnVsbCwgdHJpZ2dlcik9PntcbiAgICAgICAgbGV0IGRpc3BsYXlBbGxJdGVtcyA9IHRyaWdnZXIgPT09IFwibWFudWFsXCIgfHwgdHJpZ2dlciA9PT0gXCJmb2N1c1wiICYmIG1lbnVUcmlnZ2VyID09PSBcImZvY3VzXCI7XG4gICAgICAgIC8vIFByZXZlbnQgb3BlbiBvcGVyYXRpb25zIGZyb20gdHJpZ2dlcmluZyBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGRpc3BsYXlcbiAgICAgICAgLy8gQWxzbyBwcmV2ZW50IG9wZW4gb3BlcmF0aW9ucyBmcm9tIHRyaWdnZXJpbmcgaWYgaXRlbXMgYXJlIHVuY29udHJvbGxlZCBidXQgZGVmYXVsdEl0ZW1zIGlzIGVtcHR5LCBldmVuIGlmIGRpc3BsYXlBbGxJdGVtcyBpcyB0cnVlLlxuICAgICAgICAvLyBUaGlzIGlzIHRvIHByZXZlbnQgY29tYm9ib3hlcyB3aXRoIGVtcHR5IGRlZmF1bHRJdGVtcyBmcm9tIG9wZW5pbmcgYnV0IGFsbG93IGNvbnRyb2xsZWQgaXRlbXMgY29tYm9ib3hlcyB0byBvcGVuIGV2ZW4gaWYgdGhlIGluaXRhbCBsaXN0IGlzIGVtcHR5IChhc3N1bXB0aW9uIGlzIHVzZXIgd2lsbCBwcm92aWRlIHN3YXAgdGhlIGVtcHR5IGxpc3Qgd2l0aCBhIGJhc2UgbGlzdCB2aWEgb25PcGVuQ2hhbmdlIHJldHVybmluZyBgbWVudVRyaWdnZXJgIG1hbnVhbClcbiAgICAgICAgaWYgKGFsbG93c0VtcHR5Q29sbGVjdGlvbiB8fCBmaWx0ZXJlZENvbGxlY3Rpb24uc2l6ZSA+IDAgfHwgZGlzcGxheUFsbEl0ZW1zICYmIG9yaWdpbmFsQ29sbGVjdGlvbi5zaXplID4gMCB8fCBwcm9wcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGRpc3BsYXlBbGxJdGVtcyAmJiAhdHJpZ2dlclN0YXRlLmlzT3BlbiAmJiBwcm9wcy5pdGVtcyA9PT0gdW5kZWZpbmVkKSAvLyBTaG93IGFsbCBpdGVtcyBpZiBtZW51IGlzIG1hbnVhbGx5IG9wZW5lZC4gT25seSBjYXJlIGFib3V0IHRoaXMgaWYgaXRlbXMgYXJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgc2V0U2hvd0FsbEl0ZW1zKHRydWUpO1xuICAgICAgICAgICAgbWVudU9wZW5UcmlnZ2VyLmN1cnJlbnQgPSB0cmlnZ2VyO1xuICAgICAgICAgICAgc2V0Rm9jdXNTdHJhdGVneShmb2N1c1N0cmF0ZWd5KTtcbiAgICAgICAgICAgIHRyaWdnZXJTdGF0ZS5vcGVuKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCB0b2dnbGUgPSAoZm9jdXNTdHJhdGVneSA9IG51bGwsIHRyaWdnZXIpPT57XG4gICAgICAgIGxldCBkaXNwbGF5QWxsSXRlbXMgPSB0cmlnZ2VyID09PSBcIm1hbnVhbFwiIHx8IHRyaWdnZXIgPT09IFwiZm9jdXNcIiAmJiBtZW51VHJpZ2dlciA9PT0gXCJmb2N1c1wiO1xuICAgICAgICAvLyBJZiB0aGUgbWVudSBpcyBjbG9zZWQgYW5kIHRoZXJlIGlzIG5vdGhpbmcgdG8gZGlzcGxheSwgZWFybHkgcmV0dXJuIHNvIHRvZ2dsZSBpc24ndCBjYWxsZWQgdG8gcHJldmVudCBleHRyYW5lb3VzIG9uT3BlbkNoYW5nZVxuICAgICAgICBpZiAoIShhbGxvd3NFbXB0eUNvbGxlY3Rpb24gfHwgZmlsdGVyZWRDb2xsZWN0aW9uLnNpemUgPiAwIHx8IGRpc3BsYXlBbGxJdGVtcyAmJiBvcmlnaW5hbENvbGxlY3Rpb24uc2l6ZSA+IDAgfHwgcHJvcHMuaXRlbXMpICYmICF0cmlnZ2VyU3RhdGUuaXNPcGVuKSByZXR1cm47XG4gICAgICAgIGlmIChkaXNwbGF5QWxsSXRlbXMgJiYgIXRyaWdnZXJTdGF0ZS5pc09wZW4gJiYgcHJvcHMuaXRlbXMgPT09IHVuZGVmaW5lZCkgLy8gU2hvdyBhbGwgaXRlbXMgaWYgbWVudSBpcyB0b2dnbGVkIG9wZW4uIE9ubHkgY2FyZSBhYm91dCB0aGlzIGlmIGl0ZW1zIGFyZSB1bmRlZmluZWRcbiAgICAgICAgc2V0U2hvd0FsbEl0ZW1zKHRydWUpO1xuICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgbWVudU9wZW5UcmlnZ2VyIGlmIG1lbnUgaXMgY3VycmVudGx5IGNsb3NlZFxuICAgICAgICBpZiAoIXRyaWdnZXJTdGF0ZS5pc09wZW4pIG1lbnVPcGVuVHJpZ2dlci5jdXJyZW50ID0gdHJpZ2dlcjtcbiAgICAgICAgdG9nZ2xlTWVudShmb2N1c1N0cmF0ZWd5KTtcbiAgICB9O1xuICAgIGxldCB1cGRhdGVMYXN0Q29sbGVjdGlvbiA9ICgwLCAkazZQcHUkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldExhc3RDb2xsZWN0aW9uKHNob3dBbGxJdGVtcyA/IG9yaWdpbmFsQ29sbGVjdGlvbiA6IGZpbHRlcmVkQ29sbGVjdGlvbik7XG4gICAgfSwgW1xuICAgICAgICBzaG93QWxsSXRlbXMsXG4gICAgICAgIG9yaWdpbmFsQ29sbGVjdGlvbixcbiAgICAgICAgZmlsdGVyZWRDb2xsZWN0aW9uXG4gICAgXSk7XG4gICAgLy8gSWYgbWVudSBpcyBnb2luZyB0byBjbG9zZSwgc2F2ZSB0aGUgY3VycmVudCBjb2xsZWN0aW9uIHNvIHdlIGNhbiBmcmVlemUgdGhlIGRpc3BsYXllZCBjb2xsZWN0aW9uIHdoZW4gdGhlXG4gICAgLy8gdXNlciBjbGlja3Mgb3V0c2lkZSB0aGUgcG9wb3ZlciB0byBjbG9zZSB0aGUgbWVudS4gUHJldmVudHMgdGhlIG1lbnUgY29udGVudHMgZnJvbSB1cGRhdGluZyBhcyB0aGUgbWVudSBjbG9zZXMuXG4gICAgbGV0IHRvZ2dsZU1lbnUgPSAoMCwgJGs2UHB1JHVzZUNhbGxiYWNrKSgoZm9jdXNTdHJhdGVneSA9IG51bGwpPT57XG4gICAgICAgIGlmICh0cmlnZ2VyU3RhdGUuaXNPcGVuKSB1cGRhdGVMYXN0Q29sbGVjdGlvbigpO1xuICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xuICAgICAgICB0cmlnZ2VyU3RhdGUudG9nZ2xlKCk7XG4gICAgfSwgW1xuICAgICAgICB0cmlnZ2VyU3RhdGUsXG4gICAgICAgIHVwZGF0ZUxhc3RDb2xsZWN0aW9uXG4gICAgXSk7XG4gICAgbGV0IGNsb3NlTWVudSA9ICgwLCAkazZQcHUkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIGlmICh0cmlnZ2VyU3RhdGUuaXNPcGVuKSB7XG4gICAgICAgICAgICB1cGRhdGVMYXN0Q29sbGVjdGlvbigpO1xuICAgICAgICAgICAgdHJpZ2dlclN0YXRlLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHRyaWdnZXJTdGF0ZSxcbiAgICAgICAgdXBkYXRlTGFzdENvbGxlY3Rpb25cbiAgICBdKTtcbiAgICBsZXQgW2xhc3RWYWx1ZSwgc2V0TGFzdFZhbHVlXSA9ICgwLCAkazZQcHUkdXNlU3RhdGUpKGlucHV0VmFsdWUpO1xuICAgIGxldCByZXNldElucHV0VmFsdWUgPSAoKT0+e1xuICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbTtcbiAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlO1xuICAgICAgICBsZXQgaXRlbVRleHQgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2dldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0udGV4dFZhbHVlKSAhPT0gbnVsbCAmJiBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSAhPT0gdm9pZCAwID8gX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgOiBcIlwiO1xuICAgICAgICBzZXRMYXN0VmFsdWUoaXRlbVRleHQpO1xuICAgICAgICBzZXRJbnB1dFZhbHVlKGl0ZW1UZXh0KTtcbiAgICB9O1xuICAgIHZhciBfcHJvcHNfc2VsZWN0ZWRLZXksIF9yZWYxO1xuICAgIGxldCBsYXN0U2VsZWN0ZWRLZXkgPSAoMCwgJGs2UHB1JHVzZVJlZikoKF9yZWYxID0gKF9wcm9wc19zZWxlY3RlZEtleSA9IHByb3BzLnNlbGVjdGVkS2V5KSAhPT0gbnVsbCAmJiBfcHJvcHNfc2VsZWN0ZWRLZXkgIT09IHZvaWQgMCA/IF9wcm9wc19zZWxlY3RlZEtleSA6IHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleSkgIT09IG51bGwgJiYgX3JlZjEgIT09IHZvaWQgMCA/IF9yZWYxIDogbnVsbCk7XG4gICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlO1xuICAgIGxldCBsYXN0U2VsZWN0ZWRLZXlUZXh0ID0gKDAsICRrNlBwdSR1c2VSZWYpKChfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA9IChfY29sbGVjdGlvbl9nZXRJdGVtMSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2dldEl0ZW0xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sbGVjdGlvbl9nZXRJdGVtMS50ZXh0VmFsdWUpICE9PSBudWxsICYmIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlICE9PSB2b2lkIDAgPyBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA6IFwiXCIpO1xuICAgIC8vIGludGVudGlvbmFsIG9taXQgZGVwZW5kZW5jeSBhcnJheSwgd2FudCB0aGlzIHRvIGhhcHBlbiBvbiBldmVyeSByZW5kZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgKDAsICRrNlBwdSR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtO1xuICAgICAgICAvLyBPcGVuIGFuZCBjbG9zZSBtZW51IGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgaW5wdXQgdmFsdWUgY2hhbmdlcyBpZiB0aGUgaW5wdXQgaXMgZm9jdXNlZCxcbiAgICAgICAgLy8gYW5kIHRoZXJlIGFyZSBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbiBvciBhbGxvd0VtcHR5Q29sbGVjdGlvbiBpcyB0cnVlLlxuICAgICAgICBpZiAoaXNGb2N1c2VkICYmIChmaWx0ZXJlZENvbGxlY3Rpb24uc2l6ZSA+IDAgfHwgYWxsb3dzRW1wdHlDb2xsZWN0aW9uKSAmJiAhdHJpZ2dlclN0YXRlLmlzT3BlbiAmJiBpbnB1dFZhbHVlICE9PSBsYXN0VmFsdWUgJiYgbWVudVRyaWdnZXIgIT09IFwibWFudWFsXCIpIG9wZW4obnVsbCwgXCJpbnB1dFwiKTtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIG1lbnUgaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuIERvbid0IGNsb3NlIG1lbnUgaWYgZmlsdGVyZWQgY29sbGVjdGlvbiBzaXplIGlzIDBcbiAgICAgICAgLy8gYnV0IHdlIGFyZSBjdXJyZW50bHkgc2hvd2luZyBhbGwgaXRlbXMgdmlhIGJ1dHRvbiBwcmVzc1xuICAgICAgICBpZiAoIXNob3dBbGxJdGVtcyAmJiAhYWxsb3dzRW1wdHlDb2xsZWN0aW9uICYmIHRyaWdnZXJTdGF0ZS5pc09wZW4gJiYgZmlsdGVyZWRDb2xsZWN0aW9uLnNpemUgPT09IDApIGNsb3NlTWVudSgpO1xuICAgICAgICAvLyBDbG9zZSB3aGVuIGFuIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICAgIGlmIChzZWxlY3RlZEtleSAhPSBudWxsICYmIHNlbGVjdGVkS2V5ICE9PSBsYXN0U2VsZWN0ZWRLZXkuY3VycmVudCkgY2xvc2VNZW51KCk7XG4gICAgICAgIC8vIENsZWFyIGZvY3VzZWQga2V5IHdoZW4gaW5wdXQgdmFsdWUgY2hhbmdlcyBhbmQgZGlzcGxheSBmaWx0ZXJlZCBjb2xsZWN0aW9uIGFnYWluLlxuICAgICAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyLnNldEZvY3VzZWRLZXkobnVsbCk7XG4gICAgICAgICAgICBzZXRTaG93QWxsSXRlbXMoZmFsc2UpO1xuICAgICAgICAgICAgLy8gU2V0IHNlbGVjdGVkS2V5IHRvIG51bGwgd2hlbiB0aGUgdXNlciBjbGVhcnMgdGhlIGlucHV0LlxuICAgICAgICAgICAgLy8gSWYgY29udHJvbGxlZCwgdGhpcyBpcyB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyJ3MgcmVzcG9uc2liaWxpdHkuXG4gICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSA9PT0gXCJcIiAmJiAocHJvcHMuaW5wdXRWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BzLnNlbGVjdGVkS2V5ID09PSB1bmRlZmluZWQpKSBzZXRTZWxlY3RlZEtleShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0ZWRLZXkgY2hhbmdlZCwgdXBkYXRlIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBib3RoIGlucHV0VmFsdWUgYW5kIHNlbGVjdGVkS2V5IGFyZSBjb250cm9sbGVkLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGl0J3MgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byB1cGRhdGUgaW5wdXRWYWx1ZSBpbiBvblNlbGVjdGlvbkNoYW5nZS5cbiAgICAgICAgaWYgKHNlbGVjdGVkS2V5ICE9PSBsYXN0U2VsZWN0ZWRLZXkuY3VycmVudCAmJiAocHJvcHMuaW5wdXRWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BzLnNlbGVjdGVkS2V5ID09PSB1bmRlZmluZWQpKSByZXNldElucHV0VmFsdWUoKTtcbiAgICAgICAgZWxzZSBpZiAobGFzdFZhbHVlICE9PSBpbnB1dFZhbHVlKSBzZXRMYXN0VmFsdWUoaW5wdXRWYWx1ZSk7XG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnB1dFZhbHVlIGlmIHRoZSBzZWxlY3RlZCBpdGVtJ3MgdGV4dCBjaGFuZ2VzIGZyb20gaXRzIGxhc3QgdHJhY2tlZCB2YWx1ZS5cbiAgICAgICAgLy8gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgd2hlcmUgYSBzZWxlY3RlZEtleSBpcyBzcGVjaWZpZWQgYnV0IHRoZSBpdGVtcyBhcmVuJ3QgYXZhaWxhYmxlIChhc3luYyBsb2FkaW5nKSBvciB0aGUgc2VsZWN0ZWQgaXRlbSdzIHRleHQgdmFsdWUgdXBkYXRlcy5cbiAgICAgICAgLy8gT25seSByZXNldCBpZiB0aGUgdXNlciBpc24ndCBjdXJyZW50bHkgd2l0aGluIHRoZSBmaWVsZCBzbyB3ZSBkb24ndCBlcnJvbmVvdXNseSBtb2RpZnkgdXNlciBpbnB1dC5cbiAgICAgICAgLy8gSWYgaW5wdXRWYWx1ZSBpcyBjb250cm9sbGVkLCBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIHVwZGF0ZSB0aGUgaW5wdXRWYWx1ZSB3aGVuIGl0ZW1zIGNoYW5nZS5cbiAgICAgICAgbGV0IHNlbGVjdGVkSXRlbVRleHQgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2dldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0udGV4dFZhbHVlKSAhPT0gbnVsbCAmJiBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSAhPT0gdm9pZCAwID8gX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgOiBcIlwiO1xuICAgICAgICBpZiAoIWlzRm9jdXNlZCAmJiBzZWxlY3RlZEtleSAhPSBudWxsICYmIHByb3BzLmlucHV0VmFsdWUgPT09IHVuZGVmaW5lZCAmJiBzZWxlY3RlZEtleSA9PT0gbGFzdFNlbGVjdGVkS2V5LmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U2VsZWN0ZWRLZXlUZXh0LmN1cnJlbnQgIT09IHNlbGVjdGVkSXRlbVRleHQpIHtcbiAgICAgICAgICAgICAgICBzZXRMYXN0VmFsdWUoc2VsZWN0ZWRJdGVtVGV4dCk7XG4gICAgICAgICAgICAgICAgc2V0SW5wdXRWYWx1ZShzZWxlY3RlZEl0ZW1UZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0U2VsZWN0ZWRLZXkuY3VycmVudCA9IHNlbGVjdGVkS2V5O1xuICAgICAgICBsYXN0U2VsZWN0ZWRLZXlUZXh0LmN1cnJlbnQgPSBzZWxlY3RlZEl0ZW1UZXh0O1xuICAgIH0pO1xuICAgIGxldCB2YWxpZGF0aW9uID0gKDAsICRrNlBwdSR1c2VGb3JtVmFsaWRhdGlvblN0YXRlKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICB2YWx1ZTogKDAsICRrNlBwdSR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBpbnB1dFZhbHVlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5OiBzZWxlY3RlZEtleVxuICAgICAgICAgICAgfSksIFtcbiAgICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAgICBzZWxlY3RlZEtleVxuICAgICAgICBdKVxuICAgIH0pO1xuICAgIC8vIFJldmVydCBpbnB1dCB2YWx1ZSBhbmQgY2xvc2UgbWVudVxuICAgIGxldCByZXZlcnQgPSAoKT0+e1xuICAgICAgICBpZiAoYWxsb3dzQ3VzdG9tVmFsdWUgJiYgc2VsZWN0ZWRLZXkgPT0gbnVsbCkgY29tbWl0Q3VzdG9tVmFsdWUoKTtcbiAgICAgICAgZWxzZSBjb21taXRTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIGxldCBjb21taXRDdXN0b21WYWx1ZSA9ICgpPT57XG4gICAgICAgIGxhc3RTZWxlY3RlZEtleS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgc2V0U2VsZWN0ZWRLZXkobnVsbCk7XG4gICAgICAgIGNsb3NlTWVudSgpO1xuICAgIH07XG4gICAgbGV0IGNvbW1pdFNlbGVjdGlvbiA9ICgpPT57XG4gICAgICAgIC8vIElmIG11bHRpcGxlIHRoaW5ncyBhcmUgY29udHJvbGxlZCwgY2FsbCBvblNlbGVjdGlvbkNoYW5nZVxuICAgICAgICBpZiAocHJvcHMuc2VsZWN0ZWRLZXkgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5pbnB1dFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtO1xuICAgICAgICAgICAgcHJvcHMub25TZWxlY3Rpb25DaGFuZ2Uoc2VsZWN0ZWRLZXkpO1xuICAgICAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlO1xuICAgICAgICAgICAgLy8gU3RvcCBtZW51IGZyb20gcmVvcGVuaW5nIGZyb20gdXNlRWZmZWN0XG4gICAgICAgICAgICBsZXQgaXRlbVRleHQgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2dldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0udGV4dFZhbHVlKSAhPT0gbnVsbCAmJiBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSAhPT0gdm9pZCAwID8gX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgOiBcIlwiO1xuICAgICAgICAgICAgc2V0TGFzdFZhbHVlKGl0ZW1UZXh0KTtcbiAgICAgICAgICAgIGNsb3NlTWVudSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgb25seSBhIHNpbmdsZSBhc3BlY3Qgb2YgY29tYm9ib3ggaXMgY29udHJvbGxlZCwgcmVzZXQgaW5wdXQgdmFsdWUgYW5kIGNsb3NlIG1lbnUgZm9yIHRoZSB1c2VyXG4gICAgICAgICAgICByZXNldElucHV0VmFsdWUoKTtcbiAgICAgICAgICAgIGNsb3NlTWVudSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjb21taXRWYWx1ZSA9ICgpPT57XG4gICAgICAgIGlmIChhbGxvd3NDdXN0b21WYWx1ZSkge1xuICAgICAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW07XG4gICAgICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWU7XG4gICAgICAgICAgICBjb25zdCBpdGVtVGV4dCA9IChfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA9IChfY29sbGVjdGlvbl9nZXRJdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkgPT09IG51bGwgfHwgX2NvbGxlY3Rpb25fZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxlY3Rpb25fZ2V0SXRlbS50ZXh0VmFsdWUpICE9PSBudWxsICYmIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlICE9PSB2b2lkIDAgPyBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA6IFwiXCI7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID09PSBpdGVtVGV4dCA/IGNvbW1pdFNlbGVjdGlvbigpIDogY29tbWl0Q3VzdG9tVmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIC8vIFJlc2V0IGlucHV0VmFsdWUgYW5kIGNsb3NlIG1lbnVcbiAgICAgICAgY29tbWl0U2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBsZXQgY29tbWl0ID0gKCk9PntcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZS5pc09wZW4gJiYgc2VsZWN0aW9uTWFuYWdlci5mb2N1c2VkS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGlucHV0VmFsdWUgYW5kIGNsb3NlIG1lbnUgaGVyZSBpZiB0aGUgc2VsZWN0ZWQga2V5IGlzIGFscmVhZHkgdGhlIGZvY3VzZWQga2V5LiBPdGhlcndpc2VcbiAgICAgICAgICAgIC8vIGZpcmUgb25TZWxlY3Rpb25DaGFuZ2UgdG8gYWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGNvbnRyb2wgdGhlIGNsb3NpbmcuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRLZXkgPT09IHNlbGVjdGlvbk1hbmFnZXIuZm9jdXNlZEtleSkgY29tbWl0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBlbHNlIHNldFNlbGVjdGVkS2V5KHNlbGVjdGlvbk1hbmFnZXIuZm9jdXNlZEtleSk7XG4gICAgICAgIH0gZWxzZSBjb21taXRWYWx1ZSgpO1xuICAgIH07XG4gICAgbGV0IHZhbHVlT25Gb2N1cyA9ICgwLCAkazZQcHUkdXNlUmVmKShpbnB1dFZhbHVlKTtcbiAgICBsZXQgc2V0Rm9jdXNlZCA9IChpc0ZvY3VzZWQpPT57XG4gICAgICAgIGlmIChpc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIHZhbHVlT25Gb2N1cy5jdXJyZW50ID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChtZW51VHJpZ2dlciA9PT0gXCJmb2N1c1wiKSBvcGVuKG51bGwsIFwiZm9jdXNcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2xvc2VPbkJsdXIpIGNvbW1pdFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gdmFsdWVPbkZvY3VzLmN1cnJlbnQpIHZhbGlkYXRpb24uY29tbWl0VmFsaWRhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHNldEZvY3VzZWRTdGF0ZShpc0ZvY3VzZWQpO1xuICAgIH07XG4gICAgbGV0IGRpc3BsYXllZENvbGxlY3Rpb24gPSAoMCwgJGs2UHB1JHVzZU1lbW8pKCgpPT57XG4gICAgICAgIGlmICh0cmlnZ2VyU3RhdGUuaXNPcGVuKSB7XG4gICAgICAgICAgICBpZiAoc2hvd0FsbEl0ZW1zKSByZXR1cm4gb3JpZ2luYWxDb2xsZWN0aW9uO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gZmlsdGVyZWRDb2xsZWN0aW9uO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIGxhc3RDb2xsZWN0aW9uO1xuICAgIH0sIFtcbiAgICAgICAgdHJpZ2dlclN0YXRlLmlzT3BlbixcbiAgICAgICAgb3JpZ2luYWxDb2xsZWN0aW9uLFxuICAgICAgICBmaWx0ZXJlZENvbGxlY3Rpb24sXG4gICAgICAgIHNob3dBbGxJdGVtcyxcbiAgICAgICAgbGFzdENvbGxlY3Rpb25cbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi52YWxpZGF0aW9uLFxuICAgICAgICAuLi50cmlnZ2VyU3RhdGUsXG4gICAgICAgIGZvY3VzU3RyYXRlZ3k6IGZvY3VzU3RyYXRlZ3ksXG4gICAgICAgIHRvZ2dsZTogdG9nZ2xlLFxuICAgICAgICBvcGVuOiBvcGVuLFxuICAgICAgICBjbG9zZTogY29tbWl0VmFsdWUsXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIsXG4gICAgICAgIHNlbGVjdGVkS2V5OiBzZWxlY3RlZEtleSxcbiAgICAgICAgc2V0U2VsZWN0ZWRLZXk6IHNldFNlbGVjdGVkS2V5LFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcbiAgICAgICAgaXNGb2N1c2VkOiBpc0ZvY3VzZWQsXG4gICAgICAgIHNldEZvY3VzZWQ6IHNldEZvY3VzZWQsXG4gICAgICAgIHNlbGVjdGVkSXRlbTogc2VsZWN0ZWRJdGVtLFxuICAgICAgICBjb2xsZWN0aW9uOiBkaXNwbGF5ZWRDb2xsZWN0aW9uLFxuICAgICAgICBpbnB1dFZhbHVlOiBpbnB1dFZhbHVlLFxuICAgICAgICBzZXRJbnB1dFZhbHVlOiBzZXRJbnB1dFZhbHVlLFxuICAgICAgICBjb21taXQ6IGNvbW1pdCxcbiAgICAgICAgcmV2ZXJ0OiByZXZlcnRcbiAgICB9O1xufVxuZnVuY3Rpb24gJGE5ZTczODJhN2QxMTFjYjUkdmFyJGZpbHRlckNvbGxlY3Rpb24oY29sbGVjdGlvbiwgaW5wdXRWYWx1ZSwgZmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyAoMCwgJGs2UHB1JExpc3RDb2xsZWN0aW9uKSgkYTllNzM4MmE3ZDExMWNiNSR2YXIkZmlsdGVyTm9kZXMoY29sbGVjdGlvbiwgY29sbGVjdGlvbiwgaW5wdXRWYWx1ZSwgZmlsdGVyKSk7XG59XG5mdW5jdGlvbiAkYTllNzM4MmE3ZDExMWNiNSR2YXIkZmlsdGVyTm9kZXMoY29sbGVjdGlvbiwgbm9kZXMsIGlucHV0VmFsdWUsIGZpbHRlcikge1xuICAgIGxldCBmaWx0ZXJlZE5vZGUgPSBbXTtcbiAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJzZWN0aW9uXCIgJiYgbm9kZS5oYXNDaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSAkYTllNzM4MmE3ZDExMWNiNSR2YXIkZmlsdGVyTm9kZXMoY29sbGVjdGlvbiwgKDAsICRrNlBwdSRnZXRDaGlsZE5vZGVzKShub2RlLCBjb2xsZWN0aW9uKSwgaW5wdXRWYWx1ZSwgZmlsdGVyKTtcbiAgICAgICAgICAgIGlmIChbXG4gICAgICAgICAgICAgICAgLi4uZmlsdGVyZWRcbiAgICAgICAgICAgIF0uc29tZSgobm9kZSk9Pm5vZGUudHlwZSA9PT0gXCJpdGVtXCIpKSBmaWx0ZXJlZE5vZGUucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBmaWx0ZXJlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIml0ZW1cIiAmJiBmaWx0ZXIobm9kZS50ZXh0VmFsdWUsIGlucHV0VmFsdWUpKSBmaWx0ZXJlZE5vZGUucHVzaCh7XG4gICAgICAgICAgICAuLi5ub2RlXG4gICAgICAgIH0pO1xuICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgIT09IFwiaXRlbVwiKSBmaWx0ZXJlZE5vZGUucHVzaCh7XG4gICAgICAgICAgICAuLi5ub2RlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWROb2RlO1xufVxuXG5cblxuXG5leHBvcnQgeyRhOWU3MzgyYTdkMTExY2I1JGV4cG9ydCRiNDUzYTNiZmQ0YTVmYTllIGFzIHVzZUNvbWJvQm94U3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCIkazZQcHUkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSIsImdldENoaWxkTm9kZXMiLCIkazZQcHUkZ2V0Q2hpbGROb2RlcyIsInVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSIsIiRrNlBwdSR1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUiLCJMaXN0Q29sbGVjdGlvbiIsIiRrNlBwdSRMaXN0Q29sbGVjdGlvbiIsInVzZVN0YXRlIiwiJGs2UHB1JHVzZVN0YXRlIiwidXNlTWVtbyIsIiRrNlBwdSR1c2VNZW1vIiwidXNlUmVmIiwiJGs2UHB1JHVzZVJlZiIsInVzZUNhbGxiYWNrIiwiJGs2UHB1JHVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwiJGs2UHB1JHVzZUVmZmVjdCIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRrNlBwdSR1c2VDb250cm9sbGVkU3RhdGUiLCJ1c2VPdmVybGF5VHJpZ2dlclN0YXRlIiwiJGs2UHB1JHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUiLCIkYTllNzM4MmE3ZDExMWNiNSRleHBvcnQkYjQ1M2EzYmZkNGE1ZmE5ZSIsInByb3BzIiwiX2NvbGxlY3Rpb25fZ2V0SXRlbSIsIl9jb2xsZWN0aW9uX2dldEl0ZW0xIiwiZGVmYXVsdEZpbHRlciIsIm1lbnVUcmlnZ2VyIiwiYWxsb3dzRW1wdHlDb2xsZWN0aW9uIiwiYWxsb3dzQ3VzdG9tVmFsdWUiLCJzaG91bGRDbG9zZU9uQmx1ciIsInNob3dBbGxJdGVtcyIsInNldFNob3dBbGxJdGVtcyIsImlzRm9jdXNlZCIsInNldEZvY3VzZWRTdGF0ZSIsImZvY3VzU3RyYXRlZ3kiLCJzZXRGb2N1c1N0cmF0ZWd5Iiwib25TZWxlY3Rpb25DaGFuZ2UiLCJrZXkiLCJzZWxlY3RlZEtleSIsInJlc2V0SW5wdXRWYWx1ZSIsImNsb3NlTWVudSIsIl9wcm9wc19pdGVtcyIsImNvbGxlY3Rpb24iLCJzZWxlY3Rpb25NYW5hZ2VyIiwic2V0U2VsZWN0ZWRLZXkiLCJzZWxlY3RlZEl0ZW0iLCJkaXNhYmxlZEtleXMiLCJpdGVtcyIsImRlZmF1bHRJdGVtcyIsIl9wcm9wc19kZWZhdWx0SW5wdXRWYWx1ZSIsIl9yZWYiLCJpbnB1dFZhbHVlIiwic2V0SW5wdXRWYWx1ZSIsImRlZmF1bHRJbnB1dFZhbHVlIiwiZ2V0SXRlbSIsInRleHRWYWx1ZSIsIm9uSW5wdXRDaGFuZ2UiLCJvcmlnaW5hbENvbGxlY3Rpb24iLCJmaWx0ZXJlZENvbGxlY3Rpb24iLCIkYTllNzM4MmE3ZDExMWNiNSR2YXIkZmlsdGVyQ29sbGVjdGlvbiIsImxhc3RDb2xsZWN0aW9uIiwic2V0TGFzdENvbGxlY3Rpb24iLCJtZW51T3BlblRyaWdnZXIiLCJvbk9wZW5DaGFuZ2UiLCJvcGVuIiwiY3VycmVudCIsInVuZGVmaW5lZCIsInNldEZvY3VzZWQiLCJzZXRGb2N1c2VkS2V5IiwidHJpZ2dlclN0YXRlIiwiaXNPcGVuIiwiZGVmYXVsdE9wZW4iLCJ0cmlnZ2VyIiwiZGlzcGxheUFsbEl0ZW1zIiwic2l6ZSIsInRvZ2dsZSIsInRvZ2dsZU1lbnUiLCJ1cGRhdGVMYXN0Q29sbGVjdGlvbiIsImNsb3NlIiwibGFzdFZhbHVlIiwic2V0TGFzdFZhbHVlIiwiX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUiLCJpdGVtVGV4dCIsIl9wcm9wc19zZWxlY3RlZEtleSIsIl9yZWYxIiwibGFzdFNlbGVjdGVkS2V5IiwiZGVmYXVsdFNlbGVjdGVkS2V5IiwibGFzdFNlbGVjdGVkS2V5VGV4dCIsInNlbGVjdGVkSXRlbVRleHQiLCJ2YWxpZGF0aW9uIiwidmFsdWUiLCJyZXZlcnQiLCJjb21taXRDdXN0b21WYWx1ZSIsImNvbW1pdFNlbGVjdGlvbiIsImNvbW1pdFZhbHVlIiwiY29tbWl0IiwiZm9jdXNlZEtleSIsInZhbHVlT25Gb2N1cyIsImNvbW1pdFZhbGlkYXRpb24iLCJkaXNwbGF5ZWRDb2xsZWN0aW9uIiwiZmlsdGVyIiwiJGE5ZTczODJhN2QxMTFjYjUkdmFyJGZpbHRlck5vZGVzIiwibm9kZXMiLCJmaWx0ZXJlZE5vZGUiLCJub2RlIiwidHlwZSIsImhhc0NoaWxkTm9kZXMiLCJmaWx0ZXJlZCIsInNvbWUiLCJwdXNoIiwiY2hpbGROb2RlcyIsInVzZUNvbWJvQm94U3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/combobox/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/datepicker/dist/import.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@react-stately/datepicker/dist/import.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDateFieldState: () => (/* binding */ $3c0fc76039f1c516$export$60e84778edff6d26),\n/* harmony export */   useDatePickerState: () => (/* binding */ $ab5bf3f618090389$export$87194bb378cc3ac2),\n/* harmony export */   useDateRangePickerState: () => (/* binding */ $93c38a5e28be6249$export$e50a61c1de9f574),\n/* harmony export */   useTimeFieldState: () => (/* binding */ $eff5d8ee529ac4bb$export$fd53cef0cc796101)\n/* harmony export */ });\n/* harmony import */ var _internationalized_date__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @internationalized/date */ \"(ssr)/./node_modules/@internationalized/date/dist/import.mjs\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/datepicker/node_modules/@react-stately/overlays/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/datepicker/node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internationalized_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @internationalized/string */ \"(ssr)/./node_modules/@internationalized/string/dist/import.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $35a22f14a1f04b11$export$eac50920cf2fd59a(value, minValue, maxValue) {\n    return value != null && (minValue != null && value.compare(minValue) < 0 || maxValue != null && value.compare(maxValue) > 0);\n}\nconst $35a22f14a1f04b11$var$DEFAULT_FIELD_OPTIONS = {\n    year: \"numeric\",\n    month: \"numeric\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\"\n};\nconst $35a22f14a1f04b11$var$TWO_DIGIT_FIELD_OPTIONS = {\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\"\n};\nfunction $35a22f14a1f04b11$export$7e319ea407e63bc0(fieldOptions, options) {\n    let defaultFieldOptions = options.shouldForceLeadingZeros ? $35a22f14a1f04b11$var$TWO_DIGIT_FIELD_OPTIONS : $35a22f14a1f04b11$var$DEFAULT_FIELD_OPTIONS;\n    fieldOptions = {\n        ...defaultFieldOptions,\n        ...fieldOptions\n    };\n    let granularity = options.granularity || \"minute\";\n    let keys = Object.keys(fieldOptions);\n    var _options_maxGranularity;\n    let startIdx = keys.indexOf((_options_maxGranularity = options.maxGranularity) !== null && _options_maxGranularity !== void 0 ? _options_maxGranularity : \"year\");\n    if (startIdx < 0) startIdx = 0;\n    let endIdx = keys.indexOf(granularity);\n    if (endIdx < 0) endIdx = 2;\n    if (startIdx > endIdx) throw new Error(\"maxGranularity must be greater than granularity\");\n    let opts = keys.slice(startIdx, endIdx + 1).reduce((opts, key)=>{\n        opts[key] = fieldOptions[key];\n        return opts;\n    }, {});\n    if (options.hourCycle != null) opts.hour12 = options.hourCycle === 12;\n    opts.timeZone = options.timeZone || \"UTC\";\n    let hasTime = granularity === \"hour\" || granularity === \"minute\" || granularity === \"second\";\n    if (hasTime && options.timeZone && !options.hideTimeZone) opts.timeZoneName = \"short\";\n    if (options.showEra && startIdx === 0) opts.era = \"short\";\n    return opts;\n}\nfunction $35a22f14a1f04b11$export$c5221a78ef73c5e9(placeholderValue) {\n    if (placeholderValue && \"hour\" in placeholderValue) return placeholderValue;\n    return new (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.Time)();\n}\nfunction $35a22f14a1f04b11$export$61a490a80c552550(value, calendar) {\n    if (value === null) return null;\n    if (!value) return undefined;\n    return (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendar)(value, calendar);\n}\nfunction $35a22f14a1f04b11$export$66aa2b09de4b1ea5(placeholderValue, granularity, calendar, timeZone) {\n    if (placeholderValue) return $35a22f14a1f04b11$export$61a490a80c552550(placeholderValue, calendar);\n    let date = (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendar)((0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.now)(timeZone).set({\n        hour: 0,\n        minute: 0,\n        second: 0,\n        millisecond: 0\n    }), calendar);\n    if (granularity === \"year\" || granularity === \"month\" || granularity === \"day\") return (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendarDate)(date);\n    if (!timeZone) return (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendarDateTime)(date);\n    return date;\n}\nfunction $35a22f14a1f04b11$export$2440da353cedad43(v, granularity) {\n    // Compute default granularity and time zone from the value. If the value becomes null, keep the last values.\n    let defaultTimeZone = v && \"timeZone\" in v ? v.timeZone : undefined;\n    let defaultGranularity = v && \"minute\" in v ? \"minute\" : \"day\";\n    // props.granularity must actually exist in the value if one is provided.\n    if (v && granularity && !(granularity in v)) throw new Error(\"Invalid granularity \" + granularity + \" for value \" + v.toString());\n    let [lastValue, setLastValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([\n        defaultGranularity,\n        defaultTimeZone\n    ]);\n    // If the granularity or time zone changed, update the last value.\n    if (v && (lastValue[0] !== defaultGranularity || lastValue[1] !== defaultTimeZone)) setLastValue([\n        defaultGranularity,\n        defaultTimeZone\n    ]);\n    if (!granularity) granularity = v ? defaultGranularity : lastValue[0];\n    let timeZone = v ? defaultTimeZone : lastValue[1];\n    return [\n        granularity,\n        timeZone\n    ];\n}\nfunction $ab5bf3f618090389$export$87194bb378cc3ac2(props) {\n    var _props_isDateUnavailable;\n    let overlayState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_2__.useOverlayTriggerState)(props);\n    let [value, setValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.useControlledState)(props.value, props.defaultValue || null, props.onChange);\n    let v = value || props.placeholderValue;\n    let [granularity, defaultTimeZone] = (0, $35a22f14a1f04b11$export$2440da353cedad43)(v, props.granularity);\n    let dateValue = value != null ? value.toDate(defaultTimeZone !== null && defaultTimeZone !== void 0 ? defaultTimeZone : \"UTC\") : null;\n    let hasTime = granularity === \"hour\" || granularity === \"minute\" || granularity === \"second\";\n    var _props_shouldCloseOnSelect;\n    let shouldCloseOnSelect = (_props_shouldCloseOnSelect = props.shouldCloseOnSelect) !== null && _props_shouldCloseOnSelect !== void 0 ? _props_shouldCloseOnSelect : true;\n    let [selectedDate, setSelectedDate] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let [selectedTime, setSelectedTime] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    if (value) {\n        selectedDate = value;\n        if (\"hour\" in value) selectedTime = value;\n    }\n    // props.granularity must actually exist in the value if one is provided.\n    if (v && !(granularity in v)) throw new Error(\"Invalid granularity \" + granularity + \" for value \" + v.toString());\n    let commitValue = (date, time)=>{\n        setValue(\"timeZone\" in time ? time.set((0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendarDate)(date)) : (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendarDateTime)(date, time));\n        setSelectedDate(null);\n        setSelectedTime(null);\n    };\n    // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n    let selectDate = (newValue)=>{\n        let shouldClose = typeof shouldCloseOnSelect === \"function\" ? shouldCloseOnSelect() : shouldCloseOnSelect;\n        if (hasTime) {\n            if (selectedTime || shouldClose) commitValue(newValue, selectedTime || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue));\n            else setSelectedDate(newValue);\n        } else setValue(newValue);\n        if (shouldClose) overlayState.setOpen(false);\n    };\n    let selectTime = (newValue)=>{\n        if (selectedDate && newValue) commitValue(selectedDate, newValue);\n        else setSelectedTime(newValue);\n    };\n    let isValueInvalid = props.isInvalid || props.validationState === \"invalid\" || (0, $35a22f14a1f04b11$export$eac50920cf2fd59a)(value, props.minValue, props.maxValue) || value && ((_props_isDateUnavailable = props.isDateUnavailable) === null || _props_isDateUnavailable === void 0 ? void 0 : _props_isDateUnavailable.call(props, value));\n    let validationState = props.validationState || (isValueInvalid ? \"invalid\" : null);\n    return {\n        value: value,\n        setValue: setValue,\n        dateValue: selectedDate,\n        timeValue: selectedTime,\n        setDateValue: selectDate,\n        setTimeValue: selectTime,\n        granularity: granularity,\n        hasTime: hasTime,\n        ...overlayState,\n        setOpen (isOpen) {\n            // Commit the selected date when the calendar is closed. Use a placeholder time if one wasn't set.\n            // If only the time was set and not the date, don't commit. The state will be preserved until\n            // the user opens the popover again.\n            if (!isOpen && !value && selectedDate && hasTime) commitValue(selectedDate, selectedTime || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue));\n            overlayState.setOpen(isOpen);\n        },\n        validationState: validationState,\n        isInvalid: isValueInvalid,\n        formatValue (locale, fieldOptions) {\n            if (!dateValue) return \"\";\n            let formatOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, {\n                granularity: granularity,\n                timeZone: defaultTimeZone,\n                hideTimeZone: props.hideTimeZone,\n                hourCycle: props.hourCycle,\n                showEra: value.calendar.identifier === \"gregory\" && value.era === \"BC\"\n            });\n            let formatter = new (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.DateFormatter)(locale, formatOptions);\n            return formatter.format(dateValue);\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // These placeholders are based on the strings used by the <input type=\"date\">\n// implementations in Chrome and Firefox. Additional languages are supported\n// here than React Spectrum's typical translations.\nconst $3e3ed55ab2966714$var$placeholders = new (0, _internationalized_string__WEBPACK_IMPORTED_MODULE_4__.LocalizedStringDictionary)({\n    ach: {\n        year: \"mwaka\",\n        month: \"dwe\",\n        day: \"nino\"\n    },\n    af: {\n        year: \"jjjj\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    am: {\n        year: \"á‹“á‹“á‹“á‹“\",\n        month: \"áˆšáˆœ\",\n        day: \"á‰€á‰€\"\n    },\n    an: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    ar: {\n        year: \"Ø³Ù†Ø©\",\n        month: \"Ø´Ù‡Ø±\",\n        day: \"ÙŠÙˆÙ…\"\n    },\n    ast: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    az: {\n        year: \"iiii\",\n        month: \"aa\",\n        day: \"gg\"\n    },\n    be: {\n        year: \"Ð³Ð³Ð³Ð³\",\n        month: \"Ð¼Ð¼\",\n        day: \"Ð´Ð´\"\n    },\n    bg: {\n        year: \"Ð³Ð³Ð³Ð³\",\n        month: \"Ð¼Ð¼\",\n        day: \"Ð´Ð´\"\n    },\n    bn: {\n        year: \"yyyy\",\n        month: \"à¦®à¦¿à¦®à¦¿\",\n        day: \"dd\"\n    },\n    br: {\n        year: \"bbbb\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    bs: {\n        year: \"gggg\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    ca: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    cak: {\n        year: \"jjjj\",\n        month: \"ii\",\n        day: \"q'q'\"\n    },\n    ckb: {\n        year: \"Ø³Ø§Úµ\",\n        month: \"Ù…Ø§Ù†Ú¯\",\n        day: \"Ú•Û†Ú˜\"\n    },\n    cs: {\n        year: \"rrrr\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    cy: {\n        year: \"bbbb\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    da: {\n        year: \"\\xe5\\xe5\\xe5\\xe5\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    de: {\n        year: \"jjjj\",\n        month: \"mm\",\n        day: \"tt\"\n    },\n    dsb: {\n        year: \"llll\",\n        month: \"mm\",\n        day: \"ÅºÅº\"\n    },\n    el: {\n        year: \"ÎµÎµÎµÎµ\",\n        month: \"Î¼Î¼\",\n        day: \"Î·Î·\"\n    },\n    en: {\n        year: \"yyyy\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    eo: {\n        year: \"jjjj\",\n        month: \"mm\",\n        day: \"tt\"\n    },\n    es: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    et: {\n        year: \"aaaa\",\n        month: \"kk\",\n        day: \"pp\"\n    },\n    eu: {\n        year: \"uuuu\",\n        month: \"hh\",\n        day: \"ee\"\n    },\n    fa: {\n        year: \"Ø³Ø§Ù„\",\n        month: \"Ù…Ø§Ù‡\",\n        day: \"Ø±ÙˆØ²\"\n    },\n    ff: {\n        year: \"hhhh\",\n        month: \"ll\",\n        day: \"\\xf1\\xf1\"\n    },\n    fi: {\n        year: \"vvvv\",\n        month: \"kk\",\n        day: \"pp\"\n    },\n    fr: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"jj\"\n    },\n    fy: {\n        year: \"jjjj\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    ga: {\n        year: \"bbbb\",\n        month: \"mm\",\n        day: \"ll\"\n    },\n    gd: {\n        year: \"bbbb\",\n        month: \"mm\",\n        day: \"ll\"\n    },\n    gl: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    he: {\n        year: \"×©× ×”\",\n        month: \"×—×•×“×©\",\n        day: \"×™×•×\"\n    },\n    hr: {\n        year: \"gggg\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    hsb: {\n        year: \"llll\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    hu: {\n        year: \"\\xe9\\xe9\\xe9\\xe9\",\n        month: \"hh\",\n        day: \"nn\"\n    },\n    ia: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    id: {\n        year: \"tttt\",\n        month: \"bb\",\n        day: \"hh\"\n    },\n    it: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"gg\"\n    },\n    ja: {\n        year: \" å¹´ \",\n        month: \"æœˆ\",\n        day: \"æ—¥\"\n    },\n    ka: {\n        year: \"áƒ¬áƒ¬áƒ¬áƒ¬\",\n        month: \"áƒ—áƒ—\",\n        day: \"áƒ áƒ \"\n    },\n    kk: {\n        year: \"Ð¶Ð¶Ð¶Ð¶\",\n        month: \"Ð°Ð°\",\n        day: \"ÐºÐº\"\n    },\n    kn: {\n        year: \"à²µà²µà²µà²µ\",\n        month: \"à²®à²¿à²®à³€\",\n        day: \"à²¦à²¿à²¦à²¿\"\n    },\n    ko: {\n        year: \"ì—°ë„\",\n        month: \"ì›”\",\n        day: \"ì¼\"\n    },\n    lb: {\n        year: \"jjjj\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    lo: {\n        year: \"àº›àº›àº›àº›\",\n        month: \"àº”àº”\",\n        day: \"àº§àº§\"\n    },\n    lt: {\n        year: \"mmmm\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    lv: {\n        year: \"gggg\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    meh: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    ml: {\n        year: \"à´µàµ¼à´·à´‚\",\n        month: \"à´®à´¾à´¸à´‚\",\n        day: \"à´¤àµ€à´¯à´¤à´¿\"\n    },\n    ms: {\n        year: \"tttt\",\n        month: \"mm\",\n        day: \"hh\"\n    },\n    nl: {\n        year: \"jjjj\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    nn: {\n        year: \"\\xe5\\xe5\\xe5\\xe5\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    no: {\n        year: \"\\xe5\\xe5\\xe5\\xe5\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    oc: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"jj\"\n    },\n    pl: {\n        year: \"rrrr\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    pt: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    rm: {\n        year: \"oooo\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    ro: {\n        year: \"aaaa\",\n        month: \"ll\",\n        day: \"zz\"\n    },\n    ru: {\n        year: \"Ð³Ð³Ð³Ð³\",\n        month: \"Ð¼Ð¼\",\n        day: \"Ð´Ð´\"\n    },\n    sc: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    scn: {\n        year: \"aaaa\",\n        month: \"mm\",\n        day: \"jj\"\n    },\n    sk: {\n        year: \"rrrr\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    sl: {\n        year: \"llll\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    sr: {\n        year: \"Ð³Ð³Ð³Ð³\",\n        month: \"Ð¼Ð¼\",\n        day: \"Ð´Ð´\"\n    },\n    sv: {\n        year: \"\\xe5\\xe5\\xe5\\xe5\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    szl: {\n        year: \"rrrr\",\n        month: \"mm\",\n        day: \"dd\"\n    },\n    tg: {\n        year: \"ÑÑÑÑ\",\n        month: \"Ð¼Ð¼\",\n        day: \"Ñ€Ñ€\"\n    },\n    th: {\n        year: \"à¸›à¸›à¸›à¸›\",\n        month: \"à¸”à¸”\",\n        day: \"à¸§à¸§\"\n    },\n    tr: {\n        year: \"yyyy\",\n        month: \"aa\",\n        day: \"gg\"\n    },\n    uk: {\n        year: \"Ñ€Ñ€Ñ€Ñ€\",\n        month: \"Ð¼Ð¼\",\n        day: \"Ð´Ð´\"\n    },\n    \"zh-CN\": {\n        year: \"å¹´\",\n        month: \"æœˆ\",\n        day: \"æ—¥\"\n    },\n    \"zh-TW\": {\n        year: \"å¹´\",\n        month: \"æœˆ\",\n        day: \"æ—¥\"\n    }\n}, \"en\");\nfunction $3e3ed55ab2966714$export$d3f5c5e0a5023fa0(field, value, locale) {\n    // Use the actual placeholder value for the era and day period fields.\n    if (field === \"era\" || field === \"dayPeriod\") return value;\n    if (field === \"year\" || field === \"month\" || field === \"day\") return $3e3ed55ab2966714$var$placeholders.getStringForLocale(field, locale);\n    // For time fields (e.g. hour, minute, etc.), use two dashes as the placeholder.\n    return \"â€“â€“\";\n}\nconst $3c0fc76039f1c516$var$EDITABLE_SEGMENTS = {\n    year: true,\n    month: true,\n    day: true,\n    hour: true,\n    minute: true,\n    second: true,\n    dayPeriod: true,\n    era: true\n};\nconst $3c0fc76039f1c516$var$PAGE_STEP = {\n    year: 5,\n    month: 2,\n    day: 7,\n    hour: 2,\n    minute: 15,\n    second: 15\n};\n// Node seems to convert everything to lowercase...\nconst $3c0fc76039f1c516$var$TYPE_MAPPING = {\n    dayperiod: \"dayPeriod\"\n};\nfunction $3c0fc76039f1c516$export$60e84778edff6d26(props) {\n    let { locale: locale, createCalendar: createCalendar, hideTimeZone: hideTimeZone, isDisabled: isDisabled, isReadOnly: isReadOnly, isRequired: isRequired } = props;\n    let v = props.value || props.defaultValue || props.placeholderValue;\n    let [granularity, defaultTimeZone] = (0, $35a22f14a1f04b11$export$2440da353cedad43)(v, props.granularity);\n    let timeZone = defaultTimeZone || \"UTC\";\n    // props.granularity must actually exist in the value if one is provided.\n    if (v && !(granularity in v)) throw new Error(\"Invalid granularity \" + granularity + \" for value \" + v.toString());\n    let defaultFormatter = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.DateFormatter)(locale), [\n        locale\n    ]);\n    let calendar = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>createCalendar(defaultFormatter.resolvedOptions().calendar), [\n        createCalendar,\n        defaultFormatter\n    ]);\n    let [value, setDate] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.useControlledState)(props.value, props.defaultValue, props.onChange);\n    let calendarValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0, $35a22f14a1f04b11$export$61a490a80c552550)(value, calendar), [\n        value,\n        calendar\n    ]);\n    // We keep track of the placeholder date separately in state so that onChange is not called\n    // until all segments are set. If the value === null (not undefined), then assume the component\n    // is controlled, so use the placeholder as the value until all segments are entered so it doesn't\n    // change from uncontrolled to controlled and emit a warning.\n    let [placeholderDate, setPlaceholderDate] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>(0, $35a22f14a1f04b11$export$66aa2b09de4b1ea5)(props.placeholderValue, granularity, calendar, defaultTimeZone));\n    let val = calendarValue || placeholderDate;\n    let showEra = calendar.identifier === \"gregory\" && val.era === \"BC\";\n    var _props_maxGranularity;\n    let formatOpts = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            granularity: granularity,\n            maxGranularity: (_props_maxGranularity = props.maxGranularity) !== null && _props_maxGranularity !== void 0 ? _props_maxGranularity : \"year\",\n            timeZone: defaultTimeZone,\n            hideTimeZone: hideTimeZone,\n            hourCycle: props.hourCycle,\n            showEra: showEra,\n            shouldForceLeadingZeros: props.shouldForceLeadingZeros\n        }), [\n        props.maxGranularity,\n        granularity,\n        props.hourCycle,\n        props.shouldForceLeadingZeros,\n        defaultTimeZone,\n        hideTimeZone,\n        showEra\n    ]);\n    let opts = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0, $35a22f14a1f04b11$export$7e319ea407e63bc0)({}, formatOpts), [\n        formatOpts\n    ]);\n    let dateFormatter = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.DateFormatter)(locale, opts), [\n        locale,\n        opts\n    ]);\n    let resolvedOptions = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>dateFormatter.resolvedOptions(), [\n        dateFormatter\n    ]);\n    // Determine how many editable segments there are for validation purposes.\n    // The result is cached for performance.\n    let allSegments = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>dateFormatter.formatToParts(new Date()).filter((seg)=>$3c0fc76039f1c516$var$EDITABLE_SEGMENTS[seg.type]).reduce((p, seg)=>(p[seg.type] = true, p), {}), [\n        dateFormatter\n    ]);\n    let [validSegments, setValidSegments] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>props.value || props.defaultValue ? {\n            ...allSegments\n        } : {});\n    let clearedSegment = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    // Reset placeholder when calendar changes\n    let lastCalendarIdentifier = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(calendar.identifier);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (calendar.identifier !== lastCalendarIdentifier.current) {\n            lastCalendarIdentifier.current = calendar.identifier;\n            setPlaceholderDate((placeholder)=>Object.keys(validSegments).length > 0 ? (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendar)(placeholder, calendar) : (0, $35a22f14a1f04b11$export$66aa2b09de4b1ea5)(props.placeholderValue, granularity, calendar, defaultTimeZone));\n        }\n    }, [\n        calendar,\n        granularity,\n        validSegments,\n        defaultTimeZone,\n        props.placeholderValue\n    ]);\n    // If there is a value prop, and some segments were previously placeholders, mark them all as valid.\n    if (value && Object.keys(validSegments).length < Object.keys(allSegments).length) {\n        validSegments = {\n            ...allSegments\n        };\n        setValidSegments(validSegments);\n    }\n    // If the value is set to null and all segments are valid, reset the placeholder.\n    if (value == null && Object.keys(validSegments).length === Object.keys(allSegments).length) {\n        validSegments = {};\n        setValidSegments(validSegments);\n        setPlaceholderDate((0, $35a22f14a1f04b11$export$66aa2b09de4b1ea5)(props.placeholderValue, granularity, calendar, defaultTimeZone));\n    }\n    // If all segments are valid, use the date from state, otherwise use the placeholder date.\n    let displayValue = calendarValue && Object.keys(validSegments).length >= Object.keys(allSegments).length ? calendarValue : placeholderDate;\n    let setValue = (newValue)=>{\n        if (props.isDisabled || props.isReadOnly) return;\n        let validKeys = Object.keys(validSegments);\n        let allKeys = Object.keys(allSegments);\n        // if all the segments are completed or a timefield with everything but am/pm set the time, also ignore when am/pm cleared\n        if (newValue == null) {\n            setDate(null);\n            setPlaceholderDate((0, $35a22f14a1f04b11$export$66aa2b09de4b1ea5)(props.placeholderValue, granularity, calendar, defaultTimeZone));\n            setValidSegments({});\n        } else if (validKeys.length >= allKeys.length || validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod && clearedSegment.current !== \"dayPeriod\") {\n            // The display calendar should not have any effect on the emitted value.\n            // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n            newValue = (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendar)(newValue, (v === null || v === void 0 ? void 0 : v.calendar) || new (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.GregorianCalendar)());\n            setDate(newValue);\n        } else setPlaceholderDate(newValue);\n        clearedSegment.current = null;\n    };\n    let dateValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>displayValue.toDate(timeZone), [\n        displayValue,\n        timeZone\n    ]);\n    let segments = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>dateFormatter.formatToParts(dateValue).map((segment)=>{\n            let isEditable = $3c0fc76039f1c516$var$EDITABLE_SEGMENTS[segment.type];\n            if (segment.type === \"era\" && calendar.getEras().length === 1) isEditable = false;\n            let isPlaceholder = $3c0fc76039f1c516$var$EDITABLE_SEGMENTS[segment.type] && !validSegments[segment.type];\n            let placeholder = $3c0fc76039f1c516$var$EDITABLE_SEGMENTS[segment.type] ? (0, $3e3ed55ab2966714$export$d3f5c5e0a5023fa0)(segment.type, segment.value, locale) : null;\n            return {\n                type: $3c0fc76039f1c516$var$TYPE_MAPPING[segment.type] || segment.type,\n                text: isPlaceholder ? placeholder : segment.value,\n                ...$3c0fc76039f1c516$var$getSegmentLimits(displayValue, segment.type, resolvedOptions),\n                isPlaceholder: isPlaceholder,\n                placeholder: placeholder,\n                isEditable: isEditable\n            };\n        }), [\n        dateValue,\n        validSegments,\n        dateFormatter,\n        resolvedOptions,\n        displayValue,\n        calendar,\n        locale\n    ]);\n    // When the era field appears, mark it valid if the year field is already valid.\n    // If the era field disappears, remove it from the valid segments.\n    if (allSegments.era && validSegments.year && !validSegments.era) {\n        validSegments.era = true;\n        setValidSegments({\n            ...validSegments\n        });\n    } else if (!allSegments.era && validSegments.era) {\n        delete validSegments.era;\n        setValidSegments({\n            ...validSegments\n        });\n    }\n    let markValid = (part)=>{\n        validSegments[part] = true;\n        if (part === \"year\" && allSegments.era) validSegments.era = true;\n        setValidSegments({\n            ...validSegments\n        });\n    };\n    let adjustSegment = (type, amount)=>{\n        if (!validSegments[type]) {\n            markValid(type);\n            let validKeys = Object.keys(validSegments);\n            let allKeys = Object.keys(allSegments);\n            if (validKeys.length >= allKeys.length || validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod) setValue(displayValue);\n        } else setValue($3c0fc76039f1c516$var$addSegment(displayValue, type, amount, resolvedOptions));\n    };\n    let isValueInvalid = props.isInvalid || props.validationState === \"invalid\" || (0, $35a22f14a1f04b11$export$eac50920cf2fd59a)(calendarValue, props.minValue, props.maxValue);\n    let validationState = props.validationState || (isValueInvalid ? \"invalid\" : null);\n    var _props_maxGranularity1;\n    return {\n        value: calendarValue,\n        dateValue: dateValue,\n        calendar: calendar,\n        setValue: setValue,\n        segments: segments,\n        dateFormatter: dateFormatter,\n        validationState: validationState,\n        isInvalid: isValueInvalid,\n        granularity: granularity,\n        maxGranularity: (_props_maxGranularity1 = props.maxGranularity) !== null && _props_maxGranularity1 !== void 0 ? _props_maxGranularity1 : \"year\",\n        isDisabled: isDisabled,\n        isReadOnly: isReadOnly,\n        isRequired: isRequired,\n        increment (part) {\n            adjustSegment(part, 1);\n        },\n        decrement (part) {\n            adjustSegment(part, -1);\n        },\n        incrementPage (part) {\n            adjustSegment(part, $3c0fc76039f1c516$var$PAGE_STEP[part] || 1);\n        },\n        decrementPage (part) {\n            adjustSegment(part, -($3c0fc76039f1c516$var$PAGE_STEP[part] || 1));\n        },\n        setSegment (part, v) {\n            markValid(part);\n            setValue($3c0fc76039f1c516$var$setSegment(displayValue, part, v, resolvedOptions));\n        },\n        confirmPlaceholder () {\n            if (props.isDisabled || props.isReadOnly) return;\n            // Confirm the placeholder if only the day period is not filled in.\n            let validKeys = Object.keys(validSegments);\n            let allKeys = Object.keys(allSegments);\n            if (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod) {\n                validSegments = {\n                    ...allSegments\n                };\n                setValidSegments(validSegments);\n                setValue(displayValue.copy());\n            }\n        },\n        clearSegment (part) {\n            delete validSegments[part];\n            clearedSegment.current = part;\n            setValidSegments({\n                ...validSegments\n            });\n            let placeholder = (0, $35a22f14a1f04b11$export$66aa2b09de4b1ea5)(props.placeholderValue, granularity, calendar, defaultTimeZone);\n            let value = displayValue;\n            // Reset day period to default without changing the hour.\n            if (part === \"dayPeriod\" && \"hour\" in displayValue && \"hour\" in placeholder) {\n                let isPM = displayValue.hour >= 12;\n                let shouldBePM = placeholder.hour >= 12;\n                if (isPM && !shouldBePM) value = displayValue.set({\n                    hour: displayValue.hour - 12\n                });\n                else if (!isPM && shouldBePM) value = displayValue.set({\n                    hour: displayValue.hour + 12\n                });\n            } else if (part in displayValue) value = displayValue.set({\n                [part]: placeholder[part]\n            });\n            setDate(null);\n            setValue(value);\n        },\n        formatValue (fieldOptions) {\n            if (!calendarValue) return \"\";\n            let formatOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, formatOpts);\n            let formatter = new (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.DateFormatter)(locale, formatOptions);\n            return formatter.format(dateValue);\n        }\n    };\n}\nfunction $3c0fc76039f1c516$var$getSegmentLimits(date, type, options) {\n    switch(type){\n        case \"era\":\n            {\n                let eras = date.calendar.getEras();\n                return {\n                    value: eras.indexOf(date.era),\n                    minValue: 0,\n                    maxValue: eras.length - 1\n                };\n            }\n        case \"year\":\n            return {\n                value: date.year,\n                minValue: 1,\n                maxValue: date.calendar.getYearsInEra(date)\n            };\n        case \"month\":\n            return {\n                value: date.month,\n                minValue: (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.getMinimumMonthInYear)(date),\n                maxValue: date.calendar.getMonthsInYear(date)\n            };\n        case \"day\":\n            return {\n                value: date.day,\n                minValue: (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.getMinimumDayInMonth)(date),\n                maxValue: date.calendar.getDaysInMonth(date)\n            };\n    }\n    if (\"hour\" in date) switch(type){\n        case \"dayPeriod\":\n            return {\n                value: date.hour >= 12 ? 12 : 0,\n                minValue: 0,\n                maxValue: 12\n            };\n        case \"hour\":\n            if (options.hour12) {\n                let isPM = date.hour >= 12;\n                return {\n                    value: date.hour,\n                    minValue: isPM ? 12 : 0,\n                    maxValue: isPM ? 23 : 11\n                };\n            }\n            return {\n                value: date.hour,\n                minValue: 0,\n                maxValue: 23\n            };\n        case \"minute\":\n            return {\n                value: date.minute,\n                minValue: 0,\n                maxValue: 59\n            };\n        case \"second\":\n            return {\n                value: date.second,\n                minValue: 0,\n                maxValue: 59\n            };\n    }\n    return {};\n}\nfunction $3c0fc76039f1c516$var$addSegment(value, part, amount, options) {\n    switch(part){\n        case \"era\":\n        case \"year\":\n        case \"month\":\n        case \"day\":\n            return value.cycle(part, amount, {\n                round: part === \"year\"\n            });\n    }\n    if (\"hour\" in value) switch(part){\n        case \"dayPeriod\":\n            {\n                let hours = value.hour;\n                let isPM = hours >= 12;\n                return value.set({\n                    hour: isPM ? hours - 12 : hours + 12\n                });\n            }\n        case \"hour\":\n        case \"minute\":\n        case \"second\":\n            return value.cycle(part, amount, {\n                round: part !== \"hour\",\n                hourCycle: options.hour12 ? 12 : 24\n            });\n    }\n}\nfunction $3c0fc76039f1c516$var$setSegment(value, part, segmentValue, options) {\n    switch(part){\n        case \"day\":\n        case \"month\":\n        case \"year\":\n        case \"era\":\n            return value.set({\n                [part]: segmentValue\n            });\n    }\n    if (\"hour\" in value) switch(part){\n        case \"dayPeriod\":\n            {\n                let hours = value.hour;\n                let wasPM = hours >= 12;\n                let isPM = segmentValue >= 12;\n                if (isPM === wasPM) return value;\n                return value.set({\n                    hour: wasPM ? hours - 12 : hours + 12\n                });\n            }\n        case \"hour\":\n            // In 12 hour time, ensure that AM/PM does not change\n            if (options.hour12) {\n                let hours = value.hour;\n                let wasPM = hours >= 12;\n                if (!wasPM && segmentValue === 12) segmentValue = 0;\n                if (wasPM && segmentValue < 12) segmentValue += 12;\n            }\n        // fallthrough\n        case \"minute\":\n        case \"second\":\n            return value.set({\n                [part]: segmentValue\n            });\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $93c38a5e28be6249$export$e50a61c1de9f574(props) {\n    var _props_isDateUnavailable, _props_isDateUnavailable1;\n    let overlayState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_2__.useOverlayTriggerState)(props);\n    let [controlledValue, setControlledValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.useControlledState)(props.value, props.defaultValue || null, props.onChange);\n    let [placeholderValue, setPlaceholderValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>controlledValue || {\n            start: null,\n            end: null\n        });\n    // Reset the placeholder if the value prop is set to null.\n    if (controlledValue == null && placeholderValue.start && placeholderValue.end) {\n        placeholderValue = {\n            start: null,\n            end: null\n        };\n        setPlaceholderValue(placeholderValue);\n    }\n    let value = controlledValue || placeholderValue;\n    let setValue = (value)=>{\n        setPlaceholderValue(value || {\n            start: null,\n            end: null\n        });\n        if ((value === null || value === void 0 ? void 0 : value.start) && value.end) setControlledValue(value);\n        else setControlledValue(null);\n    };\n    let v = (value === null || value === void 0 ? void 0 : value.start) || (value === null || value === void 0 ? void 0 : value.end) || props.placeholderValue;\n    let [granularity] = (0, $35a22f14a1f04b11$export$2440da353cedad43)(v, props.granularity);\n    let hasTime = granularity === \"hour\" || granularity === \"minute\" || granularity === \"second\";\n    var _props_shouldCloseOnSelect;\n    let shouldCloseOnSelect = (_props_shouldCloseOnSelect = props.shouldCloseOnSelect) !== null && _props_shouldCloseOnSelect !== void 0 ? _props_shouldCloseOnSelect : true;\n    let [dateRange, setSelectedDateRange] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let [timeRange, setSelectedTimeRange] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    if (value && value.start && value.end) {\n        dateRange = value;\n        if (\"hour\" in value.start) timeRange = value;\n    }\n    let commitValue = (dateRange, timeRange)=>{\n        setValue({\n            start: \"timeZone\" in timeRange.start ? timeRange.start.set((0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendarDate)(dateRange.start)) : (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendarDateTime)(dateRange.start, timeRange.start),\n            end: \"timeZone\" in timeRange.end ? timeRange.end.set((0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendarDate)(dateRange.end)) : (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendarDateTime)(dateRange.end, timeRange.end)\n        });\n        setSelectedDateRange(null);\n        setSelectedTimeRange(null);\n    };\n    // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n    let setDateRange = (range)=>{\n        let shouldClose = typeof shouldCloseOnSelect === \"function\" ? shouldCloseOnSelect() : shouldCloseOnSelect;\n        if (hasTime) {\n            if (shouldClose || range.start && range.end && (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) && (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end)) commitValue(range, {\n                start: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue),\n                end: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue)\n            });\n            else setSelectedDateRange(range);\n        } else if (range.start && range.end) setValue(range);\n        else setSelectedDateRange(range);\n        if (shouldClose) overlayState.setOpen(false);\n    };\n    let setTimeRange = (range)=>{\n        if ((dateRange === null || dateRange === void 0 ? void 0 : dateRange.start) && (dateRange === null || dateRange === void 0 ? void 0 : dateRange.end) && range.start && range.end) commitValue(dateRange, range);\n        else setSelectedTimeRange(range);\n    };\n    let isValueInvalid = props.isInvalid || props.validationState === \"invalid\" || value != null && ((0, $35a22f14a1f04b11$export$eac50920cf2fd59a)(value.start, props.minValue, props.maxValue) || (0, $35a22f14a1f04b11$export$eac50920cf2fd59a)(value.end, props.minValue, props.maxValue) || value.end != null && value.start != null && value.end.compare(value.start) < 0 || (value === null || value === void 0 ? void 0 : value.start) && ((_props_isDateUnavailable = props.isDateUnavailable) === null || _props_isDateUnavailable === void 0 ? void 0 : _props_isDateUnavailable.call(props, value.start)) || (value === null || value === void 0 ? void 0 : value.end) && ((_props_isDateUnavailable1 = props.isDateUnavailable) === null || _props_isDateUnavailable1 === void 0 ? void 0 : _props_isDateUnavailable1.call(props, value.end)));\n    let validationState = props.validationState || (isValueInvalid ? \"invalid\" : null);\n    return {\n        value: value,\n        setValue: setValue,\n        dateRange: dateRange,\n        timeRange: timeRange,\n        granularity: granularity,\n        hasTime: hasTime,\n        setDate (part, date) {\n            setDateRange({\n                ...dateRange,\n                [part]: date\n            });\n        },\n        setTime (part, time) {\n            setTimeRange({\n                ...timeRange,\n                [part]: time\n            });\n        },\n        setDateTime (part, dateTime) {\n            setValue({\n                ...value,\n                [part]: dateTime\n            });\n        },\n        setDateRange: setDateRange,\n        setTimeRange: setTimeRange,\n        ...overlayState,\n        setOpen (isOpen) {\n            // Commit the selected date range when the calendar is closed. Use a placeholder time if one wasn't set.\n            // If only the time range was set and not the date range, don't commit. The state will be preserved until\n            // the user opens the popover again.\n            if (!isOpen && !((value === null || value === void 0 ? void 0 : value.start) && (value === null || value === void 0 ? void 0 : value.end)) && (dateRange === null || dateRange === void 0 ? void 0 : dateRange.start) && (dateRange === null || dateRange === void 0 ? void 0 : dateRange.end) && hasTime) commitValue(dateRange, {\n                start: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue),\n                end: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue)\n            });\n            overlayState.setOpen(isOpen);\n        },\n        validationState: validationState,\n        isInvalid: isValueInvalid,\n        formatValue (locale, fieldOptions) {\n            if (!value || !value.start || !value.end) return null;\n            let startTimeZone = \"timeZone\" in value.start ? value.start.timeZone : undefined;\n            let startGranularity = props.granularity || (value.start && \"minute\" in value.start ? \"minute\" : \"day\");\n            let endTimeZone = \"timeZone\" in value.end ? value.end.timeZone : undefined;\n            let endGranularity = props.granularity || (value.end && \"minute\" in value.end ? \"minute\" : \"day\");\n            let startOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, {\n                granularity: startGranularity,\n                timeZone: startTimeZone,\n                hideTimeZone: props.hideTimeZone,\n                hourCycle: props.hourCycle,\n                showEra: value.start.calendar.identifier === \"gregory\" && value.start.era === \"BC\" || value.end.calendar.identifier === \"gregory\" && value.end.era === \"BC\"\n            });\n            let startDate = value.start.toDate(startTimeZone || \"UTC\");\n            let endDate = value.end.toDate(endTimeZone || \"UTC\");\n            let startFormatter = new (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.DateFormatter)(locale, startOptions);\n            let endFormatter;\n            if (startTimeZone === endTimeZone && startGranularity === endGranularity && value.start.compare(value.end) !== 0) {\n                // Use formatRange, as it results in shorter output when some of the fields\n                // are shared between the start and end dates (e.g. the same month).\n                // Formatting will fail if the end date is before the start date. Fall back below when that happens.\n                try {\n                    let parts = startFormatter.formatRangeToParts(startDate, endDate);\n                    // Find the separator between the start and end date. This is determined\n                    // by finding the last shared literal before the end range.\n                    let separatorIndex = -1;\n                    for(let i = 0; i < parts.length; i++){\n                        let part = parts[i];\n                        if (part.source === \"shared\" && part.type === \"literal\") separatorIndex = i;\n                        else if (part.source === \"endRange\") break;\n                    }\n                    // Now we can combine the parts into start and end strings.\n                    let start = \"\";\n                    let end = \"\";\n                    for(let i = 0; i < parts.length; i++){\n                        if (i < separatorIndex) start += parts[i].value;\n                        else if (i > separatorIndex) end += parts[i].value;\n                    }\n                    return {\n                        start: start,\n                        end: end\n                    };\n                } catch (e) {\n                // ignore\n                }\n                endFormatter = startFormatter;\n            } else {\n                let endOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, {\n                    granularity: endGranularity,\n                    timeZone: endTimeZone,\n                    hideTimeZone: props.hideTimeZone,\n                    hourCycle: props.hourCycle\n                });\n                endFormatter = new (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.DateFormatter)(locale, endOptions);\n            }\n            return {\n                start: startFormatter.format(startDate),\n                end: endFormatter.format(endDate)\n            };\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $eff5d8ee529ac4bb$export$fd53cef0cc796101(props) {\n    let { placeholderValue: placeholderValue = new (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.Time)(), minValue: minValue, maxValue: maxValue, granularity: granularity } = props;\n    let [value, setValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.useControlledState)(props.value, props.defaultValue, props.onChange);\n    let v = value || placeholderValue;\n    let day = v && \"day\" in v ? v : undefined;\n    let defaultValueTimeZone = props.defaultValue && \"timeZone\" in props.defaultValue ? props.defaultValue.timeZone : undefined;\n    let placeholderDate = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let valueTimeZone = v && \"timeZone\" in v ? v.timeZone : undefined;\n        return (valueTimeZone || defaultValueTimeZone) && placeholderValue ? (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toZoned)($eff5d8ee529ac4bb$var$convertValue(placeholderValue), valueTimeZone || defaultValueTimeZone) : $eff5d8ee529ac4bb$var$convertValue(placeholderValue);\n    }, [\n        placeholderValue,\n        v,\n        defaultValueTimeZone\n    ]);\n    let minDate = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$eff5d8ee529ac4bb$var$convertValue(minValue, day), [\n        minValue,\n        day\n    ]);\n    let maxDate = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$eff5d8ee529ac4bb$var$convertValue(maxValue, day), [\n        maxValue,\n        day\n    ]);\n    let timeValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>value && \"day\" in value ? (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toTime)(value) : value, [\n        value\n    ]);\n    let dateTime = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>value == null ? null : $eff5d8ee529ac4bb$var$convertValue(value), [\n        value\n    ]);\n    let onChange = (newValue)=>{\n        setValue(day || defaultValueTimeZone ? newValue : newValue && (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toTime)(newValue));\n    };\n    let state = (0, $3c0fc76039f1c516$export$60e84778edff6d26)({\n        ...props,\n        value: dateTime,\n        defaultValue: undefined,\n        minValue: minDate,\n        maxValue: maxDate,\n        onChange: onChange,\n        granularity: granularity || \"minute\",\n        maxGranularity: \"hour\",\n        placeholderValue: placeholderDate,\n        // Calendar should not matter for time fields.\n        createCalendar: ()=>new (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.GregorianCalendar)()\n    });\n    return {\n        ...state,\n        timeValue: timeValue\n    };\n}\nfunction $eff5d8ee529ac4bb$var$convertValue(value, date = (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.today)((0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.getLocalTimeZone)())) {\n    if (!value) return null;\n    if (\"day\" in value) return value;\n    return (0, _internationalized_date__WEBPACK_IMPORTED_MODULE_1__.toCalendarDateTime)(date, value);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZGF0ZXBpY2tlci9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQW9nQjtBQUNwYTtBQUNYO0FBQ2dEO0FBQzdCO0FBRXhHOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0Q7Ozs7Ozs7Ozs7Q0FVQyxHQUVELFNBQVN3QywwQ0FBMENDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxRQUFRO0lBQ3hFLE9BQU9GLFNBQVMsUUFBU0MsQ0FBQUEsWUFBWSxRQUFRRCxNQUFNRyxPQUFPLENBQUNGLFlBQVksS0FBS0MsWUFBWSxRQUFRRixNQUFNRyxPQUFPLENBQUNELFlBQVk7QUFDOUg7QUFDQSxNQUFNRSw4Q0FBOEM7SUFDaERDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxRQUFRO0FBQ1o7QUFDQSxNQUFNQyxnREFBZ0Q7SUFDbEROLE1BQU07SUFDTkMsT0FBTztJQUNQQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxRQUFRO0FBQ1o7QUFDQSxTQUFTRSwwQ0FBMENDLFlBQVksRUFBRUMsT0FBTztJQUNwRSxJQUFJQyxzQkFBc0JELFFBQVFFLHVCQUF1QixHQUFHTCxnREFBZ0RQO0lBQzVHUyxlQUFlO1FBQ1gsR0FBR0UsbUJBQW1CO1FBQ3RCLEdBQUdGLFlBQVk7SUFDbkI7SUFDQSxJQUFJSSxjQUFjSCxRQUFRRyxXQUFXLElBQUk7SUFDekMsSUFBSUMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDTDtJQUN2QixJQUFJTztJQUNKLElBQUlDLFdBQVdILEtBQUtJLE9BQU8sQ0FBQyxDQUFDRiwwQkFBMEJOLFFBQVFTLGNBQWMsTUFBTSxRQUFRSCw0QkFBNEIsS0FBSyxJQUFJQSwwQkFBMEI7SUFDMUosSUFBSUMsV0FBVyxHQUFHQSxXQUFXO0lBQzdCLElBQUlHLFNBQVNOLEtBQUtJLE9BQU8sQ0FB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UEMsS0FBSztJQUNUO0lBQ0EwRixLQUFLO1FBQ0Q1RixNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0EyRixJQUFJO1FBQ0E3RixNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E0RixJQUFJO1FBQ0E5RixNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E2RixJQUFJO1FBQ0EvRixNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E4RixJQUFJO1FBQ0FoRyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0ErRixJQUFJO1FBQ0FqRyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FnRyxJQUFJO1FBQ0FsRyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FpRyxJQUFJO1FBQ0FuRyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FrRyxLQUFLO1FBQ0RwRyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FtRyxLQUFLO1FBQ0RyRyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FvRyxJQUFJO1FBQ0F0RyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FxRyxJQUFJO1FBQ0F2RyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FzRyxJQUFJO1FBQ0F4RyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0F1RyxJQUFJO1FBQ0F6RyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0F3RyxLQUFLO1FBQ0QxRyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0F5RyxJQUFJO1FBQ0EzRyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0EwRyxJQUFJO1FBQ0E1RyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0EyRyxJQUFJO1FBQ0E3RyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E0RyxJQUFJO1FBQ0E5RyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E2RyxJQUFJO1FBQ0EvRyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E4RyxJQUFJO1FBQ0FoSCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0ErRyxJQUFJO1FBQ0FqSCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FnSCxJQUFJO1FBQ0FsSCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FpSCxJQUFJO1FBQ0FuSCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FrSCxJQUFJO1FBQ0FwSCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FtSCxJQUFJO1FBQ0FySCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FvSCxJQUFJO1FBQ0F0SCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FxSCxJQUFJO1FBQ0F2SCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FzSCxJQUFJO1FBQ0F4SCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0F1SCxJQUFJO1FBQ0F6SCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0F3SCxJQUFJO1FBQ0ExSCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0F5SCxLQUFLO1FBQ0QzSCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0EwSCxJQUFJO1FBQ0E1SCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0EySCxJQUFJO1FBQ0E3SCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E0SCxJQUFJO1FBQ0E5SCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E2SCxJQUFJO1FBQ0EvSCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E4SCxJQUFJO1FBQ0FoSSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0ErSCxJQUFJO1FBQ0FqSSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FnSSxJQUFJO1FBQ0FsSSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FpSSxJQUFJO1FBQ0FuSSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FrSSxJQUFJO1FBQ0FwSSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FtSSxJQUFJO1FBQ0FySSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FvSSxJQUFJO1FBQ0F0SSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FxSSxJQUFJO1FBQ0F2SSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0FzSSxJQUFJO1FBQ0F4SSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0F1SSxLQUFLO1FBQ0R6SSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0F3SSxJQUFJO1FBQ0ExSSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0F5SSxJQUFJO1FBQ0EzSSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0EwSSxJQUFJO1FBQ0E1SSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0EySSxJQUFJO1FBQ0E3SSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E0SSxJQUFJO1FBQ0E5SSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E2SSxJQUFJO1FBQ0EvSSxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNUO0lBQ0E4SSxJQUFJO1FBQ0FoSixNQUFNO1FBQ05DLE9BQU87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LEVBQUcsQ0FBQyxHQUFHRSxxRUFBc0IsSUFBSztJQUN2RyxJQUFJLENBQUNnQixPQUFPLE9BQU87SUFDbkIsSUFBSSxTQUFTQSxPQUFPLE9BQU9BO0lBQzNCLE9BQU8sQ0FBQyxHQUFHdEMsdUVBQXdCLEVBQUdrRixNQUFNNUM7QUFDaEQ7QUFLOFEsQ0FDOVEsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZGF0ZXBpY2tlci9kaXN0L2ltcG9ydC5tanM/ZTk1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3RvQ2FsZW5kYXJEYXRlIGFzICQ3VXpvTSR0b0NhbGVuZGFyRGF0ZSwgdG9DYWxlbmRhckRhdGVUaW1lIGFzICQ3VXpvTSR0b0NhbGVuZGFyRGF0ZVRpbWUsIERhdGVGb3JtYXR0ZXIgYXMgJDdVem9NJERhdGVGb3JtYXR0ZXIsIFRpbWUgYXMgJDdVem9NJFRpbWUsIHRvQ2FsZW5kYXIgYXMgJDdVem9NJHRvQ2FsZW5kYXIsIG5vdyBhcyAkN1V6b00kbm93LCBHcmVnb3JpYW5DYWxlbmRhciBhcyAkN1V6b00kR3JlZ29yaWFuQ2FsZW5kYXIsIGdldE1pbmltdW1Nb250aEluWWVhciBhcyAkN1V6b00kZ2V0TWluaW11bU1vbnRoSW5ZZWFyLCBnZXRNaW5pbXVtRGF5SW5Nb250aCBhcyAkN1V6b00kZ2V0TWluaW11bURheUluTW9udGgsIHRvWm9uZWQgYXMgJDdVem9NJHRvWm9uZWQsIHRvVGltZSBhcyAkN1V6b00kdG9UaW1lLCB0b2RheSBhcyAkN1V6b00kdG9kYXksIGdldExvY2FsVGltZVpvbmUgYXMgJDdVem9NJGdldExvY2FsVGltZVpvbmV9IGZyb20gXCJAaW50ZXJuYXRpb25hbGl6ZWQvZGF0ZVwiO1xuaW1wb3J0IHt1c2VPdmVybGF5VHJpZ2dlclN0YXRlIGFzICQ3VXpvTSR1c2VPdmVybGF5VHJpZ2dlclN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXNcIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICQ3VXpvTSR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuaW1wb3J0IHt1c2VTdGF0ZSBhcyAkN1V6b00kdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDdVem9NJHVzZU1lbW8sIHVzZVJlZiBhcyAkN1V6b00kdXNlUmVmLCB1c2VFZmZlY3QgYXMgJDdVem9NJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge0xvY2FsaXplZFN0cmluZ0RpY3Rpb25hcnkgYXMgJDdVem9NJExvY2FsaXplZFN0cmluZ0RpY3Rpb25hcnl9IGZyb20gXCJAaW50ZXJuYXRpb25hbGl6ZWQvc3RyaW5nXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCRlYWM1MDkyMGNmMmZkNTlhKHZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAobWluVmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5jb21wYXJlKG1pblZhbHVlKSA8IDAgfHwgbWF4VmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5jb21wYXJlKG1heFZhbHVlKSA+IDApO1xufVxuY29uc3QgJDM1YTIyZjE0YTFmMDRiMTEkdmFyJERFRkFVTFRfRklFTERfT1BUSU9OUyA9IHtcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCJudW1lcmljXCIsXG4gICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIHNlY29uZDogXCIyLWRpZ2l0XCJcbn07XG5jb25zdCAkMzVhMjJmMTRhMWYwNGIxMSR2YXIkVFdPX0RJR0lUX0ZJRUxEX09QVElPTlMgPSB7XG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICBzZWNvbmQ6IFwiMi1kaWdpdFwiXG59O1xuZnVuY3Rpb24gJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JDdlMzE5ZWE0MDdlNjNiYzAoZmllbGRPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgbGV0IGRlZmF1bHRGaWVsZE9wdGlvbnMgPSBvcHRpb25zLnNob3VsZEZvcmNlTGVhZGluZ1plcm9zID8gJDM1YTIyZjE0YTFmMDRiMTEkdmFyJFRXT19ESUdJVF9GSUVMRF9PUFRJT05TIDogJDM1YTIyZjE0YTFmMDRiMTEkdmFyJERFRkFVTFRfRklFTERfT1BUSU9OUztcbiAgICBmaWVsZE9wdGlvbnMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRGaWVsZE9wdGlvbnMsXG4gICAgICAgIC4uLmZpZWxkT3B0aW9uc1xuICAgIH07XG4gICAgbGV0IGdyYW51bGFyaXR5ID0gb3B0aW9ucy5ncmFudWxhcml0eSB8fCBcIm1pbnV0ZVwiO1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRPcHRpb25zKTtcbiAgICB2YXIgX29wdGlvbnNfbWF4R3JhbnVsYXJpdHk7XG4gICAgbGV0IHN0YXJ0SWR4ID0ga2V5cy5pbmRleE9mKChfb3B0aW9uc19tYXhHcmFudWxhcml0eSA9IG9wdGlvbnMubWF4R3JhbnVsYXJpdHkpICE9PSBudWxsICYmIF9vcHRpb25zX21heEdyYW51bGFyaXR5ICE9PSB2b2lkIDAgPyBfb3B0aW9uc19tYXhHcmFudWxhcml0eSA6IFwieWVhclwiKTtcbiAgICBpZiAoc3RhcnRJZHggPCAwKSBzdGFydElkeCA9IDA7XG4gICAgbGV0IGVuZElkeCA9IGtleXMuaW5kZXhPZihncmFudWxhcml0eSk7XG4gICAgaWYgKGVuZElkeCA8IDApIGVuZElkeCA9IDI7XG4gICAgaWYgKHN0YXJ0SWR4ID4gZW5kSWR4KSB0aHJvdyBuZXcgRXJyb3IoXCJtYXhHcmFudWxhcml0eSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBncmFudWxhcml0eVwiKTtcbiAgICBsZXQgb3B0cyA9IGtleXMuc2xpY2Uoc3RhcnRJZHgsIGVuZElkeCArIDEpLnJlZHVjZSgob3B0cywga2V5KT0+e1xuICAgICAgICBvcHRzW2tleV0gPSBmaWVsZE9wdGlvbnNba2V5XTtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfSwge30pO1xuICAgIGlmIChvcHRpb25zLmhvdXJDeWNsZSAhPSBudWxsKSBvcHRzLmhvdXIxMiA9IG9wdGlvbnMuaG91ckN5Y2xlID09PSAxMjtcbiAgICBvcHRzLnRpbWVab25lID0gb3B0aW9ucy50aW1lWm9uZSB8fCBcIlVUQ1wiO1xuICAgIGxldCBoYXNUaW1lID0gZ3JhbnVsYXJpdHkgPT09IFwiaG91clwiIHx8IGdyYW51bGFyaXR5ID09PSBcIm1pbnV0ZVwiIHx8IGdyYW51bGFyaXR5ID09PSBcInNlY29uZFwiO1xuICAgIGlmIChoYXNUaW1lICYmIG9wdGlvbnMudGltZVpvbmUgJiYgIW9wdGlvbnMuaGlkZVRpbWVab25lKSBvcHRzLnRpbWVab25lTmFtZSA9IFwic2hvcnRcIjtcbiAgICBpZiAob3B0aW9ucy5zaG93RXJhICYmIHN0YXJ0SWR4ID09PSAwKSBvcHRzLmVyYSA9IFwic2hvcnRcIjtcbiAgICByZXR1cm4gb3B0cztcbn1cbmZ1bmN0aW9uICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCRjNTIyMWE3OGVmNzNjNWU5KHBsYWNlaG9sZGVyVmFsdWUpIHtcbiAgICBpZiAocGxhY2Vob2xkZXJWYWx1ZSAmJiBcImhvdXJcIiBpbiBwbGFjZWhvbGRlclZhbHVlKSByZXR1cm4gcGxhY2Vob2xkZXJWYWx1ZTtcbiAgICByZXR1cm4gbmV3ICgwLCAkN1V6b00kVGltZSkoKTtcbn1cbmZ1bmN0aW9uICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCQ2MWE0OTBhODBjNTUyNTUwKHZhbHVlLCBjYWxlbmRhcikge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKDAsICQ3VXpvTSR0b0NhbGVuZGFyKSh2YWx1ZSwgY2FsZW5kYXIpO1xufVxuZnVuY3Rpb24gJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JDY2YWEyYjA5ZGU0YjFlYTUocGxhY2Vob2xkZXJWYWx1ZSwgZ3JhbnVsYXJpdHksIGNhbGVuZGFyLCB0aW1lWm9uZSkge1xuICAgIGlmIChwbGFjZWhvbGRlclZhbHVlKSByZXR1cm4gJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JDYxYTQ5MGE4MGM1NTI1NTAocGxhY2Vob2xkZXJWYWx1ZSwgY2FsZW5kYXIpO1xuICAgIGxldCBkYXRlID0gKDAsICQ3VXpvTSR0b0NhbGVuZGFyKSgoMCwgJDdVem9NJG5vdykodGltZVpvbmUpLnNldCh7XG4gICAgICAgIGhvdXI6IDAsXG4gICAgICAgIG1pbnV0ZTogMCxcbiAgICAgICAgc2Vjb25kOiAwLFxuICAgICAgICBtaWxsaXNlY29uZDogMFxuICAgIH0pLCBjYWxlbmRhcik7XG4gICAgaWYgKGdyYW51bGFyaXR5ID09PSBcInllYXJcIiB8fCBncmFudWxhcml0eSA9PT0gXCJtb250aFwiIHx8IGdyYW51bGFyaXR5ID09PSBcImRheVwiKSByZXR1cm4gKDAsICQ3VXpvTSR0b0NhbGVuZGFyRGF0ZSkoZGF0ZSk7XG4gICAgaWYgKCF0aW1lWm9uZSkgcmV0dXJuICgwLCAkN1V6b00kdG9DYWxlbmRhckRhdGVUaW1lKShkYXRlKTtcbiAgICByZXR1cm4gZGF0ZTtcbn1cbmZ1bmN0aW9uICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCQyNDQwZGEzNTNjZWRhZDQzKHYsIGdyYW51bGFyaXR5KSB7XG4gICAgLy8gQ29tcHV0ZSBkZWZhdWx0IGdyYW51bGFyaXR5IGFuZCB0aW1lIHpvbmUgZnJvbSB0aGUgdmFsdWUuIElmIHRoZSB2YWx1ZSBiZWNvbWVzIG51bGwsIGtlZXAgdGhlIGxhc3QgdmFsdWVzLlxuICAgIGxldCBkZWZhdWx0VGltZVpvbmUgPSB2ICYmIFwidGltZVpvbmVcIiBpbiB2ID8gdi50aW1lWm9uZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgZGVmYXVsdEdyYW51bGFyaXR5ID0gdiAmJiBcIm1pbnV0ZVwiIGluIHYgPyBcIm1pbnV0ZVwiIDogXCJkYXlcIjtcbiAgICAvLyBwcm9wcy5ncmFudWxhcml0eSBtdXN0IGFjdHVhbGx5IGV4aXN0IGluIHRoZSB2YWx1ZSBpZiBvbmUgaXMgcHJvdmlkZWQuXG4gICAgaWYgKHYgJiYgZ3JhbnVsYXJpdHkgJiYgIShncmFudWxhcml0eSBpbiB2KSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncmFudWxhcml0eSBcIiArIGdyYW51bGFyaXR5ICsgXCIgZm9yIHZhbHVlIFwiICsgdi50b1N0cmluZygpKTtcbiAgICBsZXQgW2xhc3RWYWx1ZSwgc2V0TGFzdFZhbHVlXSA9ICgwLCAkN1V6b00kdXNlU3RhdGUpKFtcbiAgICAgICAgZGVmYXVsdEdyYW51bGFyaXR5LFxuICAgICAgICBkZWZhdWx0VGltZVpvbmVcbiAgICBdKTtcbiAgICAvLyBJZiB0aGUgZ3JhbnVsYXJpdHkgb3IgdGltZSB6b25lIGNoYW5nZWQsIHVwZGF0ZSB0aGUgbGFzdCB2YWx1ZS5cbiAgICBpZiAodiAmJiAobGFzdFZhbHVlWzBdICE9PSBkZWZhdWx0R3JhbnVsYXJpdHkgfHwgbGFzdFZhbHVlWzFdICE9PSBkZWZhdWx0VGltZVpvbmUpKSBzZXRMYXN0VmFsdWUoW1xuICAgICAgICBkZWZhdWx0R3JhbnVsYXJpdHksXG4gICAgICAgIGRlZmF1bHRUaW1lWm9uZVxuICAgIF0pO1xuICAgIGlmICghZ3JhbnVsYXJpdHkpIGdyYW51bGFyaXR5ID0gdiA/IGRlZmF1bHRHcmFudWxhcml0eSA6IGxhc3RWYWx1ZVswXTtcbiAgICBsZXQgdGltZVpvbmUgPSB2ID8gZGVmYXVsdFRpbWVab25lIDogbGFzdFZhbHVlWzFdO1xuICAgIHJldHVybiBbXG4gICAgICAgIGdyYW51bGFyaXR5LFxuICAgICAgICB0aW1lWm9uZVxuICAgIF07XG59XG5cblxuXG5cblxuZnVuY3Rpb24gJGFiNWJmM2Y2MTgwOTAzODkkZXhwb3J0JDg3MTk0YmIzNzhjYzNhYzIocHJvcHMpIHtcbiAgICB2YXIgX3Byb3BzX2lzRGF0ZVVuYXZhaWxhYmxlO1xuICAgIGxldCBvdmVybGF5U3RhdGUgPSAoMCwgJDdVem9NJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUpKHByb3BzKTtcbiAgICBsZXQgW3ZhbHVlLCBzZXRWYWx1ZV0gPSAoMCwgJDdVem9NJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMudmFsdWUsIHByb3BzLmRlZmF1bHRWYWx1ZSB8fCBudWxsLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgbGV0IHYgPSB2YWx1ZSB8fCBwcm9wcy5wbGFjZWhvbGRlclZhbHVlO1xuICAgIGxldCBbZ3JhbnVsYXJpdHksIGRlZmF1bHRUaW1lWm9uZV0gPSAoMCwgJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JDI0NDBkYTM1M2NlZGFkNDMpKHYsIHByb3BzLmdyYW51bGFyaXR5KTtcbiAgICBsZXQgZGF0ZVZhbHVlID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLnRvRGF0ZShkZWZhdWx0VGltZVpvbmUgIT09IG51bGwgJiYgZGVmYXVsdFRpbWVab25lICE9PSB2b2lkIDAgPyBkZWZhdWx0VGltZVpvbmUgOiBcIlVUQ1wiKSA6IG51bGw7XG4gICAgbGV0IGhhc1RpbWUgPSBncmFudWxhcml0eSA9PT0gXCJob3VyXCIgfHwgZ3JhbnVsYXJpdHkgPT09IFwibWludXRlXCIgfHwgZ3JhbnVsYXJpdHkgPT09IFwic2Vjb25kXCI7XG4gICAgdmFyIF9wcm9wc19zaG91bGRDbG9zZU9uU2VsZWN0O1xuICAgIGxldCBzaG91bGRDbG9zZU9uU2VsZWN0ID0gKF9wcm9wc19zaG91bGRDbG9zZU9uU2VsZWN0ID0gcHJvcHMuc2hvdWxkQ2xvc2VPblNlbGVjdCkgIT09IG51bGwgJiYgX3Byb3BzX3Nob3VsZENsb3NlT25TZWxlY3QgIT09IHZvaWQgMCA/IF9wcm9wc19zaG91bGRDbG9zZU9uU2VsZWN0IDogdHJ1ZTtcbiAgICBsZXQgW3NlbGVjdGVkRGF0ZSwgc2V0U2VsZWN0ZWREYXRlXSA9ICgwLCAkN1V6b00kdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCBbc2VsZWN0ZWRUaW1lLCBzZXRTZWxlY3RlZFRpbWVdID0gKDAsICQ3VXpvTSR1c2VTdGF0ZSkobnVsbCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHNlbGVjdGVkRGF0ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoXCJob3VyXCIgaW4gdmFsdWUpIHNlbGVjdGVkVGltZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvLyBwcm9wcy5ncmFudWxhcml0eSBtdXN0IGFjdHVhbGx5IGV4aXN0IGluIHRoZSB2YWx1ZSBpZiBvbmUgaXMgcHJvdmlkZWQuXG4gICAgaWYgKHYgJiYgIShncmFudWxhcml0eSBpbiB2KSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncmFudWxhcml0eSBcIiArIGdyYW51bGFyaXR5ICsgXCIgZm9yIHZhbHVlIFwiICsgdi50b1N0cmluZygpKTtcbiAgICBsZXQgY29tbWl0VmFsdWUgPSAoZGF0ZSwgdGltZSk9PntcbiAgICAgICAgc2V0VmFsdWUoXCJ0aW1lWm9uZVwiIGluIHRpbWUgPyB0aW1lLnNldCgoMCwgJDdVem9NJHRvQ2FsZW5kYXJEYXRlKShkYXRlKSkgOiAoMCwgJDdVem9NJHRvQ2FsZW5kYXJEYXRlVGltZSkoZGF0ZSwgdGltZSkpO1xuICAgICAgICBzZXRTZWxlY3RlZERhdGUobnVsbCk7XG4gICAgICAgIHNldFNlbGVjdGVkVGltZShudWxsKTtcbiAgICB9O1xuICAgIC8vIEludGVyY2VwdCBzZXRWYWx1ZSB0byBtYWtlIHN1cmUgdGhlIFRpbWUgc2VjdGlvbiBpcyBub3QgY2hhbmdlZCBieSBkYXRlIHNlbGVjdGlvbiBpbiBDYWxlbmRhclxuICAgIGxldCBzZWxlY3REYXRlID0gKG5ld1ZhbHVlKT0+e1xuICAgICAgICBsZXQgc2hvdWxkQ2xvc2UgPSB0eXBlb2Ygc2hvdWxkQ2xvc2VPblNlbGVjdCA9PT0gXCJmdW5jdGlvblwiID8gc2hvdWxkQ2xvc2VPblNlbGVjdCgpIDogc2hvdWxkQ2xvc2VPblNlbGVjdDtcbiAgICAgICAgaWYgKGhhc1RpbWUpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFRpbWUgfHwgc2hvdWxkQ2xvc2UpIGNvbW1pdFZhbHVlKG5ld1ZhbHVlLCBzZWxlY3RlZFRpbWUgfHwgKDAsICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCRjNTIyMWE3OGVmNzNjNWU5KShwcm9wcy5wbGFjZWhvbGRlclZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlIHNldFNlbGVjdGVkRGF0ZShuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBzZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgIGlmIChzaG91bGRDbG9zZSkgb3ZlcmxheVN0YXRlLnNldE9wZW4oZmFsc2UpO1xuICAgIH07XG4gICAgbGV0IHNlbGVjdFRpbWUgPSAobmV3VmFsdWUpPT57XG4gICAgICAgIGlmIChzZWxlY3RlZERhdGUgJiYgbmV3VmFsdWUpIGNvbW1pdFZhbHVlKHNlbGVjdGVkRGF0ZSwgbmV3VmFsdWUpO1xuICAgICAgICBlbHNlIHNldFNlbGVjdGVkVGltZShuZXdWYWx1ZSk7XG4gICAgfTtcbiAgICBsZXQgaXNWYWx1ZUludmFsaWQgPSBwcm9wcy5pc0ludmFsaWQgfHwgcHJvcHMudmFsaWRhdGlvblN0YXRlID09PSBcImludmFsaWRcIiB8fCAoMCwgJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JGVhYzUwOTIwY2YyZmQ1OWEpKHZhbHVlLCBwcm9wcy5taW5WYWx1ZSwgcHJvcHMubWF4VmFsdWUpIHx8IHZhbHVlICYmICgoX3Byb3BzX2lzRGF0ZVVuYXZhaWxhYmxlID0gcHJvcHMuaXNEYXRlVW5hdmFpbGFibGUpID09PSBudWxsIHx8IF9wcm9wc19pc0RhdGVVbmF2YWlsYWJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Byb3BzX2lzRGF0ZVVuYXZhaWxhYmxlLmNhbGwocHJvcHMsIHZhbHVlKSk7XG4gICAgbGV0IHZhbGlkYXRpb25TdGF0ZSA9IHByb3BzLnZhbGlkYXRpb25TdGF0ZSB8fCAoaXNWYWx1ZUludmFsaWQgPyBcImludmFsaWRcIiA6IG51bGwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgc2V0VmFsdWU6IHNldFZhbHVlLFxuICAgICAgICBkYXRlVmFsdWU6IHNlbGVjdGVkRGF0ZSxcbiAgICAgICAgdGltZVZhbHVlOiBzZWxlY3RlZFRpbWUsXG4gICAgICAgIHNldERhdGVWYWx1ZTogc2VsZWN0RGF0ZSxcbiAgICAgICAgc2V0VGltZVZhbHVlOiBzZWxlY3RUaW1lLFxuICAgICAgICBncmFudWxhcml0eTogZ3JhbnVsYXJpdHksXG4gICAgICAgIGhhc1RpbWU6IGhhc1RpbWUsXG4gICAgICAgIC4uLm92ZXJsYXlTdGF0ZSxcbiAgICAgICAgc2V0T3BlbiAoaXNPcGVuKSB7XG4gICAgICAgICAgICAvLyBDb21taXQgdGhlIHNlbGVjdGVkIGRhdGUgd2hlbiB0aGUgY2FsZW5kYXIgaXMgY2xvc2VkLiBVc2UgYSBwbGFjZWhvbGRlciB0aW1lIGlmIG9uZSB3YXNuJ3Qgc2V0LlxuICAgICAgICAgICAgLy8gSWYgb25seSB0aGUgdGltZSB3YXMgc2V0IGFuZCBub3QgdGhlIGRhdGUsIGRvbid0IGNvbW1pdC4gVGhlIHN0YXRlIHdpbGwgYmUgcHJlc2VydmVkIHVudGlsXG4gICAgICAgICAgICAvLyB0aGUgdXNlciBvcGVucyB0aGUgcG9wb3ZlciBhZ2Fpbi5cbiAgICAgICAgICAgIGlmICghaXNPcGVuICYmICF2YWx1ZSAmJiBzZWxlY3RlZERhdGUgJiYgaGFzVGltZSkgY29tbWl0VmFsdWUoc2VsZWN0ZWREYXRlLCBzZWxlY3RlZFRpbWUgfHwgKDAsICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCRjNTIyMWE3OGVmNzNjNWU5KShwcm9wcy5wbGFjZWhvbGRlclZhbHVlKSk7XG4gICAgICAgICAgICBvdmVybGF5U3RhdGUuc2V0T3Blbihpc09wZW4pO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0aW9uU3RhdGU6IHZhbGlkYXRpb25TdGF0ZSxcbiAgICAgICAgaXNJbnZhbGlkOiBpc1ZhbHVlSW52YWxpZCxcbiAgICAgICAgZm9ybWF0VmFsdWUgKGxvY2FsZSwgZmllbGRPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGVWYWx1ZSkgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICBsZXQgZm9ybWF0T3B0aW9ucyA9ICgwLCAkMzVhMjJmMTRhMWYwNGIxMSRleHBvcnQkN2UzMTllYTQwN2U2M2JjMCkoZmllbGRPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgZ3JhbnVsYXJpdHk6IGdyYW51bGFyaXR5LFxuICAgICAgICAgICAgICAgIHRpbWVab25lOiBkZWZhdWx0VGltZVpvbmUsXG4gICAgICAgICAgICAgICAgaGlkZVRpbWVab25lOiBwcm9wcy5oaWRlVGltZVpvbmUsXG4gICAgICAgICAgICAgICAgaG91ckN5Y2xlOiBwcm9wcy5ob3VyQ3ljbGUsXG4gICAgICAgICAgICAgICAgc2hvd0VyYTogdmFsdWUuY2FsZW5kYXIuaWRlbnRpZmllciA9PT0gXCJncmVnb3J5XCIgJiYgdmFsdWUuZXJhID09PSBcIkJDXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGZvcm1hdHRlciA9IG5ldyAoMCwgJDdVem9NJERhdGVGb3JtYXR0ZXIpKGxvY2FsZSwgZm9ybWF0T3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChkYXRlVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8vIFRoZXNlIHBsYWNlaG9sZGVycyBhcmUgYmFzZWQgb24gdGhlIHN0cmluZ3MgdXNlZCBieSB0aGUgPGlucHV0IHR5cGU9XCJkYXRlXCI+XG4vLyBpbXBsZW1lbnRhdGlvbnMgaW4gQ2hyb21lIGFuZCBGaXJlZm94LiBBZGRpdGlvbmFsIGxhbmd1YWdlcyBhcmUgc3VwcG9ydGVkXG4vLyBoZXJlIHRoYW4gUmVhY3QgU3BlY3RydW0ncyB0eXBpY2FsIHRyYW5zbGF0aW9ucy5cbmNvbnN0ICQzZTNlZDU1YWIyOTY2NzE0JHZhciRwbGFjZWhvbGRlcnMgPSBuZXcgKDAsICQ3VXpvTSRMb2NhbGl6ZWRTdHJpbmdEaWN0aW9uYXJ5KSh7XG4gICAgYWNoOiB7XG4gICAgICAgIHllYXI6IFwibXdha2FcIixcbiAgICAgICAgbW9udGg6IFwiZHdlXCIsXG4gICAgICAgIGRheTogXCJuaW5vXCJcbiAgICB9LFxuICAgIGFmOiB7XG4gICAgICAgIHllYXI6IFwiampqalwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgYW06IHtcbiAgICAgICAgeWVhcjogXCLhi5Phi5Phi5Phi5NcIixcbiAgICAgICAgbW9udGg6IFwi4Yia4YicXCIsXG4gICAgICAgIGRheTogXCLhiYDhiYBcIlxuICAgIH0sXG4gICAgYW46IHtcbiAgICAgICAgeWVhcjogXCJhYWFhXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJkZFwiXG4gICAgfSxcbiAgICBhcjoge1xuICAgICAgICB5ZWFyOiBcItiz2YbYqVwiLFxuICAgICAgICBtb250aDogXCLYtNmH2LFcIixcbiAgICAgICAgZGF5OiBcItmK2YjZhVwiXG4gICAgfSxcbiAgICBhc3Q6IHtcbiAgICAgICAgeWVhcjogXCJhYWFhXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJkZFwiXG4gICAgfSxcbiAgICBhejoge1xuICAgICAgICB5ZWFyOiBcImlpaWlcIixcbiAgICAgICAgbW9udGg6IFwiYWFcIixcbiAgICAgICAgZGF5OiBcImdnXCJcbiAgICB9LFxuICAgIGJlOiB7XG4gICAgICAgIHllYXI6IFwi0LPQs9Cz0LNcIixcbiAgICAgICAgbW9udGg6IFwi0LzQvFwiLFxuICAgICAgICBkYXk6IFwi0LTQtFwiXG4gICAgfSxcbiAgICBiZzoge1xuICAgICAgICB5ZWFyOiBcItCz0LPQs9CzXCIsXG4gICAgICAgIG1vbnRoOiBcItC80LxcIixcbiAgICAgICAgZGF5OiBcItC00LRcIlxuICAgIH0sXG4gICAgYm46IHtcbiAgICAgICAgeWVhcjogXCJ5eXl5XCIsXG4gICAgICAgIG1vbnRoOiBcIuCmruCmv+CmruCmv1wiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgYnI6IHtcbiAgICAgICAgeWVhcjogXCJiYmJiXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJkZFwiXG4gICAgfSxcbiAgICBiczoge1xuICAgICAgICB5ZWFyOiBcImdnZ2dcIixcbiAgICAgICAgbW9udGg6IFwibW1cIixcbiAgICAgICAgZGF5OiBcImRkXCJcbiAgICB9LFxuICAgIGNhOiB7XG4gICAgICAgIHllYXI6IFwiYWFhYVwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgY2FrOiB7XG4gICAgICAgIHllYXI6IFwiampqalwiLFxuICAgICAgICBtb250aDogXCJpaVwiLFxuICAgICAgICBkYXk6IFwicSdxJ1wiXG4gICAgfSxcbiAgICBja2I6IHtcbiAgICAgICAgeWVhcjogXCLYs9in2rVcIixcbiAgICAgICAgbW9udGg6IFwi2YXYp9mG2q9cIixcbiAgICAgICAgZGF5OiBcItqV24bamFwiXG4gICAgfSxcbiAgICBjczoge1xuICAgICAgICB5ZWFyOiBcInJycnJcIixcbiAgICAgICAgbW9udGg6IFwibW1cIixcbiAgICAgICAgZGF5OiBcImRkXCJcbiAgICB9LFxuICAgIGN5OiB7XG4gICAgICAgIHllYXI6IFwiYmJiYlwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgZGE6IHtcbiAgICAgICAgeWVhcjogXCJcXHhlNVxceGU1XFx4ZTVcXHhlNVwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgZGU6IHtcbiAgICAgICAgeWVhcjogXCJqampqXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJ0dFwiXG4gICAgfSxcbiAgICBkc2I6IHtcbiAgICAgICAgeWVhcjogXCJsbGxsXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCLFusW6XCJcbiAgICB9LFxuICAgIGVsOiB7XG4gICAgICAgIHllYXI6IFwizrXOtc61zrVcIixcbiAgICAgICAgbW9udGg6IFwizrzOvFwiLFxuICAgICAgICBkYXk6IFwizrfOt1wiXG4gICAgfSxcbiAgICBlbjoge1xuICAgICAgICB5ZWFyOiBcInl5eXlcIixcbiAgICAgICAgbW9udGg6IFwibW1cIixcbiAgICAgICAgZGF5OiBcImRkXCJcbiAgICB9LFxuICAgIGVvOiB7XG4gICAgICAgIHllYXI6IFwiampqalwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwidHRcIlxuICAgIH0sXG4gICAgZXM6IHtcbiAgICAgICAgeWVhcjogXCJhYWFhXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJkZFwiXG4gICAgfSxcbiAgICBldDoge1xuICAgICAgICB5ZWFyOiBcImFhYWFcIixcbiAgICAgICAgbW9udGg6IFwia2tcIixcbiAgICAgICAgZGF5OiBcInBwXCJcbiAgICB9LFxuICAgIGV1OiB7XG4gICAgICAgIHllYXI6IFwidXV1dVwiLFxuICAgICAgICBtb250aDogXCJoaFwiLFxuICAgICAgICBkYXk6IFwiZWVcIlxuICAgIH0sXG4gICAgZmE6IHtcbiAgICAgICAgeWVhcjogXCLYs9in2YRcIixcbiAgICAgICAgbW9udGg6IFwi2YXYp9mHXCIsXG4gICAgICAgIGRheTogXCLYsdmI2LJcIlxuICAgIH0sXG4gICAgZmY6IHtcbiAgICAgICAgeWVhcjogXCJoaGhoXCIsXG4gICAgICAgIG1vbnRoOiBcImxsXCIsXG4gICAgICAgIGRheTogXCJcXHhmMVxceGYxXCJcbiAgICB9LFxuICAgIGZpOiB7XG4gICAgICAgIHllYXI6IFwidnZ2dlwiLFxuICAgICAgICBtb250aDogXCJra1wiLFxuICAgICAgICBkYXk6IFwicHBcIlxuICAgIH0sXG4gICAgZnI6IHtcbiAgICAgICAgeWVhcjogXCJhYWFhXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJqalwiXG4gICAgfSxcbiAgICBmeToge1xuICAgICAgICB5ZWFyOiBcImpqampcIixcbiAgICAgICAgbW9udGg6IFwibW1cIixcbiAgICAgICAgZGF5OiBcImRkXCJcbiAgICB9LFxuICAgIGdhOiB7XG4gICAgICAgIHllYXI6IFwiYmJiYlwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwibGxcIlxuICAgIH0sXG4gICAgZ2Q6IHtcbiAgICAgICAgeWVhcjogXCJiYmJiXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJsbFwiXG4gICAgfSxcbiAgICBnbDoge1xuICAgICAgICB5ZWFyOiBcImFhYWFcIixcbiAgICAgICAgbW9udGg6IFwibW1cIixcbiAgICAgICAgZGF5OiBcImRkXCJcbiAgICB9LFxuICAgIGhlOiB7XG4gICAgICAgIHllYXI6IFwi16nXoNeUXCIsXG4gICAgICAgIG1vbnRoOiBcIteX15XXk9epXCIsXG4gICAgICAgIGRheTogXCLXmdeV151cIlxuICAgIH0sXG4gICAgaHI6IHtcbiAgICAgICAgeWVhcjogXCJnZ2dnXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJkZFwiXG4gICAgfSxcbiAgICBoc2I6IHtcbiAgICAgICAgeWVhcjogXCJsbGxsXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJkZFwiXG4gICAgfSxcbiAgICBodToge1xuICAgICAgICB5ZWFyOiBcIlxceGU5XFx4ZTlcXHhlOVxceGU5XCIsXG4gICAgICAgIG1vbnRoOiBcImhoXCIsXG4gICAgICAgIGRheTogXCJublwiXG4gICAgfSxcbiAgICBpYToge1xuICAgICAgICB5ZWFyOiBcImFhYWFcIixcbiAgICAgICAgbW9udGg6IFwibW1cIixcbiAgICAgICAgZGF5OiBcImRkXCJcbiAgICB9LFxuICAgIGlkOiB7XG4gICAgICAgIHllYXI6IFwidHR0dFwiLFxuICAgICAgICBtb250aDogXCJiYlwiLFxuICAgICAgICBkYXk6IFwiaGhcIlxuICAgIH0sXG4gICAgaXQ6IHtcbiAgICAgICAgeWVhcjogXCJhYWFhXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJnZ1wiXG4gICAgfSxcbiAgICBqYToge1xuICAgICAgICB5ZWFyOiBcIiDlubQgXCIsXG4gICAgICAgIG1vbnRoOiBcIuaciFwiLFxuICAgICAgICBkYXk6IFwi5pelXCJcbiAgICB9LFxuICAgIGthOiB7XG4gICAgICAgIHllYXI6IFwi4YOs4YOs4YOs4YOsXCIsXG4gICAgICAgIG1vbnRoOiBcIuGDl+GDl1wiLFxuICAgICAgICBkYXk6IFwi4YOg4YOgXCJcbiAgICB9LFxuICAgIGtrOiB7XG4gICAgICAgIHllYXI6IFwi0LbQttC20LZcIixcbiAgICAgICAgbW9udGg6IFwi0LDQsFwiLFxuICAgICAgICBkYXk6IFwi0LrQulwiXG4gICAgfSxcbiAgICBrbjoge1xuICAgICAgICB5ZWFyOiBcIuCyteCyteCyteCytVwiLFxuICAgICAgICBtb250aDogXCLgsq7gsr/gsq7gs4BcIixcbiAgICAgICAgZGF5OiBcIuCypuCyv+CypuCyv1wiXG4gICAgfSxcbiAgICBrbzoge1xuICAgICAgICB5ZWFyOiBcIuyXsOuPhFwiLFxuICAgICAgICBtb250aDogXCLsm5RcIixcbiAgICAgICAgZGF5OiBcIuydvFwiXG4gICAgfSxcbiAgICBsYjoge1xuICAgICAgICB5ZWFyOiBcImpqampcIixcbiAgICAgICAgbW9udGg6IFwibW1cIixcbiAgICAgICAgZGF5OiBcImRkXCJcbiAgICB9LFxuICAgIGxvOiB7XG4gICAgICAgIHllYXI6IFwi4Lqb4Lqb4Lqb4LqbXCIsXG4gICAgICAgIG1vbnRoOiBcIuC6lOC6lFwiLFxuICAgICAgICBkYXk6IFwi4Lqn4LqnXCJcbiAgICB9LFxuICAgIGx0OiB7XG4gICAgICAgIHllYXI6IFwibW1tbVwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgbHY6IHtcbiAgICAgICAgeWVhcjogXCJnZ2dnXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJkZFwiXG4gICAgfSxcbiAgICBtZWg6IHtcbiAgICAgICAgeWVhcjogXCJhYWFhXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJkZFwiXG4gICAgfSxcbiAgICBtbDoge1xuICAgICAgICB5ZWFyOiBcIuC0teC1vOC0t+C0glwiLFxuICAgICAgICBtb250aDogXCLgtK7gtL7gtLjgtIJcIixcbiAgICAgICAgZGF5OiBcIuC0pOC1gOC0r+C0pOC0v1wiXG4gICAgfSxcbiAgICBtczoge1xuICAgICAgICB5ZWFyOiBcInR0dHRcIixcbiAgICAgICAgbW9udGg6IFwibW1cIixcbiAgICAgICAgZGF5OiBcImhoXCJcbiAgICB9LFxuICAgIG5sOiB7XG4gICAgICAgIHllYXI6IFwiampqalwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgbm46IHtcbiAgICAgICAgeWVhcjogXCJcXHhlNVxceGU1XFx4ZTVcXHhlNVwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgbm86IHtcbiAgICAgICAgeWVhcjogXCJcXHhlNVxceGU1XFx4ZTVcXHhlNVwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgb2M6IHtcbiAgICAgICAgeWVhcjogXCJhYWFhXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJqalwiXG4gICAgfSxcbiAgICBwbDoge1xuICAgICAgICB5ZWFyOiBcInJycnJcIixcbiAgICAgICAgbW9udGg6IFwibW1cIixcbiAgICAgICAgZGF5OiBcImRkXCJcbiAgICB9LFxuICAgIHB0OiB7XG4gICAgICAgIHllYXI6IFwiYWFhYVwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgcm06IHtcbiAgICAgICAgeWVhcjogXCJvb29vXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJkZFwiXG4gICAgfSxcbiAgICBybzoge1xuICAgICAgICB5ZWFyOiBcImFhYWFcIixcbiAgICAgICAgbW9udGg6IFwibGxcIixcbiAgICAgICAgZGF5OiBcInp6XCJcbiAgICB9LFxuICAgIHJ1OiB7XG4gICAgICAgIHllYXI6IFwi0LPQs9Cz0LNcIixcbiAgICAgICAgbW9udGg6IFwi0LzQvFwiLFxuICAgICAgICBkYXk6IFwi0LTQtFwiXG4gICAgfSxcbiAgICBzYzoge1xuICAgICAgICB5ZWFyOiBcImFhYWFcIixcbiAgICAgICAgbW9udGg6IFwibW1cIixcbiAgICAgICAgZGF5OiBcImRkXCJcbiAgICB9LFxuICAgIHNjbjoge1xuICAgICAgICB5ZWFyOiBcImFhYWFcIixcbiAgICAgICAgbW9udGg6IFwibW1cIixcbiAgICAgICAgZGF5OiBcImpqXCJcbiAgICB9LFxuICAgIHNrOiB7XG4gICAgICAgIHllYXI6IFwicnJyclwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgc2w6IHtcbiAgICAgICAgeWVhcjogXCJsbGxsXCIsXG4gICAgICAgIG1vbnRoOiBcIm1tXCIsXG4gICAgICAgIGRheTogXCJkZFwiXG4gICAgfSxcbiAgICBzcjoge1xuICAgICAgICB5ZWFyOiBcItCz0LPQs9CzXCIsXG4gICAgICAgIG1vbnRoOiBcItC80LxcIixcbiAgICAgICAgZGF5OiBcItC00LRcIlxuICAgIH0sXG4gICAgc3Y6IHtcbiAgICAgICAgeWVhcjogXCJcXHhlNVxceGU1XFx4ZTVcXHhlNVwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgc3psOiB7XG4gICAgICAgIHllYXI6IFwicnJyclwiLFxuICAgICAgICBtb250aDogXCJtbVwiLFxuICAgICAgICBkYXk6IFwiZGRcIlxuICAgIH0sXG4gICAgdGc6IHtcbiAgICAgICAgeWVhcjogXCLRgdGB0YHRgVwiLFxuICAgICAgICBtb250aDogXCLQvNC8XCIsXG4gICAgICAgIGRheTogXCLRgNGAXCJcbiAgICB9LFxuICAgIHRoOiB7XG4gICAgICAgIHllYXI6IFwi4Lib4Lib4Lib4LibXCIsXG4gICAgICAgIG1vbnRoOiBcIuC4lOC4lFwiLFxuICAgICAgICBkYXk6IFwi4Lin4LinXCJcbiAgICB9LFxuICAgIHRyOiB7XG4gICAgICAgIHllYXI6IFwieXl5eVwiLFxuICAgICAgICBtb250aDogXCJhYVwiLFxuICAgICAgICBkYXk6IFwiZ2dcIlxuICAgIH0sXG4gICAgdWs6IHtcbiAgICAgICAgeWVhcjogXCLRgNGA0YDRgFwiLFxuICAgICAgICBtb250aDogXCLQvNC8XCIsXG4gICAgICAgIGRheTogXCLQtNC0XCJcbiAgICB9LFxuICAgIFwiemgtQ05cIjoge1xuICAgICAgICB5ZWFyOiBcIuW5tFwiLFxuICAgICAgICBtb250aDogXCLmnIhcIixcbiAgICAgICAgZGF5OiBcIuaXpVwiXG4gICAgfSxcbiAgICBcInpoLVRXXCI6IHtcbiAgICAgICAgeWVhcjogXCLlubRcIixcbiAgICAgICAgbW9udGg6IFwi5pyIXCIsXG4gICAgICAgIGRheTogXCLml6VcIlxuICAgIH1cbn0sIFwiZW5cIik7XG5mdW5jdGlvbiAkM2UzZWQ1NWFiMjk2NjcxNCRleHBvcnQkZDNmNWM1ZTBhNTAyM2ZhMChmaWVsZCwgdmFsdWUsIGxvY2FsZSkge1xuICAgIC8vIFVzZSB0aGUgYWN0dWFsIHBsYWNlaG9sZGVyIHZhbHVlIGZvciB0aGUgZXJhIGFuZCBkYXkgcGVyaW9kIGZpZWxkcy5cbiAgICBpZiAoZmllbGQgPT09IFwiZXJhXCIgfHwgZmllbGQgPT09IFwiZGF5UGVyaW9kXCIpIHJldHVybiB2YWx1ZTtcbiAgICBpZiAoZmllbGQgPT09IFwieWVhclwiIHx8IGZpZWxkID09PSBcIm1vbnRoXCIgfHwgZmllbGQgPT09IFwiZGF5XCIpIHJldHVybiAkM2UzZWQ1NWFiMjk2NjcxNCR2YXIkcGxhY2Vob2xkZXJzLmdldFN0cmluZ0ZvckxvY2FsZShmaWVsZCwgbG9jYWxlKTtcbiAgICAvLyBGb3IgdGltZSBmaWVsZHMgKGUuZy4gaG91ciwgbWludXRlLCBldGMuKSwgdXNlIHR3byBkYXNoZXMgYXMgdGhlIHBsYWNlaG9sZGVyLlxuICAgIHJldHVybiBcIuKAk+KAk1wiO1xufVxuXG5cblxuXG5jb25zdCAkM2MwZmM3NjAzOWYxYzUxNiR2YXIkRURJVEFCTEVfU0VHTUVOVFMgPSB7XG4gICAgeWVhcjogdHJ1ZSxcbiAgICBtb250aDogdHJ1ZSxcbiAgICBkYXk6IHRydWUsXG4gICAgaG91cjogdHJ1ZSxcbiAgICBtaW51dGU6IHRydWUsXG4gICAgc2Vjb25kOiB0cnVlLFxuICAgIGRheVBlcmlvZDogdHJ1ZSxcbiAgICBlcmE6IHRydWVcbn07XG5jb25zdCAkM2MwZmM3NjAzOWYxYzUxNiR2YXIkUEFHRV9TVEVQID0ge1xuICAgIHllYXI6IDUsXG4gICAgbW9udGg6IDIsXG4gICAgZGF5OiA3LFxuICAgIGhvdXI6IDIsXG4gICAgbWludXRlOiAxNSxcbiAgICBzZWNvbmQ6IDE1XG59O1xuLy8gTm9kZSBzZWVtcyB0byBjb252ZXJ0IGV2ZXJ5dGhpbmcgdG8gbG93ZXJjYXNlLi4uXG5jb25zdCAkM2MwZmM3NjAzOWYxYzUxNiR2YXIkVFlQRV9NQVBQSU5HID0ge1xuICAgIGRheXBlcmlvZDogXCJkYXlQZXJpb2RcIlxufTtcbmZ1bmN0aW9uICQzYzBmYzc2MDM5ZjFjNTE2JGV4cG9ydCQ2MGU4NDc3OGVkZmY2ZDI2KHByb3BzKSB7XG4gICAgbGV0IHsgbG9jYWxlOiBsb2NhbGUsIGNyZWF0ZUNhbGVuZGFyOiBjcmVhdGVDYWxlbmRhciwgaGlkZVRpbWVab25lOiBoaWRlVGltZVpvbmUsIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsIGlzUmVhZE9ubHk6IGlzUmVhZE9ubHksIGlzUmVxdWlyZWQ6IGlzUmVxdWlyZWQgfSA9IHByb3BzO1xuICAgIGxldCB2ID0gcHJvcHMudmFsdWUgfHwgcHJvcHMuZGVmYXVsdFZhbHVlIHx8IHByb3BzLnBsYWNlaG9sZGVyVmFsdWU7XG4gICAgbGV0IFtncmFudWxhcml0eSwgZGVmYXVsdFRpbWVab25lXSA9ICgwLCAkMzVhMjJmMTRhMWYwNGIxMSRleHBvcnQkMjQ0MGRhMzUzY2VkYWQ0MykodiwgcHJvcHMuZ3JhbnVsYXJpdHkpO1xuICAgIGxldCB0aW1lWm9uZSA9IGRlZmF1bHRUaW1lWm9uZSB8fCBcIlVUQ1wiO1xuICAgIC8vIHByb3BzLmdyYW51bGFyaXR5IG11c3QgYWN0dWFsbHkgZXhpc3QgaW4gdGhlIHZhbHVlIGlmIG9uZSBpcyBwcm92aWRlZC5cbiAgICBpZiAodiAmJiAhKGdyYW51bGFyaXR5IGluIHYpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyYW51bGFyaXR5IFwiICsgZ3JhbnVsYXJpdHkgKyBcIiBmb3IgdmFsdWUgXCIgKyB2LnRvU3RyaW5nKCkpO1xuICAgIGxldCBkZWZhdWx0Rm9ybWF0dGVyID0gKDAsICQ3VXpvTSR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkN1V6b00kRGF0ZUZvcm1hdHRlcikobG9jYWxlKSwgW1xuICAgICAgICBsb2NhbGVcbiAgICBdKTtcbiAgICBsZXQgY2FsZW5kYXIgPSAoMCwgJDdVem9NJHVzZU1lbW8pKCgpPT5jcmVhdGVDYWxlbmRhcihkZWZhdWx0Rm9ybWF0dGVyLnJlc29sdmVkT3B0aW9ucygpLmNhbGVuZGFyKSwgW1xuICAgICAgICBjcmVhdGVDYWxlbmRhcixcbiAgICAgICAgZGVmYXVsdEZvcm1hdHRlclxuICAgIF0pO1xuICAgIGxldCBbdmFsdWUsIHNldERhdGVdID0gKDAsICQ3VXpvTSR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHByb3BzLm9uQ2hhbmdlKTtcbiAgICBsZXQgY2FsZW5kYXJWYWx1ZSA9ICgwLCAkN1V6b00kdXNlTWVtbykoKCk9PigwLCAkMzVhMjJmMTRhMWYwNGIxMSRleHBvcnQkNjFhNDkwYTgwYzU1MjU1MCkodmFsdWUsIGNhbGVuZGFyKSwgW1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgY2FsZW5kYXJcbiAgICBdKTtcbiAgICAvLyBXZSBrZWVwIHRyYWNrIG9mIHRoZSBwbGFjZWhvbGRlciBkYXRlIHNlcGFyYXRlbHkgaW4gc3RhdGUgc28gdGhhdCBvbkNoYW5nZSBpcyBub3QgY2FsbGVkXG4gICAgLy8gdW50aWwgYWxsIHNlZ21lbnRzIGFyZSBzZXQuIElmIHRoZSB2YWx1ZSA9PT0gbnVsbCAobm90IHVuZGVmaW5lZCksIHRoZW4gYXNzdW1lIHRoZSBjb21wb25lbnRcbiAgICAvLyBpcyBjb250cm9sbGVkLCBzbyB1c2UgdGhlIHBsYWNlaG9sZGVyIGFzIHRoZSB2YWx1ZSB1bnRpbCBhbGwgc2VnbWVudHMgYXJlIGVudGVyZWQgc28gaXQgZG9lc24ndFxuICAgIC8vIGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIGFuZCBlbWl0IGEgd2FybmluZy5cbiAgICBsZXQgW3BsYWNlaG9sZGVyRGF0ZSwgc2V0UGxhY2Vob2xkZXJEYXRlXSA9ICgwLCAkN1V6b00kdXNlU3RhdGUpKCgpPT4oMCwgJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JDY2YWEyYjA5ZGU0YjFlYTUpKHByb3BzLnBsYWNlaG9sZGVyVmFsdWUsIGdyYW51bGFyaXR5LCBjYWxlbmRhciwgZGVmYXVsdFRpbWVab25lKSk7XG4gICAgbGV0IHZhbCA9IGNhbGVuZGFyVmFsdWUgfHwgcGxhY2Vob2xkZXJEYXRlO1xuICAgIGxldCBzaG93RXJhID0gY2FsZW5kYXIuaWRlbnRpZmllciA9PT0gXCJncmVnb3J5XCIgJiYgdmFsLmVyYSA9PT0gXCJCQ1wiO1xuICAgIHZhciBfcHJvcHNfbWF4R3JhbnVsYXJpdHk7XG4gICAgbGV0IGZvcm1hdE9wdHMgPSAoMCwgJDdVem9NJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgZ3JhbnVsYXJpdHk6IGdyYW51bGFyaXR5LFxuICAgICAgICAgICAgbWF4R3JhbnVsYXJpdHk6IChfcHJvcHNfbWF4R3JhbnVsYXJpdHkgPSBwcm9wcy5tYXhHcmFudWxhcml0eSkgIT09IG51bGwgJiYgX3Byb3BzX21heEdyYW51bGFyaXR5ICE9PSB2b2lkIDAgPyBfcHJvcHNfbWF4R3JhbnVsYXJpdHkgOiBcInllYXJcIixcbiAgICAgICAgICAgIHRpbWVab25lOiBkZWZhdWx0VGltZVpvbmUsXG4gICAgICAgICAgICBoaWRlVGltZVpvbmU6IGhpZGVUaW1lWm9uZSxcbiAgICAgICAgICAgIGhvdXJDeWNsZTogcHJvcHMuaG91ckN5Y2xlLFxuICAgICAgICAgICAgc2hvd0VyYTogc2hvd0VyYSxcbiAgICAgICAgICAgIHNob3VsZEZvcmNlTGVhZGluZ1plcm9zOiBwcm9wcy5zaG91bGRGb3JjZUxlYWRpbmdaZXJvc1xuICAgICAgICB9KSwgW1xuICAgICAgICBwcm9wcy5tYXhHcmFudWxhcml0eSxcbiAgICAgICAgZ3JhbnVsYXJpdHksXG4gICAgICAgIHByb3BzLmhvdXJDeWNsZSxcbiAgICAgICAgcHJvcHMuc2hvdWxkRm9yY2VMZWFkaW5nWmVyb3MsXG4gICAgICAgIGRlZmF1bHRUaW1lWm9uZSxcbiAgICAgICAgaGlkZVRpbWVab25lLFxuICAgICAgICBzaG93RXJhXG4gICAgXSk7XG4gICAgbGV0IG9wdHMgPSAoMCwgJDdVem9NJHVzZU1lbW8pKCgpPT4oMCwgJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JDdlMzE5ZWE0MDdlNjNiYzApKHt9LCBmb3JtYXRPcHRzKSwgW1xuICAgICAgICBmb3JtYXRPcHRzXG4gICAgXSk7XG4gICAgbGV0IGRhdGVGb3JtYXR0ZXIgPSAoMCwgJDdVem9NJHVzZU1lbW8pKCgpPT5uZXcgKDAsICQ3VXpvTSREYXRlRm9ybWF0dGVyKShsb2NhbGUsIG9wdHMpLCBbXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgb3B0c1xuICAgIF0pO1xuICAgIGxldCByZXNvbHZlZE9wdGlvbnMgPSAoMCwgJDdVem9NJHVzZU1lbW8pKCgpPT5kYXRlRm9ybWF0dGVyLnJlc29sdmVkT3B0aW9ucygpLCBbXG4gICAgICAgIGRhdGVGb3JtYXR0ZXJcbiAgICBdKTtcbiAgICAvLyBEZXRlcm1pbmUgaG93IG1hbnkgZWRpdGFibGUgc2VnbWVudHMgdGhlcmUgYXJlIGZvciB2YWxpZGF0aW9uIHB1cnBvc2VzLlxuICAgIC8vIFRoZSByZXN1bHQgaXMgY2FjaGVkIGZvciBwZXJmb3JtYW5jZS5cbiAgICBsZXQgYWxsU2VnbWVudHMgPSAoMCwgJDdVem9NJHVzZU1lbW8pKCgpPT5kYXRlRm9ybWF0dGVyLmZvcm1hdFRvUGFydHMobmV3IERhdGUoKSkuZmlsdGVyKChzZWcpPT4kM2MwZmM3NjAzOWYxYzUxNiR2YXIkRURJVEFCTEVfU0VHTUVOVFNbc2VnLnR5cGVdKS5yZWR1Y2UoKHAsIHNlZyk9PihwW3NlZy50eXBlXSA9IHRydWUsIHApLCB7fSksIFtcbiAgICAgICAgZGF0ZUZvcm1hdHRlclxuICAgIF0pO1xuICAgIGxldCBbdmFsaWRTZWdtZW50cywgc2V0VmFsaWRTZWdtZW50c10gPSAoMCwgJDdVem9NJHVzZVN0YXRlKSgoKT0+cHJvcHMudmFsdWUgfHwgcHJvcHMuZGVmYXVsdFZhbHVlID8ge1xuICAgICAgICAgICAgLi4uYWxsU2VnbWVudHNcbiAgICAgICAgfSA6IHt9KTtcbiAgICBsZXQgY2xlYXJlZFNlZ21lbnQgPSAoMCwgJDdVem9NJHVzZVJlZikoKTtcbiAgICAvLyBSZXNldCBwbGFjZWhvbGRlciB3aGVuIGNhbGVuZGFyIGNoYW5nZXNcbiAgICBsZXQgbGFzdENhbGVuZGFySWRlbnRpZmllciA9ICgwLCAkN1V6b00kdXNlUmVmKShjYWxlbmRhci5pZGVudGlmaWVyKTtcbiAgICAoMCwgJDdVem9NJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKGNhbGVuZGFyLmlkZW50aWZpZXIgIT09IGxhc3RDYWxlbmRhcklkZW50aWZpZXIuY3VycmVudCkge1xuICAgICAgICAgICAgbGFzdENhbGVuZGFySWRlbnRpZmllci5jdXJyZW50ID0gY2FsZW5kYXIuaWRlbnRpZmllcjtcbiAgICAgICAgICAgIHNldFBsYWNlaG9sZGVyRGF0ZSgocGxhY2Vob2xkZXIpPT5PYmplY3Qua2V5cyh2YWxpZFNlZ21lbnRzKS5sZW5ndGggPiAwID8gKDAsICQ3VXpvTSR0b0NhbGVuZGFyKShwbGFjZWhvbGRlciwgY2FsZW5kYXIpIDogKDAsICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCQ2NmFhMmIwOWRlNGIxZWE1KShwcm9wcy5wbGFjZWhvbGRlclZhbHVlLCBncmFudWxhcml0eSwgY2FsZW5kYXIsIGRlZmF1bHRUaW1lWm9uZSkpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBjYWxlbmRhcixcbiAgICAgICAgZ3JhbnVsYXJpdHksXG4gICAgICAgIHZhbGlkU2VnbWVudHMsXG4gICAgICAgIGRlZmF1bHRUaW1lWm9uZSxcbiAgICAgICAgcHJvcHMucGxhY2Vob2xkZXJWYWx1ZVxuICAgIF0pO1xuICAgIC8vIElmIHRoZXJlIGlzIGEgdmFsdWUgcHJvcCwgYW5kIHNvbWUgc2VnbWVudHMgd2VyZSBwcmV2aW91c2x5IHBsYWNlaG9sZGVycywgbWFyayB0aGVtIGFsbCBhcyB2YWxpZC5cbiAgICBpZiAodmFsdWUgJiYgT2JqZWN0LmtleXModmFsaWRTZWdtZW50cykubGVuZ3RoIDwgT2JqZWN0LmtleXMoYWxsU2VnbWVudHMpLmxlbmd0aCkge1xuICAgICAgICB2YWxpZFNlZ21lbnRzID0ge1xuICAgICAgICAgICAgLi4uYWxsU2VnbWVudHNcbiAgICAgICAgfTtcbiAgICAgICAgc2V0VmFsaWRTZWdtZW50cyh2YWxpZFNlZ21lbnRzKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHZhbHVlIGlzIHNldCB0byBudWxsIGFuZCBhbGwgc2VnbWVudHMgYXJlIHZhbGlkLCByZXNldCB0aGUgcGxhY2Vob2xkZXIuXG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgT2JqZWN0LmtleXModmFsaWRTZWdtZW50cykubGVuZ3RoID09PSBPYmplY3Qua2V5cyhhbGxTZWdtZW50cykubGVuZ3RoKSB7XG4gICAgICAgIHZhbGlkU2VnbWVudHMgPSB7fTtcbiAgICAgICAgc2V0VmFsaWRTZWdtZW50cyh2YWxpZFNlZ21lbnRzKTtcbiAgICAgICAgc2V0UGxhY2Vob2xkZXJEYXRlKCgwLCAkMzVhMjJmMTRhMWYwNGIxMSRleHBvcnQkNjZhYTJiMDlkZTRiMWVhNSkocHJvcHMucGxhY2Vob2xkZXJWYWx1ZSwgZ3JhbnVsYXJpdHksIGNhbGVuZGFyLCBkZWZhdWx0VGltZVpvbmUpKTtcbiAgICB9XG4gICAgLy8gSWYgYWxsIHNlZ21lbnRzIGFyZSB2YWxpZCwgdXNlIHRoZSBkYXRlIGZyb20gc3RhdGUsIG90aGVyd2lzZSB1c2UgdGhlIHBsYWNlaG9sZGVyIGRhdGUuXG4gICAgbGV0IGRpc3BsYXlWYWx1ZSA9IGNhbGVuZGFyVmFsdWUgJiYgT2JqZWN0LmtleXModmFsaWRTZWdtZW50cykubGVuZ3RoID49IE9iamVjdC5rZXlzKGFsbFNlZ21lbnRzKS5sZW5ndGggPyBjYWxlbmRhclZhbHVlIDogcGxhY2Vob2xkZXJEYXRlO1xuICAgIGxldCBzZXRWYWx1ZSA9IChuZXdWYWx1ZSk9PntcbiAgICAgICAgaWYgKHByb3BzLmlzRGlzYWJsZWQgfHwgcHJvcHMuaXNSZWFkT25seSkgcmV0dXJuO1xuICAgICAgICBsZXQgdmFsaWRLZXlzID0gT2JqZWN0LmtleXModmFsaWRTZWdtZW50cyk7XG4gICAgICAgIGxldCBhbGxLZXlzID0gT2JqZWN0LmtleXMoYWxsU2VnbWVudHMpO1xuICAgICAgICAvLyBpZiBhbGwgdGhlIHNlZ21lbnRzIGFyZSBjb21wbGV0ZWQgb3IgYSB0aW1lZmllbGQgd2l0aCBldmVyeXRoaW5nIGJ1dCBhbS9wbSBzZXQgdGhlIHRpbWUsIGFsc28gaWdub3JlIHdoZW4gYW0vcG0gY2xlYXJlZFxuICAgICAgICBpZiAobmV3VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0RGF0ZShudWxsKTtcbiAgICAgICAgICAgIHNldFBsYWNlaG9sZGVyRGF0ZSgoMCwgJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JDY2YWEyYjA5ZGU0YjFlYTUpKHByb3BzLnBsYWNlaG9sZGVyVmFsdWUsIGdyYW51bGFyaXR5LCBjYWxlbmRhciwgZGVmYXVsdFRpbWVab25lKSk7XG4gICAgICAgICAgICBzZXRWYWxpZFNlZ21lbnRzKHt9KTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxpZEtleXMubGVuZ3RoID49IGFsbEtleXMubGVuZ3RoIHx8IHZhbGlkS2V5cy5sZW5ndGggPT09IGFsbEtleXMubGVuZ3RoIC0gMSAmJiBhbGxTZWdtZW50cy5kYXlQZXJpb2QgJiYgIXZhbGlkU2VnbWVudHMuZGF5UGVyaW9kICYmIGNsZWFyZWRTZWdtZW50LmN1cnJlbnQgIT09IFwiZGF5UGVyaW9kXCIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBkaXNwbGF5IGNhbGVuZGFyIHNob3VsZCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBlbWl0dGVkIHZhbHVlLlxuICAgICAgICAgICAgLy8gRW1pdCBkYXRlcyBpbiB0aGUgc2FtZSBjYWxlbmRhciBhcyB0aGUgb3JpZ2luYWwgdmFsdWUsIGlmIGFueSwgb3RoZXJ3aXNlIGdyZWdvcmlhbi5cbiAgICAgICAgICAgIG5ld1ZhbHVlID0gKDAsICQ3VXpvTSR0b0NhbGVuZGFyKShuZXdWYWx1ZSwgKHYgPT09IG51bGwgfHwgdiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdi5jYWxlbmRhcikgfHwgbmV3ICgwLCAkN1V6b00kR3JlZ29yaWFuQ2FsZW5kYXIpKCkpO1xuICAgICAgICAgICAgc2V0RGF0ZShuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBzZXRQbGFjZWhvbGRlckRhdGUobmV3VmFsdWUpO1xuICAgICAgICBjbGVhcmVkU2VnbWVudC5jdXJyZW50ID0gbnVsbDtcbiAgICB9O1xuICAgIGxldCBkYXRlVmFsdWUgPSAoMCwgJDdVem9NJHVzZU1lbW8pKCgpPT5kaXNwbGF5VmFsdWUudG9EYXRlKHRpbWVab25lKSwgW1xuICAgICAgICBkaXNwbGF5VmFsdWUsXG4gICAgICAgIHRpbWVab25lXG4gICAgXSk7XG4gICAgbGV0IHNlZ21lbnRzID0gKDAsICQ3VXpvTSR1c2VNZW1vKSgoKT0+ZGF0ZUZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKGRhdGVWYWx1ZSkubWFwKChzZWdtZW50KT0+e1xuICAgICAgICAgICAgbGV0IGlzRWRpdGFibGUgPSAkM2MwZmM3NjAzOWYxYzUxNiR2YXIkRURJVEFCTEVfU0VHTUVOVFNbc2VnbWVudC50eXBlXTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50LnR5cGUgPT09IFwiZXJhXCIgJiYgY2FsZW5kYXIuZ2V0RXJhcygpLmxlbmd0aCA9PT0gMSkgaXNFZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGlzUGxhY2Vob2xkZXIgPSAkM2MwZmM3NjAzOWYxYzUxNiR2YXIkRURJVEFCTEVfU0VHTUVOVFNbc2VnbWVudC50eXBlXSAmJiAhdmFsaWRTZWdtZW50c1tzZWdtZW50LnR5cGVdO1xuICAgICAgICAgICAgbGV0IHBsYWNlaG9sZGVyID0gJDNjMGZjNzYwMzlmMWM1MTYkdmFyJEVESVRBQkxFX1NFR01FTlRTW3NlZ21lbnQudHlwZV0gPyAoMCwgJDNlM2VkNTVhYjI5NjY3MTQkZXhwb3J0JGQzZjVjNWUwYTUwMjNmYTApKHNlZ21lbnQudHlwZSwgc2VnbWVudC52YWx1ZSwgbG9jYWxlKSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICQzYzBmYzc2MDM5ZjFjNTE2JHZhciRUWVBFX01BUFBJTkdbc2VnbWVudC50eXBlXSB8fCBzZWdtZW50LnR5cGUsXG4gICAgICAgICAgICAgICAgdGV4dDogaXNQbGFjZWhvbGRlciA/IHBsYWNlaG9sZGVyIDogc2VnbWVudC52YWx1ZSxcbiAgICAgICAgICAgICAgICAuLi4kM2MwZmM3NjAzOWYxYzUxNiR2YXIkZ2V0U2VnbWVudExpbWl0cyhkaXNwbGF5VmFsdWUsIHNlZ21lbnQudHlwZSwgcmVzb2x2ZWRPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBpc1BsYWNlaG9sZGVyOiBpc1BsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBpc0VkaXRhYmxlOiBpc0VkaXRhYmxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSwgW1xuICAgICAgICBkYXRlVmFsdWUsXG4gICAgICAgIHZhbGlkU2VnbWVudHMsXG4gICAgICAgIGRhdGVGb3JtYXR0ZXIsXG4gICAgICAgIHJlc29sdmVkT3B0aW9ucyxcbiAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICBjYWxlbmRhcixcbiAgICAgICAgbG9jYWxlXG4gICAgXSk7XG4gICAgLy8gV2hlbiB0aGUgZXJhIGZpZWxkIGFwcGVhcnMsIG1hcmsgaXQgdmFsaWQgaWYgdGhlIHllYXIgZmllbGQgaXMgYWxyZWFkeSB2YWxpZC5cbiAgICAvLyBJZiB0aGUgZXJhIGZpZWxkIGRpc2FwcGVhcnMsIHJlbW92ZSBpdCBmcm9tIHRoZSB2YWxpZCBzZWdtZW50cy5cbiAgICBpZiAoYWxsU2VnbWVudHMuZXJhICYmIHZhbGlkU2VnbWVudHMueWVhciAmJiAhdmFsaWRTZWdtZW50cy5lcmEpIHtcbiAgICAgICAgdmFsaWRTZWdtZW50cy5lcmEgPSB0cnVlO1xuICAgICAgICBzZXRWYWxpZFNlZ21lbnRzKHtcbiAgICAgICAgICAgIC4uLnZhbGlkU2VnbWVudHNcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghYWxsU2VnbWVudHMuZXJhICYmIHZhbGlkU2VnbWVudHMuZXJhKSB7XG4gICAgICAgIGRlbGV0ZSB2YWxpZFNlZ21lbnRzLmVyYTtcbiAgICAgICAgc2V0VmFsaWRTZWdtZW50cyh7XG4gICAgICAgICAgICAuLi52YWxpZFNlZ21lbnRzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbWFya1ZhbGlkID0gKHBhcnQpPT57XG4gICAgICAgIHZhbGlkU2VnbWVudHNbcGFydF0gPSB0cnVlO1xuICAgICAgICBpZiAocGFydCA9PT0gXCJ5ZWFyXCIgJiYgYWxsU2VnbWVudHMuZXJhKSB2YWxpZFNlZ21lbnRzLmVyYSA9IHRydWU7XG4gICAgICAgIHNldFZhbGlkU2VnbWVudHMoe1xuICAgICAgICAgICAgLi4udmFsaWRTZWdtZW50c1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGxldCBhZGp1c3RTZWdtZW50ID0gKHR5cGUsIGFtb3VudCk9PntcbiAgICAgICAgaWYgKCF2YWxpZFNlZ21lbnRzW3R5cGVdKSB7XG4gICAgICAgICAgICBtYXJrVmFsaWQodHlwZSk7XG4gICAgICAgICAgICBsZXQgdmFsaWRLZXlzID0gT2JqZWN0LmtleXModmFsaWRTZWdtZW50cyk7XG4gICAgICAgICAgICBsZXQgYWxsS2V5cyA9IE9iamVjdC5rZXlzKGFsbFNlZ21lbnRzKTtcbiAgICAgICAgICAgIGlmICh2YWxpZEtleXMubGVuZ3RoID49IGFsbEtleXMubGVuZ3RoIHx8IHZhbGlkS2V5cy5sZW5ndGggPT09IGFsbEtleXMubGVuZ3RoIC0gMSAmJiBhbGxTZWdtZW50cy5kYXlQZXJpb2QgJiYgIXZhbGlkU2VnbWVudHMuZGF5UGVyaW9kKSBzZXRWYWx1ZShkaXNwbGF5VmFsdWUpO1xuICAgICAgICB9IGVsc2Ugc2V0VmFsdWUoJDNjMGZjNzYwMzlmMWM1MTYkdmFyJGFkZFNlZ21lbnQoZGlzcGxheVZhbHVlLCB0eXBlLCBhbW91bnQsIHJlc29sdmVkT3B0aW9ucykpO1xuICAgIH07XG4gICAgbGV0IGlzVmFsdWVJbnZhbGlkID0gcHJvcHMuaXNJbnZhbGlkIHx8IHByb3BzLnZhbGlkYXRpb25TdGF0ZSA9PT0gXCJpbnZhbGlkXCIgfHwgKDAsICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCRlYWM1MDkyMGNmMmZkNTlhKShjYWxlbmRhclZhbHVlLCBwcm9wcy5taW5WYWx1ZSwgcHJvcHMubWF4VmFsdWUpO1xuICAgIGxldCB2YWxpZGF0aW9uU3RhdGUgPSBwcm9wcy52YWxpZGF0aW9uU3RhdGUgfHwgKGlzVmFsdWVJbnZhbGlkID8gXCJpbnZhbGlkXCIgOiBudWxsKTtcbiAgICB2YXIgX3Byb3BzX21heEdyYW51bGFyaXR5MTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2FsZW5kYXJWYWx1ZSxcbiAgICAgICAgZGF0ZVZhbHVlOiBkYXRlVmFsdWUsXG4gICAgICAgIGNhbGVuZGFyOiBjYWxlbmRhcixcbiAgICAgICAgc2V0VmFsdWU6IHNldFZhbHVlLFxuICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgICAgIGRhdGVGb3JtYXR0ZXI6IGRhdGVGb3JtYXR0ZXIsXG4gICAgICAgIHZhbGlkYXRpb25TdGF0ZTogdmFsaWRhdGlvblN0YXRlLFxuICAgICAgICBpc0ludmFsaWQ6IGlzVmFsdWVJbnZhbGlkLFxuICAgICAgICBncmFudWxhcml0eTogZ3JhbnVsYXJpdHksXG4gICAgICAgIG1heEdyYW51bGFyaXR5OiAoX3Byb3BzX21heEdyYW51bGFyaXR5MSA9IHByb3BzLm1heEdyYW51bGFyaXR5KSAhPT0gbnVsbCAmJiBfcHJvcHNfbWF4R3JhbnVsYXJpdHkxICE9PSB2b2lkIDAgPyBfcHJvcHNfbWF4R3JhbnVsYXJpdHkxIDogXCJ5ZWFyXCIsXG4gICAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICAgIGlzUmVhZE9ubHk6IGlzUmVhZE9ubHksXG4gICAgICAgIGlzUmVxdWlyZWQ6IGlzUmVxdWlyZWQsXG4gICAgICAgIGluY3JlbWVudCAocGFydCkge1xuICAgICAgICAgICAgYWRqdXN0U2VnbWVudChwYXJ0LCAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjcmVtZW50IChwYXJ0KSB7XG4gICAgICAgICAgICBhZGp1c3RTZWdtZW50KHBhcnQsIC0xKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5jcmVtZW50UGFnZSAocGFydCkge1xuICAgICAgICAgICAgYWRqdXN0U2VnbWVudChwYXJ0LCAkM2MwZmM3NjAzOWYxYzUxNiR2YXIkUEFHRV9TVEVQW3BhcnRdIHx8IDEpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNyZW1lbnRQYWdlIChwYXJ0KSB7XG4gICAgICAgICAgICBhZGp1c3RTZWdtZW50KHBhcnQsIC0oJDNjMGZjNzYwMzlmMWM1MTYkdmFyJFBBR0VfU1RFUFtwYXJ0XSB8fCAxKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFNlZ21lbnQgKHBhcnQsIHYpIHtcbiAgICAgICAgICAgIG1hcmtWYWxpZChwYXJ0KTtcbiAgICAgICAgICAgIHNldFZhbHVlKCQzYzBmYzc2MDM5ZjFjNTE2JHZhciRzZXRTZWdtZW50KGRpc3BsYXlWYWx1ZSwgcGFydCwgdiwgcmVzb2x2ZWRPcHRpb25zKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpcm1QbGFjZWhvbGRlciAoKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuaXNEaXNhYmxlZCB8fCBwcm9wcy5pc1JlYWRPbmx5KSByZXR1cm47XG4gICAgICAgICAgICAvLyBDb25maXJtIHRoZSBwbGFjZWhvbGRlciBpZiBvbmx5IHRoZSBkYXkgcGVyaW9kIGlzIG5vdCBmaWxsZWQgaW4uXG4gICAgICAgICAgICBsZXQgdmFsaWRLZXlzID0gT2JqZWN0LmtleXModmFsaWRTZWdtZW50cyk7XG4gICAgICAgICAgICBsZXQgYWxsS2V5cyA9IE9iamVjdC5rZXlzKGFsbFNlZ21lbnRzKTtcbiAgICAgICAgICAgIGlmICh2YWxpZEtleXMubGVuZ3RoID09PSBhbGxLZXlzLmxlbmd0aCAtIDEgJiYgYWxsU2VnbWVudHMuZGF5UGVyaW9kICYmICF2YWxpZFNlZ21lbnRzLmRheVBlcmlvZCkge1xuICAgICAgICAgICAgICAgIHZhbGlkU2VnbWVudHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFsbFNlZ21lbnRzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZXRWYWxpZFNlZ21lbnRzKHZhbGlkU2VnbWVudHMpO1xuICAgICAgICAgICAgICAgIHNldFZhbHVlKGRpc3BsYXlWYWx1ZS5jb3B5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGVhclNlZ21lbnQgKHBhcnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB2YWxpZFNlZ21lbnRzW3BhcnRdO1xuICAgICAgICAgICAgY2xlYXJlZFNlZ21lbnQuY3VycmVudCA9IHBhcnQ7XG4gICAgICAgICAgICBzZXRWYWxpZFNlZ21lbnRzKHtcbiAgICAgICAgICAgICAgICAuLi52YWxpZFNlZ21lbnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBwbGFjZWhvbGRlciA9ICgwLCAkMzVhMjJmMTRhMWYwNGIxMSRleHBvcnQkNjZhYTJiMDlkZTRiMWVhNSkocHJvcHMucGxhY2Vob2xkZXJWYWx1ZSwgZ3JhbnVsYXJpdHksIGNhbGVuZGFyLCBkZWZhdWx0VGltZVpvbmUpO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgLy8gUmVzZXQgZGF5IHBlcmlvZCB0byBkZWZhdWx0IHdpdGhvdXQgY2hhbmdpbmcgdGhlIGhvdXIuXG4gICAgICAgICAgICBpZiAocGFydCA9PT0gXCJkYXlQZXJpb2RcIiAmJiBcImhvdXJcIiBpbiBkaXNwbGF5VmFsdWUgJiYgXCJob3VyXCIgaW4gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNQTSA9IGRpc3BsYXlWYWx1ZS5ob3VyID49IDEyO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRCZVBNID0gcGxhY2Vob2xkZXIuaG91ciA+PSAxMjtcbiAgICAgICAgICAgICAgICBpZiAoaXNQTSAmJiAhc2hvdWxkQmVQTSkgdmFsdWUgPSBkaXNwbGF5VmFsdWUuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgaG91cjogZGlzcGxheVZhbHVlLmhvdXIgLSAxMlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1BNICYmIHNob3VsZEJlUE0pIHZhbHVlID0gZGlzcGxheVZhbHVlLnNldCh7XG4gICAgICAgICAgICAgICAgICAgIGhvdXI6IGRpc3BsYXlWYWx1ZS5ob3VyICsgMTJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydCBpbiBkaXNwbGF5VmFsdWUpIHZhbHVlID0gZGlzcGxheVZhbHVlLnNldCh7XG4gICAgICAgICAgICAgICAgW3BhcnRdOiBwbGFjZWhvbGRlcltwYXJ0XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXREYXRlKG51bGwpO1xuICAgICAgICAgICAgc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXRWYWx1ZSAoZmllbGRPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGVuZGFyVmFsdWUpIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgbGV0IGZvcm1hdE9wdGlvbnMgPSAoMCwgJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JDdlMzE5ZWE0MDdlNjNiYzApKGZpZWxkT3B0aW9ucywgZm9ybWF0T3B0cyk7XG4gICAgICAgICAgICBsZXQgZm9ybWF0dGVyID0gbmV3ICgwLCAkN1V6b00kRGF0ZUZvcm1hdHRlcikobG9jYWxlLCBmb3JtYXRPcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGRhdGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gJDNjMGZjNzYwMzlmMWM1MTYkdmFyJGdldFNlZ21lbnRMaW1pdHMoZGF0ZSwgdHlwZSwgb3B0aW9ucykge1xuICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgY2FzZSBcImVyYVwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBlcmFzID0gZGF0ZS5jYWxlbmRhci5nZXRFcmFzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGVyYXMuaW5kZXhPZihkYXRlLmVyYSksXG4gICAgICAgICAgICAgICAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZTogZXJhcy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInllYXJcIjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGUueWVhcixcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZTogMSxcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZTogZGF0ZS5jYWxlbmRhci5nZXRZZWFyc0luRXJhKGRhdGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGUubW9udGgsXG4gICAgICAgICAgICAgICAgbWluVmFsdWU6ICgwLCAkN1V6b00kZ2V0TWluaW11bU1vbnRoSW5ZZWFyKShkYXRlKSxcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZTogZGF0ZS5jYWxlbmRhci5nZXRNb250aHNJblllYXIoZGF0ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGUuZGF5LFxuICAgICAgICAgICAgICAgIG1pblZhbHVlOiAoMCwgJDdVem9NJGdldE1pbmltdW1EYXlJbk1vbnRoKShkYXRlKSxcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZTogZGF0ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aChkYXRlKVxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKFwiaG91clwiIGluIGRhdGUpIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgY2FzZSBcImRheVBlcmlvZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0ZS5ob3VyID49IDEyID8gMTIgOiAwLFxuICAgICAgICAgICAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIG1heFZhbHVlOiAxMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImhvdXJcIjpcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhvdXIxMikge1xuICAgICAgICAgICAgICAgIGxldCBpc1BNID0gZGF0ZS5ob3VyID49IDEyO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRlLmhvdXIsXG4gICAgICAgICAgICAgICAgICAgIG1pblZhbHVlOiBpc1BNID8gMTIgOiAwLFxuICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZTogaXNQTSA/IDIzIDogMTFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0ZS5ob3VyLFxuICAgICAgICAgICAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIG1heFZhbHVlOiAyM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcIm1pbnV0ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0ZS5taW51dGUsXG4gICAgICAgICAgICAgICAgbWluVmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgbWF4VmFsdWU6IDU5XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRlLnNlY29uZCxcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZTogMCxcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZTogNTlcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn1cbmZ1bmN0aW9uICQzYzBmYzc2MDM5ZjFjNTE2JHZhciRhZGRTZWdtZW50KHZhbHVlLCBwYXJ0LCBhbW91bnQsIG9wdGlvbnMpIHtcbiAgICBzd2l0Y2gocGFydCl7XG4gICAgICAgIGNhc2UgXCJlcmFcIjpcbiAgICAgICAgY2FzZSBcInllYXJcIjpcbiAgICAgICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jeWNsZShwYXJ0LCBhbW91bnQsIHtcbiAgICAgICAgICAgICAgICByb3VuZDogcGFydCA9PT0gXCJ5ZWFyXCJcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoXCJob3VyXCIgaW4gdmFsdWUpIHN3aXRjaChwYXJ0KXtcbiAgICAgICAgY2FzZSBcImRheVBlcmlvZFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBob3VycyA9IHZhbHVlLmhvdXI7XG4gICAgICAgICAgICAgICAgbGV0IGlzUE0gPSBob3VycyA+PSAxMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgaG91cjogaXNQTSA/IGhvdXJzIC0gMTIgOiBob3VycyArIDEyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJob3VyXCI6XG4gICAgICAgIGNhc2UgXCJtaW51dGVcIjpcbiAgICAgICAgY2FzZSBcInNlY29uZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmN5Y2xlKHBhcnQsIGFtb3VudCwge1xuICAgICAgICAgICAgICAgIHJvdW5kOiBwYXJ0ICE9PSBcImhvdXJcIixcbiAgICAgICAgICAgICAgICBob3VyQ3ljbGU6IG9wdGlvbnMuaG91cjEyID8gMTIgOiAyNFxuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gJDNjMGZjNzYwMzlmMWM1MTYkdmFyJHNldFNlZ21lbnQodmFsdWUsIHBhcnQsIHNlZ21lbnRWYWx1ZSwgb3B0aW9ucykge1xuICAgIHN3aXRjaChwYXJ0KXtcbiAgICAgICAgY2FzZSBcImRheVwiOlxuICAgICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgY2FzZSBcInllYXJcIjpcbiAgICAgICAgY2FzZSBcImVyYVwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNldCh7XG4gICAgICAgICAgICAgICAgW3BhcnRdOiBzZWdtZW50VmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoXCJob3VyXCIgaW4gdmFsdWUpIHN3aXRjaChwYXJ0KXtcbiAgICAgICAgY2FzZSBcImRheVBlcmlvZFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBob3VycyA9IHZhbHVlLmhvdXI7XG4gICAgICAgICAgICAgICAgbGV0IHdhc1BNID0gaG91cnMgPj0gMTI7XG4gICAgICAgICAgICAgICAgbGV0IGlzUE0gPSBzZWdtZW50VmFsdWUgPj0gMTI7XG4gICAgICAgICAgICAgICAgaWYgKGlzUE0gPT09IHdhc1BNKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNldCh7XG4gICAgICAgICAgICAgICAgICAgIGhvdXI6IHdhc1BNID8gaG91cnMgLSAxMiA6IGhvdXJzICsgMTJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImhvdXJcIjpcbiAgICAgICAgICAgIC8vIEluIDEyIGhvdXIgdGltZSwgZW5zdXJlIHRoYXQgQU0vUE0gZG9lcyBub3QgY2hhbmdlXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ob3VyMTIpIHtcbiAgICAgICAgICAgICAgICBsZXQgaG91cnMgPSB2YWx1ZS5ob3VyO1xuICAgICAgICAgICAgICAgIGxldCB3YXNQTSA9IGhvdXJzID49IDEyO1xuICAgICAgICAgICAgICAgIGlmICghd2FzUE0gJiYgc2VnbWVudFZhbHVlID09PSAxMikgc2VnbWVudFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICBpZiAod2FzUE0gJiYgc2VnbWVudFZhbHVlIDwgMTIpIHNlZ21lbnRWYWx1ZSArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSBcIm1pbnV0ZVwiOlxuICAgICAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc2V0KHtcbiAgICAgICAgICAgICAgICBbcGFydF06IHNlZ21lbnRWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5cblxuZnVuY3Rpb24gJDkzYzM4YTVlMjhiZTYyNDkkZXhwb3J0JGU1MGE2MWMxZGU5ZjU3NChwcm9wcykge1xuICAgIHZhciBfcHJvcHNfaXNEYXRlVW5hdmFpbGFibGUsIF9wcm9wc19pc0RhdGVVbmF2YWlsYWJsZTE7XG4gICAgbGV0IG92ZXJsYXlTdGF0ZSA9ICgwLCAkN1V6b00kdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSkocHJvcHMpO1xuICAgIGxldCBbY29udHJvbGxlZFZhbHVlLCBzZXRDb250cm9sbGVkVmFsdWVdID0gKDAsICQ3VXpvTSR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUgfHwgbnVsbCwgcHJvcHMub25DaGFuZ2UpO1xuICAgIGxldCBbcGxhY2Vob2xkZXJWYWx1ZSwgc2V0UGxhY2Vob2xkZXJWYWx1ZV0gPSAoMCwgJDdVem9NJHVzZVN0YXRlKSgoKT0+Y29udHJvbGxlZFZhbHVlIHx8IHtcbiAgICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgZW5kOiBudWxsXG4gICAgICAgIH0pO1xuICAgIC8vIFJlc2V0IHRoZSBwbGFjZWhvbGRlciBpZiB0aGUgdmFsdWUgcHJvcCBpcyBzZXQgdG8gbnVsbC5cbiAgICBpZiAoY29udHJvbGxlZFZhbHVlID09IG51bGwgJiYgcGxhY2Vob2xkZXJWYWx1ZS5zdGFydCAmJiBwbGFjZWhvbGRlclZhbHVlLmVuZCkge1xuICAgICAgICBwbGFjZWhvbGRlclZhbHVlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICAgICAgICBlbmQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgc2V0UGxhY2Vob2xkZXJWYWx1ZShwbGFjZWhvbGRlclZhbHVlKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gY29udHJvbGxlZFZhbHVlIHx8IHBsYWNlaG9sZGVyVmFsdWU7XG4gICAgbGV0IHNldFZhbHVlID0gKHZhbHVlKT0+e1xuICAgICAgICBzZXRQbGFjZWhvbGRlclZhbHVlKHZhbHVlIHx8IHtcbiAgICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgZW5kOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5zdGFydCkgJiYgdmFsdWUuZW5kKSBzZXRDb250cm9sbGVkVmFsdWUodmFsdWUpO1xuICAgICAgICBlbHNlIHNldENvbnRyb2xsZWRWYWx1ZShudWxsKTtcbiAgICB9O1xuICAgIGxldCB2ID0gKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5zdGFydCkgfHwgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5lbmQpIHx8IHByb3BzLnBsYWNlaG9sZGVyVmFsdWU7XG4gICAgbGV0IFtncmFudWxhcml0eV0gPSAoMCwgJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JDI0NDBkYTM1M2NlZGFkNDMpKHYsIHByb3BzLmdyYW51bGFyaXR5KTtcbiAgICBsZXQgaGFzVGltZSA9IGdyYW51bGFyaXR5ID09PSBcImhvdXJcIiB8fCBncmFudWxhcml0eSA9PT0gXCJtaW51dGVcIiB8fCBncmFudWxhcml0eSA9PT0gXCJzZWNvbmRcIjtcbiAgICB2YXIgX3Byb3BzX3Nob3VsZENsb3NlT25TZWxlY3Q7XG4gICAgbGV0IHNob3VsZENsb3NlT25TZWxlY3QgPSAoX3Byb3BzX3Nob3VsZENsb3NlT25TZWxlY3QgPSBwcm9wcy5zaG91bGRDbG9zZU9uU2VsZWN0KSAhPT0gbnVsbCAmJiBfcHJvcHNfc2hvdWxkQ2xvc2VPblNlbGVjdCAhPT0gdm9pZCAwID8gX3Byb3BzX3Nob3VsZENsb3NlT25TZWxlY3QgOiB0cnVlO1xuICAgIGxldCBbZGF0ZVJhbmdlLCBzZXRTZWxlY3RlZERhdGVSYW5nZV0gPSAoMCwgJDdVem9NJHVzZVN0YXRlKShudWxsKTtcbiAgICBsZXQgW3RpbWVSYW5nZSwgc2V0U2VsZWN0ZWRUaW1lUmFuZ2VdID0gKDAsICQ3VXpvTSR1c2VTdGF0ZSkobnVsbCk7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnN0YXJ0ICYmIHZhbHVlLmVuZCkge1xuICAgICAgICBkYXRlUmFuZ2UgPSB2YWx1ZTtcbiAgICAgICAgaWYgKFwiaG91clwiIGluIHZhbHVlLnN0YXJ0KSB0aW1lUmFuZ2UgPSB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IGNvbW1pdFZhbHVlID0gKGRhdGVSYW5nZSwgdGltZVJhbmdlKT0+e1xuICAgICAgICBzZXRWYWx1ZSh7XG4gICAgICAgICAgICBzdGFydDogXCJ0aW1lWm9uZVwiIGluIHRpbWVSYW5nZS5zdGFydCA/IHRpbWVSYW5nZS5zdGFydC5zZXQoKDAsICQ3VXpvTSR0b0NhbGVuZGFyRGF0ZSkoZGF0ZVJhbmdlLnN0YXJ0KSkgOiAoMCwgJDdVem9NJHRvQ2FsZW5kYXJEYXRlVGltZSkoZGF0ZVJhbmdlLnN0YXJ0LCB0aW1lUmFuZ2Uuc3RhcnQpLFxuICAgICAgICAgICAgZW5kOiBcInRpbWVab25lXCIgaW4gdGltZVJhbmdlLmVuZCA/IHRpbWVSYW5nZS5lbmQuc2V0KCgwLCAkN1V6b00kdG9DYWxlbmRhckRhdGUpKGRhdGVSYW5nZS5lbmQpKSA6ICgwLCAkN1V6b00kdG9DYWxlbmRhckRhdGVUaW1lKShkYXRlUmFuZ2UuZW5kLCB0aW1lUmFuZ2UuZW5kKVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0U2VsZWN0ZWREYXRlUmFuZ2UobnVsbCk7XG4gICAgICAgIHNldFNlbGVjdGVkVGltZVJhbmdlKG51bGwpO1xuICAgIH07XG4gICAgLy8gSW50ZXJjZXB0IHNldFZhbHVlIHRvIG1ha2Ugc3VyZSB0aGUgVGltZSBzZWN0aW9uIGlzIG5vdCBjaGFuZ2VkIGJ5IGRhdGUgc2VsZWN0aW9uIGluIENhbGVuZGFyXG4gICAgbGV0IHNldERhdGVSYW5nZSA9IChyYW5nZSk9PntcbiAgICAgICAgbGV0IHNob3VsZENsb3NlID0gdHlwZW9mIHNob3VsZENsb3NlT25TZWxlY3QgPT09IFwiZnVuY3Rpb25cIiA/IHNob3VsZENsb3NlT25TZWxlY3QoKSA6IHNob3VsZENsb3NlT25TZWxlY3Q7XG4gICAgICAgIGlmIChoYXNUaW1lKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2xvc2UgfHwgcmFuZ2Uuc3RhcnQgJiYgcmFuZ2UuZW5kICYmICh0aW1lUmFuZ2UgPT09IG51bGwgfHwgdGltZVJhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aW1lUmFuZ2Uuc3RhcnQpICYmICh0aW1lUmFuZ2UgPT09IG51bGwgfHwgdGltZVJhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aW1lUmFuZ2UuZW5kKSkgY29tbWl0VmFsdWUocmFuZ2UsIHtcbiAgICAgICAgICAgICAgICBzdGFydDogKHRpbWVSYW5nZSA9PT0gbnVsbCB8fCB0aW1lUmFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbWVSYW5nZS5zdGFydCkgfHwgKDAsICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCRjNTIyMWE3OGVmNzNjNWU5KShwcm9wcy5wbGFjZWhvbGRlclZhbHVlKSxcbiAgICAgICAgICAgICAgICBlbmQ6ICh0aW1lUmFuZ2UgPT09IG51bGwgfHwgdGltZVJhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aW1lUmFuZ2UuZW5kKSB8fCAoMCwgJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JGM1MjIxYTc4ZWY3M2M1ZTkpKHByb3BzLnBsYWNlaG9sZGVyVmFsdWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsc2Ugc2V0U2VsZWN0ZWREYXRlUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnN0YXJ0ICYmIHJhbmdlLmVuZCkgc2V0VmFsdWUocmFuZ2UpO1xuICAgICAgICBlbHNlIHNldFNlbGVjdGVkRGF0ZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKHNob3VsZENsb3NlKSBvdmVybGF5U3RhdGUuc2V0T3BlbihmYWxzZSk7XG4gICAgfTtcbiAgICBsZXQgc2V0VGltZVJhbmdlID0gKHJhbmdlKT0+e1xuICAgICAgICBpZiAoKGRhdGVSYW5nZSA9PT0gbnVsbCB8fCBkYXRlUmFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGVSYW5nZS5zdGFydCkgJiYgKGRhdGVSYW5nZSA9PT0gbnVsbCB8fCBkYXRlUmFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGVSYW5nZS5lbmQpICYmIHJhbmdlLnN0YXJ0ICYmIHJhbmdlLmVuZCkgY29tbWl0VmFsdWUoZGF0ZVJhbmdlLCByYW5nZSk7XG4gICAgICAgIGVsc2Ugc2V0U2VsZWN0ZWRUaW1lUmFuZ2UocmFuZ2UpO1xuICAgIH07XG4gICAgbGV0IGlzVmFsdWVJbnZhbGlkID0gcHJvcHMuaXNJbnZhbGlkIHx8IHByb3BzLnZhbGlkYXRpb25TdGF0ZSA9PT0gXCJpbnZhbGlkXCIgfHwgdmFsdWUgIT0gbnVsbCAmJiAoKDAsICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCRlYWM1MDkyMGNmMmZkNTlhKSh2YWx1ZS5zdGFydCwgcHJvcHMubWluVmFsdWUsIHByb3BzLm1heFZhbHVlKSB8fCAoMCwgJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JGVhYzUwOTIwY2YyZmQ1OWEpKHZhbHVlLmVuZCwgcHJvcHMubWluVmFsdWUsIHByb3BzLm1heFZhbHVlKSB8fCB2YWx1ZS5lbmQgIT0gbnVsbCAmJiB2YWx1ZS5zdGFydCAhPSBudWxsICYmIHZhbHVlLmVuZC5jb21wYXJlKHZhbHVlLnN0YXJ0KSA8IDAgfHwgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5zdGFydCkgJiYgKChfcHJvcHNfaXNEYXRlVW5hdmFpbGFibGUgPSBwcm9wcy5pc0RhdGVVbmF2YWlsYWJsZSkgPT09IG51bGwgfHwgX3Byb3BzX2lzRGF0ZVVuYXZhaWxhYmxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJvcHNfaXNEYXRlVW5hdmFpbGFibGUuY2FsbChwcm9wcywgdmFsdWUuc3RhcnQpKSB8fCAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmVuZCkgJiYgKChfcHJvcHNfaXNEYXRlVW5hdmFpbGFibGUxID0gcHJvcHMuaXNEYXRlVW5hdmFpbGFibGUpID09PSBudWxsIHx8IF9wcm9wc19pc0RhdGVVbmF2YWlsYWJsZTEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcm9wc19pc0RhdGVVbmF2YWlsYWJsZTEuY2FsbChwcm9wcywgdmFsdWUuZW5kKSkpO1xuICAgIGxldCB2YWxpZGF0aW9uU3RhdGUgPSBwcm9wcy52YWxpZGF0aW9uU3RhdGUgfHwgKGlzVmFsdWVJbnZhbGlkID8gXCJpbnZhbGlkXCIgOiBudWxsKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHNldFZhbHVlOiBzZXRWYWx1ZSxcbiAgICAgICAgZGF0ZVJhbmdlOiBkYXRlUmFuZ2UsXG4gICAgICAgIHRpbWVSYW5nZTogdGltZVJhbmdlLFxuICAgICAgICBncmFudWxhcml0eTogZ3JhbnVsYXJpdHksXG4gICAgICAgIGhhc1RpbWU6IGhhc1RpbWUsXG4gICAgICAgIHNldERhdGUgKHBhcnQsIGRhdGUpIHtcbiAgICAgICAgICAgIHNldERhdGVSYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4uZGF0ZVJhbmdlLFxuICAgICAgICAgICAgICAgIFtwYXJ0XTogZGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFRpbWUgKHBhcnQsIHRpbWUpIHtcbiAgICAgICAgICAgIHNldFRpbWVSYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4udGltZVJhbmdlLFxuICAgICAgICAgICAgICAgIFtwYXJ0XTogdGltZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldERhdGVUaW1lIChwYXJ0LCBkYXRlVGltZSkge1xuICAgICAgICAgICAgc2V0VmFsdWUoe1xuICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIFtwYXJ0XTogZGF0ZVRpbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXREYXRlUmFuZ2U6IHNldERhdGVSYW5nZSxcbiAgICAgICAgc2V0VGltZVJhbmdlOiBzZXRUaW1lUmFuZ2UsXG4gICAgICAgIC4uLm92ZXJsYXlTdGF0ZSxcbiAgICAgICAgc2V0T3BlbiAoaXNPcGVuKSB7XG4gICAgICAgICAgICAvLyBDb21taXQgdGhlIHNlbGVjdGVkIGRhdGUgcmFuZ2Ugd2hlbiB0aGUgY2FsZW5kYXIgaXMgY2xvc2VkLiBVc2UgYSBwbGFjZWhvbGRlciB0aW1lIGlmIG9uZSB3YXNuJ3Qgc2V0LlxuICAgICAgICAgICAgLy8gSWYgb25seSB0aGUgdGltZSByYW5nZSB3YXMgc2V0IGFuZCBub3QgdGhlIGRhdGUgcmFuZ2UsIGRvbid0IGNvbW1pdC4gVGhlIHN0YXRlIHdpbGwgYmUgcHJlc2VydmVkIHVudGlsXG4gICAgICAgICAgICAvLyB0aGUgdXNlciBvcGVucyB0aGUgcG9wb3ZlciBhZ2Fpbi5cbiAgICAgICAgICAgIGlmICghaXNPcGVuICYmICEoKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5zdGFydCkgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5lbmQpKSAmJiAoZGF0ZVJhbmdlID09PSBudWxsIHx8IGRhdGVSYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0ZVJhbmdlLnN0YXJ0KSAmJiAoZGF0ZVJhbmdlID09PSBudWxsIHx8IGRhdGVSYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0ZVJhbmdlLmVuZCkgJiYgaGFzVGltZSkgY29tbWl0VmFsdWUoZGF0ZVJhbmdlLCB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6ICh0aW1lUmFuZ2UgPT09IG51bGwgfHwgdGltZVJhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aW1lUmFuZ2Uuc3RhcnQpIHx8ICgwLCAkMzVhMjJmMTRhMWYwNGIxMSRleHBvcnQkYzUyMjFhNzhlZjczYzVlOSkocHJvcHMucGxhY2Vob2xkZXJWYWx1ZSksXG4gICAgICAgICAgICAgICAgZW5kOiAodGltZVJhbmdlID09PSBudWxsIHx8IHRpbWVSYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGltZVJhbmdlLmVuZCkgfHwgKDAsICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCRjNTIyMWE3OGVmNzNjNWU5KShwcm9wcy5wbGFjZWhvbGRlclZhbHVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdmVybGF5U3RhdGUuc2V0T3Blbihpc09wZW4pO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0aW9uU3RhdGU6IHZhbGlkYXRpb25TdGF0ZSxcbiAgICAgICAgaXNJbnZhbGlkOiBpc1ZhbHVlSW52YWxpZCxcbiAgICAgICAgZm9ybWF0VmFsdWUgKGxvY2FsZSwgZmllbGRPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8ICF2YWx1ZS5zdGFydCB8fCAhdmFsdWUuZW5kKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBzdGFydFRpbWVab25lID0gXCJ0aW1lWm9uZVwiIGluIHZhbHVlLnN0YXJ0ID8gdmFsdWUuc3RhcnQudGltZVpvbmUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgc3RhcnRHcmFudWxhcml0eSA9IHByb3BzLmdyYW51bGFyaXR5IHx8ICh2YWx1ZS5zdGFydCAmJiBcIm1pbnV0ZVwiIGluIHZhbHVlLnN0YXJ0ID8gXCJtaW51dGVcIiA6IFwiZGF5XCIpO1xuICAgICAgICAgICAgbGV0IGVuZFRpbWVab25lID0gXCJ0aW1lWm9uZVwiIGluIHZhbHVlLmVuZCA/IHZhbHVlLmVuZC50aW1lWm9uZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBlbmRHcmFudWxhcml0eSA9IHByb3BzLmdyYW51bGFyaXR5IHx8ICh2YWx1ZS5lbmQgJiYgXCJtaW51dGVcIiBpbiB2YWx1ZS5lbmQgPyBcIm1pbnV0ZVwiIDogXCJkYXlcIik7XG4gICAgICAgICAgICBsZXQgc3RhcnRPcHRpb25zID0gKDAsICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCQ3ZTMxOWVhNDA3ZTYzYmMwKShmaWVsZE9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBncmFudWxhcml0eTogc3RhcnRHcmFudWxhcml0eSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZTogc3RhcnRUaW1lWm9uZSxcbiAgICAgICAgICAgICAgICBoaWRlVGltZVpvbmU6IHByb3BzLmhpZGVUaW1lWm9uZSxcbiAgICAgICAgICAgICAgICBob3VyQ3ljbGU6IHByb3BzLmhvdXJDeWNsZSxcbiAgICAgICAgICAgICAgICBzaG93RXJhOiB2YWx1ZS5zdGFydC5jYWxlbmRhci5pZGVudGlmaWVyID09PSBcImdyZWdvcnlcIiAmJiB2YWx1ZS5zdGFydC5lcmEgPT09IFwiQkNcIiB8fCB2YWx1ZS5lbmQuY2FsZW5kYXIuaWRlbnRpZmllciA9PT0gXCJncmVnb3J5XCIgJiYgdmFsdWUuZW5kLmVyYSA9PT0gXCJCQ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBzdGFydERhdGUgPSB2YWx1ZS5zdGFydC50b0RhdGUoc3RhcnRUaW1lWm9uZSB8fCBcIlVUQ1wiKTtcbiAgICAgICAgICAgIGxldCBlbmREYXRlID0gdmFsdWUuZW5kLnRvRGF0ZShlbmRUaW1lWm9uZSB8fCBcIlVUQ1wiKTtcbiAgICAgICAgICAgIGxldCBzdGFydEZvcm1hdHRlciA9IG5ldyAoMCwgJDdVem9NJERhdGVGb3JtYXR0ZXIpKGxvY2FsZSwgc3RhcnRPcHRpb25zKTtcbiAgICAgICAgICAgIGxldCBlbmRGb3JtYXR0ZXI7XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lWm9uZSA9PT0gZW5kVGltZVpvbmUgJiYgc3RhcnRHcmFudWxhcml0eSA9PT0gZW5kR3JhbnVsYXJpdHkgJiYgdmFsdWUuc3RhcnQuY29tcGFyZSh2YWx1ZS5lbmQpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGZvcm1hdFJhbmdlLCBhcyBpdCByZXN1bHRzIGluIHNob3J0ZXIgb3V0cHV0IHdoZW4gc29tZSBvZiB0aGUgZmllbGRzXG4gICAgICAgICAgICAgICAgLy8gYXJlIHNoYXJlZCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIGRhdGVzIChlLmcuIHRoZSBzYW1lIG1vbnRoKS5cbiAgICAgICAgICAgICAgICAvLyBGb3JtYXR0aW5nIHdpbGwgZmFpbCBpZiB0aGUgZW5kIGRhdGUgaXMgYmVmb3JlIHRoZSBzdGFydCBkYXRlLiBGYWxsIGJhY2sgYmVsb3cgd2hlbiB0aGF0IGhhcHBlbnMuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRzID0gc3RhcnRGb3JtYXR0ZXIuZm9ybWF0UmFuZ2VUb1BhcnRzKHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHNlcGFyYXRvciBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIGRhdGUuIFRoaXMgaXMgZGV0ZXJtaW5lZFxuICAgICAgICAgICAgICAgICAgICAvLyBieSBmaW5kaW5nIHRoZSBsYXN0IHNoYXJlZCBsaXRlcmFsIGJlZm9yZSB0aGUgZW5kIHJhbmdlLlxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VwYXJhdG9ySW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5zb3VyY2UgPT09IFwic2hhcmVkXCIgJiYgcGFydC50eXBlID09PSBcImxpdGVyYWxcIikgc2VwYXJhdG9ySW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFydC5zb3VyY2UgPT09IFwiZW5kUmFuZ2VcIikgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHdlIGNhbiBjb21iaW5lIHRoZSBwYXJ0cyBpbnRvIHN0YXJ0IGFuZCBlbmQgc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IHNlcGFyYXRvckluZGV4KSBzdGFydCArPSBwYXJ0c1tpXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPiBzZXBhcmF0b3JJbmRleCkgZW5kICs9IHBhcnRzW2ldLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5kRm9ybWF0dGVyID0gc3RhcnRGb3JtYXR0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBlbmRPcHRpb25zID0gKDAsICQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCQ3ZTMxOWVhNDA3ZTYzYmMwKShmaWVsZE9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhbnVsYXJpdHk6IGVuZEdyYW51bGFyaXR5LFxuICAgICAgICAgICAgICAgICAgICB0aW1lWm9uZTogZW5kVGltZVpvbmUsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVUaW1lWm9uZTogcHJvcHMuaGlkZVRpbWVab25lLFxuICAgICAgICAgICAgICAgICAgICBob3VyQ3ljbGU6IHByb3BzLmhvdXJDeWNsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVuZEZvcm1hdHRlciA9IG5ldyAoMCwgJDdVem9NJERhdGVGb3JtYXR0ZXIpKGxvY2FsZSwgZW5kT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydEZvcm1hdHRlci5mb3JtYXQoc3RhcnREYXRlKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZEZvcm1hdHRlci5mb3JtYXQoZW5kRGF0ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cblxuZnVuY3Rpb24gJGVmZjVkOGVlNTI5YWM0YmIkZXhwb3J0JGZkNTNjZWYwY2M3OTYxMDEocHJvcHMpIHtcbiAgICBsZXQgeyBwbGFjZWhvbGRlclZhbHVlOiBwbGFjZWhvbGRlclZhbHVlID0gbmV3ICgwLCAkN1V6b00kVGltZSkoKSwgbWluVmFsdWU6IG1pblZhbHVlLCBtYXhWYWx1ZTogbWF4VmFsdWUsIGdyYW51bGFyaXR5OiBncmFudWxhcml0eSB9ID0gcHJvcHM7XG4gICAgbGV0IFt2YWx1ZSwgc2V0VmFsdWVdID0gKDAsICQ3VXpvTSR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHByb3BzLm9uQ2hhbmdlKTtcbiAgICBsZXQgdiA9IHZhbHVlIHx8IHBsYWNlaG9sZGVyVmFsdWU7XG4gICAgbGV0IGRheSA9IHYgJiYgXCJkYXlcIiBpbiB2ID8gdiA6IHVuZGVmaW5lZDtcbiAgICBsZXQgZGVmYXVsdFZhbHVlVGltZVpvbmUgPSBwcm9wcy5kZWZhdWx0VmFsdWUgJiYgXCJ0aW1lWm9uZVwiIGluIHByb3BzLmRlZmF1bHRWYWx1ZSA/IHByb3BzLmRlZmF1bHRWYWx1ZS50aW1lWm9uZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgcGxhY2Vob2xkZXJEYXRlID0gKDAsICQ3VXpvTSR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBsZXQgdmFsdWVUaW1lWm9uZSA9IHYgJiYgXCJ0aW1lWm9uZVwiIGluIHYgPyB2LnRpbWVab25lIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gKHZhbHVlVGltZVpvbmUgfHwgZGVmYXVsdFZhbHVlVGltZVpvbmUpICYmIHBsYWNlaG9sZGVyVmFsdWUgPyAoMCwgJDdVem9NJHRvWm9uZWQpKCRlZmY1ZDhlZTUyOWFjNGJiJHZhciRjb252ZXJ0VmFsdWUocGxhY2Vob2xkZXJWYWx1ZSksIHZhbHVlVGltZVpvbmUgfHwgZGVmYXVsdFZhbHVlVGltZVpvbmUpIDogJGVmZjVkOGVlNTI5YWM0YmIkdmFyJGNvbnZlcnRWYWx1ZShwbGFjZWhvbGRlclZhbHVlKTtcbiAgICB9LCBbXG4gICAgICAgIHBsYWNlaG9sZGVyVmFsdWUsXG4gICAgICAgIHYsXG4gICAgICAgIGRlZmF1bHRWYWx1ZVRpbWVab25lXG4gICAgXSk7XG4gICAgbGV0IG1pbkRhdGUgPSAoMCwgJDdVem9NJHVzZU1lbW8pKCgpPT4kZWZmNWQ4ZWU1MjlhYzRiYiR2YXIkY29udmVydFZhbHVlKG1pblZhbHVlLCBkYXkpLCBbXG4gICAgICAgIG1pblZhbHVlLFxuICAgICAgICBkYXlcbiAgICBdKTtcbiAgICBsZXQgbWF4RGF0ZSA9ICgwLCAkN1V6b00kdXNlTWVtbykoKCk9PiRlZmY1ZDhlZTUyOWFjNGJiJHZhciRjb252ZXJ0VmFsdWUobWF4VmFsdWUsIGRheSksIFtcbiAgICAgICAgbWF4VmFsdWUsXG4gICAgICAgIGRheVxuICAgIF0pO1xuICAgIGxldCB0aW1lVmFsdWUgPSAoMCwgJDdVem9NJHVzZU1lbW8pKCgpPT52YWx1ZSAmJiBcImRheVwiIGluIHZhbHVlID8gKDAsICQ3VXpvTSR0b1RpbWUpKHZhbHVlKSA6IHZhbHVlLCBbXG4gICAgICAgIHZhbHVlXG4gICAgXSk7XG4gICAgbGV0IGRhdGVUaW1lID0gKDAsICQ3VXpvTSR1c2VNZW1vKSgoKT0+dmFsdWUgPT0gbnVsbCA/IG51bGwgOiAkZWZmNWQ4ZWU1MjlhYzRiYiR2YXIkY29udmVydFZhbHVlKHZhbHVlKSwgW1xuICAgICAgICB2YWx1ZVxuICAgIF0pO1xuICAgIGxldCBvbkNoYW5nZSA9IChuZXdWYWx1ZSk9PntcbiAgICAgICAgc2V0VmFsdWUoZGF5IHx8IGRlZmF1bHRWYWx1ZVRpbWVab25lID8gbmV3VmFsdWUgOiBuZXdWYWx1ZSAmJiAoMCwgJDdVem9NJHRvVGltZSkobmV3VmFsdWUpKTtcbiAgICB9O1xuICAgIGxldCBzdGF0ZSA9ICgwLCAkM2MwZmM3NjAzOWYxYzUxNiRleHBvcnQkNjBlODQ3NzhlZGZmNmQyNikoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgdmFsdWU6IGRhdGVUaW1lLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgbWluVmFsdWU6IG1pbkRhdGUsXG4gICAgICAgIG1heFZhbHVlOiBtYXhEYXRlLFxuICAgICAgICBvbkNoYW5nZTogb25DaGFuZ2UsXG4gICAgICAgIGdyYW51bGFyaXR5OiBncmFudWxhcml0eSB8fCBcIm1pbnV0ZVwiLFxuICAgICAgICBtYXhHcmFudWxhcml0eTogXCJob3VyXCIsXG4gICAgICAgIHBsYWNlaG9sZGVyVmFsdWU6IHBsYWNlaG9sZGVyRGF0ZSxcbiAgICAgICAgLy8gQ2FsZW5kYXIgc2hvdWxkIG5vdCBtYXR0ZXIgZm9yIHRpbWUgZmllbGRzLlxuICAgICAgICBjcmVhdGVDYWxlbmRhcjogKCk9Pm5ldyAoMCwgJDdVem9NJEdyZWdvcmlhbkNhbGVuZGFyKSgpXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHRpbWVWYWx1ZTogdGltZVZhbHVlXG4gICAgfTtcbn1cbmZ1bmN0aW9uICRlZmY1ZDhlZTUyOWFjNGJiJHZhciRjb252ZXJ0VmFsdWUodmFsdWUsIGRhdGUgPSAoMCwgJDdVem9NJHRvZGF5KSgoMCwgJDdVem9NJGdldExvY2FsVGltZVpvbmUpKCkpKSB7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKFwiZGF5XCIgaW4gdmFsdWUpIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gKDAsICQ3VXpvTSR0b0NhbGVuZGFyRGF0ZVRpbWUpKGRhdGUsIHZhbHVlKTtcbn1cblxuXG5cblxuZXhwb3J0IHskYWI1YmYzZjYxODA5MDM4OSRleHBvcnQkODcxOTRiYjM3OGNjM2FjMiBhcyB1c2VEYXRlUGlja2VyU3RhdGUsICQzYzBmYzc2MDM5ZjFjNTE2JGV4cG9ydCQ2MGU4NDc3OGVkZmY2ZDI2IGFzIHVzZURhdGVGaWVsZFN0YXRlLCAkOTNjMzhhNWUyOGJlNjI0OSRleHBvcnQkZTUwYTYxYzFkZTlmNTc0IGFzIHVzZURhdGVSYW5nZVBpY2tlclN0YXRlLCAkZWZmNWQ4ZWU1MjlhYzRiYiRleHBvcnQkZmQ1M2NlZjBjYzc5NjEwMSBhcyB1c2VUaW1lRmllbGRTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidG9DYWxlbmRhckRhdGUiLCIkN1V6b00kdG9DYWxlbmRhckRhdGUiLCJ0b0NhbGVuZGFyRGF0ZVRpbWUiLCIkN1V6b00kdG9DYWxlbmRhckRhdGVUaW1lIiwiRGF0ZUZvcm1hdHRlciIsIiQ3VXpvTSREYXRlRm9ybWF0dGVyIiwiVGltZSIsIiQ3VXpvTSRUaW1lIiwidG9DYWxlbmRhciIsIiQ3VXpvTSR0b0NhbGVuZGFyIiwibm93IiwiJDdVem9NJG5vdyIsIkdyZWdvcmlhbkNhbGVuZGFyIiwiJDdVem9NJEdyZWdvcmlhbkNhbGVuZGFyIiwiZ2V0TWluaW11bU1vbnRoSW5ZZWFyIiwiJDdVem9NJGdldE1pbmltdW1Nb250aEluWWVhciIsImdldE1pbmltdW1EYXlJbk1vbnRoIiwiJDdVem9NJGdldE1pbmltdW1EYXlJbk1vbnRoIiwidG9ab25lZCIsIiQ3VXpvTSR0b1pvbmVkIiwidG9UaW1lIiwiJDdVem9NJHRvVGltZSIsInRvZGF5IiwiJDdVem9NJHRvZGF5IiwiZ2V0TG9jYWxUaW1lWm9uZSIsIiQ3VXpvTSRnZXRMb2NhbFRpbWVab25lIiwidXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSIsIiQ3VXpvTSR1c2VPdmVybGF5VHJpZ2dlclN0YXRlIiwidXNlQ29udHJvbGxlZFN0YXRlIiwiJDdVem9NJHVzZUNvbnRyb2xsZWRTdGF0ZSIsInVzZVN0YXRlIiwiJDdVem9NJHVzZVN0YXRlIiwidXNlTWVtbyIsIiQ3VXpvTSR1c2VNZW1vIiwidXNlUmVmIiwiJDdVem9NJHVzZVJlZiIsInVzZUVmZmVjdCIsIiQ3VXpvTSR1c2VFZmZlY3QiLCJMb2NhbGl6ZWRTdHJpbmdEaWN0aW9uYXJ5IiwiJDdVem9NJExvY2FsaXplZFN0cmluZ0RpY3Rpb25hcnkiLCIkMzVhMjJmMTRhMWYwNGIxMSRleHBvcnQkZWFjNTA5MjBjZjJmZDU5YSIsInZhbHVlIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsImNvbXBhcmUiLCIkMzVhMjJmMTRhMWYwNGIxMSR2YXIkREVGQVVMVF9GSUVMRF9PUFRJT05TIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInNlY29uZCIsIiQzNWEyMmYxNGExZjA0YjExJHZhciRUV09fRElHSVRfRklFTERfT1BUSU9OUyIsIiQzNWEyMmYxNGExZjA0YjExJGV4cG9ydCQ3ZTMxOWVhNDA3ZTYzYmMwIiwiZmllbGRPcHRpb25zIiwib3B0aW9ucyIsImRlZmF1bHRGaWVsZE9wdGlvbnMiLCJzaG91bGRGb3JjZUxlYWRpbmdaZXJvcyIsImdyYW51bGFyaXR5Iiwia2V5cyIsIk9iamVjdCIsIl9vcHRpb25zX21heEdyYW51bGFyaXR5Iiwic3RhcnRJZHgiLCJpbmRleE9mIiwibWF4R3JhbnVsYXJpdHkiLCJlbmRJZHgiLCJFcnJvciIsIm9wdHMiLCJzbGljZSIsInJlZHVjZSIsImtleSIsImhvdXJDeWNsZSIsImhvdXIxMiIsInRpbWVab25lIiwiaGFzVGltZSIsImhpZGVUaW1lWm9uZSIsInRpbWVab25lTmFtZSIsInNob3dFcmEiLCJlcmEiLCIkMzVhMjJmMTRhMWYwNGIxMSRleHBvcnQkYzUyMjFhNzhlZjczYzVlOSIsInBsYWNlaG9sZGVyVmFsdWUiLCIkMzVhMjJmMTRhMWYwNGIxMSRleHBvcnQkNjFhNDkwYTgwYzU1MjU1MCIsImNhbGVuZGFyIiwidW5kZWZpbmVkIiwiJDM1YTIyZjE0YTFmMDRiMTEkZXhwb3J0JDY2YWEyYjA5ZGU0YjFlYTUiLCJkYXRlIiwic2V0IiwibWlsbGlzZWNvbmQiLCIkMzVhMjJmMTRhMWYwNGIxMSRleHBvcnQkMjQ0MGRhMzUzY2VkYWQ0MyIsInYiLCJkZWZhdWx0VGltZVpvbmUiLCJkZWZhdWx0R3JhbnVsYXJpdHkiLCJ0b1N0cmluZyIsImxhc3RWYWx1ZSIsInNldExhc3RWYWx1ZSIsIiRhYjViZjNmNjE4MDkwMzg5JGV4cG9ydCQ4NzE5NGJiMzc4Y2MzYWMyIiwicHJvcHMiLCJfcHJvcHNfaXNEYXRlVW5hdmFpbGFibGUiLCJvdmVybGF5U3RhdGUiLCJzZXRWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsIm9uQ2hhbmdlIiwiZGF0ZVZhbHVlIiwidG9EYXRlIiwiX3Byb3BzX3Nob3VsZENsb3NlT25TZWxlY3QiLCJzaG91bGRDbG9zZU9uU2VsZWN0Iiwic2VsZWN0ZWREYXRlIiwic2V0U2VsZWN0ZWREYXRlIiwic2VsZWN0ZWRUaW1lIiwic2V0U2VsZWN0ZWRUaW1lIiwiY29tbWl0VmFsdWUiLCJ0aW1lIiwic2VsZWN0RGF0ZSIsIm5ld1ZhbHVlIiwic2hvdWxkQ2xvc2UiLCJzZXRPcGVuIiwic2VsZWN0VGltZSIsImlzVmFsdWVJbnZhbGlkIiwiaXNJbnZhbGlkIiwidmFsaWRhdGlvblN0YXRlIiwiaXNEYXRlVW5hdmFpbGFibGUiLCJjYWxsIiwidGltZVZhbHVlIiwic2V0RGF0ZVZhbHVlIiwic2V0VGltZVZhbHVlIiwiaXNPcGVuIiwiZm9ybWF0VmFsdWUiLCJsb2NhbGUiLCJmb3JtYXRPcHRpb25zIiwiaWRlbnRpZmllciIsImZvcm1hdHRlciIsImZvcm1hdCIsIiQzZTNlZDU1YWIyOTY2NzE0JHZhciRwbGFjZWhvbGRlcnMiLCJhY2giLCJhZiIsImFtIiwiYW4iLCJhciIsImFzdCIsImF6IiwiYmUiLCJiZyIsImJuIiwiYnIiLCJicyIsImNhIiwiY2FrIiwiY2tiIiwiY3MiLCJjeSIsImRhIiwiZGUiLCJkc2IiLCJlbCIsImVuIiwiZW8iLCJlcyIsImV0IiwiZXUiLCJmYSIsImZmIiwiZmkiLCJmciIsImZ5IiwiZ2EiLCJnZCIsImdsIiwiaGUiLCJociIsImhzYiIsImh1IiwiaWEiLCJpZCIsIml0IiwiamEiLCJrYSIsImtrIiwia24iLCJrbyIsImxiIiwibG8iLCJsdCIsImx2IiwibWVoIiwibWwiLCJtcyIsIm5sIiwibm4iLCJubyIsIm9jIiwicGwiLCJwdCIsInJtIiwicm8iLCJydSIsInNjIiwic2NuIiwic2siLCJzbCIsInNyIiwic3YiLCJzemwiLCJ0ZyIsInRoIiwidHIiLCJ1ayIsIiQzZTNlZDU1YWIyOTY2NzE0JGV4cG9ydCRkM2Y1YzVlMGE1MDIzZmEwIiwiZmllbGQiLCJnZXRTdHJpbmdGb3JMb2NhbGUiLCIkM2MwZmM3NjAzOWYxYzUxNiR2YXIkRURJVEFCTEVfU0VHTUVOVFMiLCJkYXlQZXJpb2QiLCIkM2MwZmM3NjAzOWYxYzUxNiR2YXIkUEFHRV9TVEVQIiwiJDNjMGZjNzYwMzlmMWM1MTYkdmFyJFRZUEVfTUFQUElORyIsImRheXBlcmlvZCIsIiQzYzBmYzc2MDM5ZjFjNTE2JGV4cG9ydCQ2MGU4NDc3OGVkZmY2ZDI2IiwiY3JlYXRlQ2FsZW5kYXIiLCJpc0Rpc2FibGVkIiwiaXNSZWFkT25seSIsImlzUmVxdWlyZWQiLCJkZWZhdWx0Rm9ybWF0dGVyIiwicmVzb2x2ZWRPcHRpb25zIiwic2V0RGF0ZSIsImNhbGVuZGFyVmFsdWUiLCJwbGFjZWhvbGRlckRhdGUiLCJzZXRQbGFjZWhvbGRlckRhdGUiLCJ2YWwiLCJfcHJvcHNfbWF4R3JhbnVsYXJpdHkiLCJmb3JtYXRPcHRzIiwiZGF0ZUZvcm1hdHRlciIsImFsbFNlZ21lbnRzIiwiZm9ybWF0VG9QYXJ0cyIsIkRhdGUiLCJmaWx0ZXIiLCJzZWciLCJ0eXBlIiwicCIsInZhbGlkU2VnbWVudHMiLCJzZXRWYWxpZFNlZ21lbnRzIiwiY2xlYXJlZFNlZ21lbnQiLCJsYXN0Q2FsZW5kYXJJZGVudGlmaWVyIiwiY3VycmVudCIsInBsYWNlaG9sZGVyIiwibGVuZ3RoIiwiZGlzcGxheVZhbHVlIiwidmFsaWRLZXlzIiwiYWxsS2V5cyIsInNlZ21lbnRzIiwibWFwIiwic2VnbWVudCIsImlzRWRpdGFibGUiLCJnZXRFcmFzIiwiaXNQbGFjZWhvbGRlciIsInRleHQiLCIkM2MwZmM3NjAzOWYxYzUxNiR2YXIkZ2V0U2VnbWVudExpbWl0cyIsIm1hcmtWYWxpZCIsInBhcnQiLCJhZGp1c3RTZWdtZW50IiwiYW1vdW50IiwiJDNjMGZjNzYwMzlmMWM1MTYkdmFyJGFkZFNlZ21lbnQiLCJfcHJvcHNfbWF4R3JhbnVsYXJpdHkxIiwiaW5jcmVtZW50IiwiZGVjcmVtZW50IiwiaW5jcmVtZW50UGFnZSIsImRlY3JlbWVudFBhZ2UiLCJzZXRTZWdtZW50IiwiJDNjMGZjNzYwMzlmMWM1MTYkdmFyJHNldFNlZ21lbnQiLCJjb25maXJtUGxhY2Vob2xkZXIiLCJjb3B5IiwiY2xlYXJTZWdtZW50IiwiaXNQTSIsInNob3VsZEJlUE0iLCJlcmFzIiwiZ2V0WWVhcnNJbkVyYSIsImdldE1vbnRoc0luWWVhciIsImdldERheXNJbk1vbnRoIiwiY3ljbGUiLCJyb3VuZCIsImhvdXJzIiwic2VnbWVudFZhbHVlIiwid2FzUE0iLCIkOTNjMzhhNWUyOGJlNjI0OSRleHBvcnQkZTUwYTYxYzFkZTlmNTc0IiwiX3Byb3BzX2lzRGF0ZVVuYXZhaWxhYmxlMSIsImNvbnRyb2xsZWRWYWx1ZSIsInNldENvbnRyb2xsZWRWYWx1ZSIsInNldFBsYWNlaG9sZGVyVmFsdWUiLCJzdGFydCIsImVuZCIsImRhdGVSYW5nZSIsInNldFNlbGVjdGVkRGF0ZVJhbmdlIiwidGltZVJhbmdlIiwic2V0U2VsZWN0ZWRUaW1lUmFuZ2UiLCJzZXREYXRlUmFuZ2UiLCJyYW5nZSIsInNldFRpbWVSYW5nZSIsInNldFRpbWUiLCJzZXREYXRlVGltZSIsImRhdGVUaW1lIiwic3RhcnRUaW1lWm9uZSIsInN0YXJ0R3JhbnVsYXJpdHkiLCJlbmRUaW1lWm9uZSIsImVuZEdyYW51bGFyaXR5Iiwic3RhcnRPcHRpb25zIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInN0YXJ0Rm9ybWF0dGVyIiwiZW5kRm9ybWF0dGVyIiwicGFydHMiLCJmb3JtYXRSYW5nZVRvUGFydHMiLCJzZXBhcmF0b3JJbmRleCIsImkiLCJzb3VyY2UiLCJlIiwiZW5kT3B0aW9ucyIsIiRlZmY1ZDhlZTUyOWFjNGJiJGV4cG9ydCRmZDUzY2VmMGNjNzk2MTAxIiwiZGVmYXVsdFZhbHVlVGltZVpvbmUiLCJ2YWx1ZVRpbWVab25lIiwiJGVmZjVkOGVlNTI5YWM0YmIkdmFyJGNvbnZlcnRWYWx1ZSIsIm1pbkRhdGUiLCJtYXhEYXRlIiwic3RhdGUiLCJ1c2VEYXRlUGlja2VyU3RhdGUiLCJ1c2VEYXRlRmllbGRTdGF0ZSIsInVzZURhdGVSYW5nZVBpY2tlclN0YXRlIiwidXNlVGltZUZpZWxkU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/datepicker/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/datepicker/node_modules/@react-stately/overlays/dist/import.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@react-stately/datepicker/node_modules/@react-stately/overlays/dist/import.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOverlayTriggerState: () => (/* binding */ $fc909762b330b746$export$61c6a8c84e605fb6)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/datepicker/node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $fc909762b330b746$export$61c6a8c84e605fb6(props) {\n    let [isOpen, setOpen] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.isOpen, props.defaultOpen || false, props.onOpenChange);\n    const open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(true);\n    }, [\n        setOpen\n    ]);\n    const close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(false);\n    }, [\n        setOpen\n    ]);\n    const toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(!isOpen);\n    }, [\n        setOpen,\n        isOpen\n    ]);\n    return {\n        isOpen: isOpen,\n        setOpen: setOpen,\n        open: open,\n        close: close,\n        toggle: toggle\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZGF0ZXBpY2tlci9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RDtBQUM2QjtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELFNBQVNJLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLENBQUNDLFFBQVFDLFFBQVEsR0FBRyxDQUFDLEdBQUdKLG9FQUF3QixFQUFHRSxNQUFNQyxNQUFNLEVBQUVELE1BQU1HLFdBQVcsSUFBSSxPQUFPSCxNQUFNSSxZQUFZO0lBQ25ILE1BQU1DLE9BQU8sQ0FBQyxHQUFHVCw4Q0FBaUIsRUFBRztRQUNqQ00sUUFBUTtJQUNaLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE1BQU1JLFFBQVEsQ0FBQyxHQUFHViw4Q0FBaUIsRUFBRztRQUNsQ00sUUFBUTtJQUNaLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE1BQU1LLFNBQVMsQ0FBQyxHQUFHWCw4Q0FBaUIsRUFBRztRQUNuQ00sUUFBUSxDQUFDRDtJQUNiLEdBQUc7UUFDQ0M7UUFDQUQ7S0FDSDtJQUNELE9BQU87UUFDSEEsUUFBUUE7UUFDUkMsU0FBU0E7UUFDVEcsTUFBTUE7UUFDTkMsT0FBT0E7UUFDUEMsUUFBUUE7SUFDWjtBQUNKO0FBSzZFLENBQzdFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2RhdGVwaWNrZXIvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L292ZXJsYXlzL2Rpc3QvaW1wb3J0Lm1qcz81YWM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlQ2FsbGJhY2sgYXMgJDRvQTNQJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICQ0b0EzUCR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkZmM5MDk3NjJiMzMwYjc0NiRleHBvcnQkNjFjNmE4Yzg0ZTYwNWZiNihwcm9wcykge1xuICAgIGxldCBbaXNPcGVuLCBzZXRPcGVuXSA9ICgwLCAkNG9BM1AkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5pc09wZW4sIHByb3BzLmRlZmF1bHRPcGVuIHx8IGZhbHNlLCBwcm9wcy5vbk9wZW5DaGFuZ2UpO1xuICAgIGNvbnN0IG9wZW4gPSAoMCwgJDRvQTNQJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRPcGVuKHRydWUpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0T3BlblxuICAgIF0pO1xuICAgIGNvbnN0IGNsb3NlID0gKDAsICQ0b0EzUCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0T3BlbihmYWxzZSk7XG4gICAgfSwgW1xuICAgICAgICBzZXRPcGVuXG4gICAgXSk7XG4gICAgY29uc3QgdG9nZ2xlID0gKDAsICQ0b0EzUCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0T3BlbighaXNPcGVuKTtcbiAgICB9LCBbXG4gICAgICAgIHNldE9wZW4sXG4gICAgICAgIGlzT3BlblxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzT3BlbjogaXNPcGVuLFxuICAgICAgICBzZXRPcGVuOiBzZXRPcGVuLFxuICAgICAgICBvcGVuOiBvcGVuLFxuICAgICAgICBjbG9zZTogY2xvc2UsXG4gICAgICAgIHRvZ2dsZTogdG9nZ2xlXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskZmM5MDk3NjJiMzMwYjc0NiRleHBvcnQkNjFjNmE4Yzg0ZTYwNWZiNiBhcyB1c2VPdmVybGF5VHJpZ2dlclN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsIiQ0b0EzUCR1c2VDYWxsYmFjayIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiQ0b0EzUCR1c2VDb250cm9sbGVkU3RhdGUiLCIkZmM5MDk3NjJiMzMwYjc0NiRleHBvcnQkNjFjNmE4Yzg0ZTYwNWZiNiIsInByb3BzIiwiaXNPcGVuIiwic2V0T3BlbiIsImRlZmF1bHRPcGVuIiwib25PcGVuQ2hhbmdlIiwib3BlbiIsImNsb3NlIiwidG9nZ2xlIiwidXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/datepicker/node_modules/@react-stately/overlays/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/datepicker/node_modules/@react-stately/utils/dist/import.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@react-stately/datepicker/node_modules/@react-stately/utils/dist/import.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ $9446cca9a3875146$export$7d15b64cf5a3a4c4),\n/* harmony export */   snapValueToStep: () => (/* binding */ $9446cca9a3875146$export$cb6e0bb50bc19463),\n/* harmony export */   toFixedNumber: () => (/* binding */ $9446cca9a3875146$export$b6268554fba451f),\n/* harmony export */   useControlledState: () => (/* binding */ $458b0a5536c1a7cf$export$40bfa8c7b0832715)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $458b0a5536c1a7cf$export$40bfa8c7b0832715(value, defaultValue, onChange) {\n    let [stateValue, setStateValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(value || defaultValue);\n    let isControlledRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value !== undefined);\n    let isControlled = value !== undefined;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let wasControlled = isControlledRef.current;\n        if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? \"controlled\" : \"uncontrolled\"} to ${isControlled ? \"controlled\" : \"uncontrolled\"}.`);\n        isControlledRef.current = isControlled;\n    }, [\n        isControlled\n    ]);\n    let currentValue = isControlled ? value : stateValue;\n    let setValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value, ...args)=>{\n        let onChangeCaller = (value, ...onChangeArgs)=>{\n            if (onChange) {\n                if (!Object.is(currentValue, value)) onChange(value, ...onChangeArgs);\n            }\n            if (!isControlled) // calling setState multiple times with the same value only emits onChange once.\n            // We do not use a ref for this because we specifically _do_ want the value to\n            // reset every render, and assigning to a ref in render breaks aborted suspended renders.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            currentValue = value;\n        };\n        if (typeof value === \"function\") {\n            console.warn(\"We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320\");\n            // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n            // when someone using useControlledState calls setControlledState(myFunc)\n            // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n            // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n            // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n            let updateFunction = (oldValue, ...functionArgs)=>{\n                let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);\n                onChangeCaller(interceptedValue, ...args);\n                if (!isControlled) return interceptedValue;\n                return oldValue;\n            };\n            setStateValue(updateFunction);\n        } else {\n            if (!isControlled) setStateValue(value);\n            onChangeCaller(value, ...args);\n        }\n    }, [\n        isControlled,\n        currentValue,\n        onChange\n    ]);\n    return [\n        currentValue,\n        setValue\n    ];\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */ function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {\n    let newValue = Math.min(Math.max(value, min), max);\n    return newValue;\n}\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n    min = Number(min);\n    max = Number(max);\n    let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n    if (!isNaN(min)) {\n        if (snappedValue < min) snappedValue = min;\n        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;\n    // correct floating point behavior by rounding to step precision\n    let string = step.toString();\n    let index = string.indexOf(\".\");\n    let precision = index >= 0 ? string.length - index : 0;\n    if (precision > 0) {\n        let pow = Math.pow(10, precision);\n        snappedValue = Math.round(snappedValue * pow) / pow;\n    }\n    return snappedValue;\n}\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits, base = 10) {\n    const pow = Math.pow(base, digits);\n    return Math.round(value * pow) / pow;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZGF0ZXBpY2tlci9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdXRpbHMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZJO0FBRTdJOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsU0FBU1EsMENBQTBDQyxLQUFLLEVBQUVDLFlBQVksRUFBRUMsUUFBUTtJQUM1RSxJQUFJLENBQUNDLFlBQVlDLGNBQWMsR0FBRyxDQUFDLEdBQUdaLDJDQUFjLEVBQUdRLFNBQVNDO0lBQ2hFLElBQUlJLGtCQUFrQixDQUFDLEdBQUdYLHlDQUFZLEVBQUdNLFVBQVVNO0lBQ25ELElBQUlDLGVBQWVQLFVBQVVNO0lBQzVCLElBQUdWLDRDQUFlLEVBQUc7UUFDbEIsSUFBSVksZ0JBQWdCSCxnQkFBZ0JJLE9BQU87UUFDM0MsSUFBSUQsa0JBQWtCRCxjQUFjRyxRQUFRQyxJQUFJLENBQUMsQ0FBQywrQkFBK0IsRUFBRUgsZ0JBQWdCLGVBQWUsZUFBZSxJQUFJLEVBQUVELGVBQWUsZUFBZSxlQUFlLENBQUMsQ0FBQztRQUN0TEYsZ0JBQWdCSSxPQUFPLEdBQUdGO0lBQzlCLEdBQUc7UUFDQ0E7S0FDSDtJQUNELElBQUlLLGVBQWVMLGVBQWVQLFFBQVFHO0lBQzFDLElBQUlVLFdBQVcsQ0FBQyxHQUFHZiw4Q0FBaUIsRUFBRyxDQUFDRSxPQUFPLEdBQUdjO1FBQzlDLElBQUlDLGlCQUFpQixDQUFDZixPQUFPLEdBQUdnQjtZQUM1QixJQUFJZCxVQUFVO2dCQUNWLElBQUksQ0FBQ2UsT0FBT0MsRUFBRSxDQUFDTixjQUFjWixRQUFRRSxTQUFTRixVQUFVZ0I7WUFDNUQ7WUFDQSxJQUFJLENBQUNULGNBQ0wsZ0ZBQWdGO1lBQ2hGLDhFQUE4RTtZQUM5RSx5RkFBeUY7WUFDekYsdURBQXVEO1lBQ3ZESyxlQUFlWjtRQUNuQjtRQUNBLElBQUksT0FBT0EsVUFBVSxZQUFZO1lBQzdCVSxRQUFRQyxJQUFJLENBQUM7WUFDYixvR0FBb0c7WUFDcEcseUVBQXlFO1lBQ3pFLGtJQUFrSTtZQUNsSSxpS0FBaUs7WUFDaksseUlBQXlJO1lBQ3pJLElBQUlRLGlCQUFpQixDQUFDQyxVQUFVLEdBQUdDO2dCQUMvQixJQUFJQyxtQkFBbUJ0QixNQUFNTyxlQUFlSyxlQUFlUSxhQUFhQztnQkFDeEVOLGVBQWVPLHFCQUFxQlI7Z0JBQ3BDLElBQUksQ0FBQ1AsY0FBYyxPQUFPZTtnQkFDMUIsT0FBT0Y7WUFDWDtZQUNBaEIsY0FBY2U7UUFDbEIsT0FBTztZQUNILElBQUksQ0FBQ1osY0FBY0gsY0FBY0o7WUFDakNlLGVBQWVmLFVBQVVjO1FBQzdCO0lBQ0osR0FBRztRQUNDUDtRQUNBSztRQUNBVjtLQUNIO0lBQ0QsT0FBTztRQUNIVTtRQUNBQztLQUNIO0FBQ0w7QUFHQTs7Ozs7Ozs7OztDQVVDLEdBQUc7O0NBRUgsR0FBRyxTQUFTVSwwQ0FBMEN2QixLQUFLLEVBQUV3QixNQUFNLENBQUNDLFFBQVEsRUFBRUMsTUFBTUQsUUFBUTtJQUN6RixJQUFJRSxXQUFXQyxLQUFLSixHQUFHLENBQUNJLEtBQUtGLEdBQUcsQ0FBQzFCLE9BQU93QixNQUFNRTtJQUM5QyxPQUFPQztBQUNYO0FBQ0EsU0FBU0UsMENBQTBDN0IsS0FBSyxFQUFFd0IsR0FBRyxFQUFFRSxHQUFHLEVBQUVJLElBQUk7SUFDcEVOLE1BQU1PLE9BQU9QO0lBQ2JFLE1BQU1LLE9BQU9MO0lBQ2IsSUFBSU0sWUFBWSxDQUFDaEMsUUFBU2lDLENBQUFBLE1BQU1ULE9BQU8sSUFBSUEsR0FBRSxDQUFDLElBQUtNO0lBQ25ELElBQUlJLGVBQWVOLEtBQUtPLEdBQUcsQ0FBQ0gsYUFBYSxLQUFLRixPQUFPOUIsUUFBUTRCLEtBQUtRLElBQUksQ0FBQ0osYUFBY0YsQ0FBQUEsT0FBT0YsS0FBS08sR0FBRyxDQUFDSCxVQUFTLElBQUtoQyxRQUFRZ0M7SUFDM0gsSUFBSSxDQUFDQyxNQUFNVCxNQUFNO1FBQ2IsSUFBSVUsZUFBZVYsS0FBS1UsZUFBZVY7YUFDbEMsSUFBSSxDQUFDUyxNQUFNUCxRQUFRUSxlQUFlUixLQUFLUSxlQUFlVixNQUFNSSxLQUFLUyxLQUFLLENBQUMsQ0FBQ1gsTUFBTUYsR0FBRSxJQUFLTSxRQUFRQTtJQUN0RyxPQUFPLElBQUksQ0FBQ0csTUFBTVAsUUFBUVEsZUFBZVIsS0FBS1EsZUFBZU4sS0FBS1MsS0FBSyxDQUFDWCxNQUFNSSxRQUFRQTtJQUN0RixnRUFBZ0U7SUFDaEUsSUFBSVEsU0FBU1IsS0FBS1MsUUFBUTtJQUMxQixJQUFJQyxRQUFRRixPQUFPRyxPQUFPLENBQUM7SUFDM0IsSUFBSUMsWUFBWUYsU0FBUyxJQUFJRixPQUFPSyxNQUFNLEdBQUdILFFBQVE7SUFDckQsSUFBSUUsWUFBWSxHQUFHO1FBQ2YsSUFBSUUsTUFBTWhCLEtBQUtnQixHQUFHLENBQUMsSUFBSUY7UUFDdkJSLGVBQWVOLEtBQUtpQixLQUFLLENBQUNYLGVBQWVVLE9BQU9BO0lBQ3BEO0lBQ0EsT0FBT1Y7QUFDWDtBQUNBLFNBQVNZLHlDQUF5QzlDLEtBQUssRUFBRStDLE1BQU0sRUFBRUMsT0FBTyxFQUFFO0lBQ3RFLE1BQU1KLE1BQU1oQixLQUFLZ0IsR0FBRyxDQUFDSSxNQUFNRDtJQUMzQixPQUFPbkIsS0FBS2lCLEtBQUssQ0FBQzdDLFFBQVE0QyxPQUFPQTtBQUNyQztBQUtzUCxDQUN0UCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWR1c2EtbmV4dC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9kYXRlcGlja2VyL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS91dGlscy9kaXN0L2ltcG9ydC5tanM/ODg5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZVN0YXRlIGFzICQ2aW11aCR1c2VTdGF0ZSwgdXNlUmVmIGFzICQ2aW11aCR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkNmltdWgkdXNlRWZmZWN0LCB1c2VDYWxsYmFjayBhcyAkNmltdWgkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDQ1OGIwYTU1MzZjMWE3Y2YkZXhwb3J0JDQwYmZhOGM3YjA4MzI3MTUodmFsdWUsIGRlZmF1bHRWYWx1ZSwgb25DaGFuZ2UpIHtcbiAgICBsZXQgW3N0YXRlVmFsdWUsIHNldFN0YXRlVmFsdWVdID0gKDAsICQ2aW11aCR1c2VTdGF0ZSkodmFsdWUgfHwgZGVmYXVsdFZhbHVlKTtcbiAgICBsZXQgaXNDb250cm9sbGVkUmVmID0gKDAsICQ2aW11aCR1c2VSZWYpKHZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgIGxldCBpc0NvbnRyb2xsZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICgwLCAkNmltdWgkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgd2FzQ29udHJvbGxlZCA9IGlzQ29udHJvbGxlZFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAod2FzQ29udHJvbGxlZCAhPT0gaXNDb250cm9sbGVkKSBjb25zb2xlLndhcm4oYFdBUk46IEEgY29tcG9uZW50IGNoYW5nZWQgZnJvbSAke3dhc0NvbnRyb2xsZWQgPyBcImNvbnRyb2xsZWRcIiA6IFwidW5jb250cm9sbGVkXCJ9IHRvICR7aXNDb250cm9sbGVkID8gXCJjb250cm9sbGVkXCIgOiBcInVuY29udHJvbGxlZFwifS5gKTtcbiAgICAgICAgaXNDb250cm9sbGVkUmVmLmN1cnJlbnQgPSBpc0NvbnRyb2xsZWQ7XG4gICAgfSwgW1xuICAgICAgICBpc0NvbnRyb2xsZWRcbiAgICBdKTtcbiAgICBsZXQgY3VycmVudFZhbHVlID0gaXNDb250cm9sbGVkID8gdmFsdWUgOiBzdGF0ZVZhbHVlO1xuICAgIGxldCBzZXRWYWx1ZSA9ICgwLCAkNmltdWgkdXNlQ2FsbGJhY2spKCh2YWx1ZSwgLi4uYXJncyk9PntcbiAgICAgICAgbGV0IG9uQ2hhbmdlQ2FsbGVyID0gKHZhbHVlLCAuLi5vbkNoYW5nZUFyZ3MpPT57XG4gICAgICAgICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5pcyhjdXJyZW50VmFsdWUsIHZhbHVlKSkgb25DaGFuZ2UodmFsdWUsIC4uLm9uQ2hhbmdlQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxlZCkgLy8gSWYgdW5jb250cm9sbGVkLCBtdXRhdGUgdGhlIGN1cnJlbnRWYWx1ZSBsb2NhbCB2YXJpYWJsZSBzbyB0aGF0XG4gICAgICAgICAgICAvLyBjYWxsaW5nIHNldFN0YXRlIG11bHRpcGxlIHRpbWVzIHdpdGggdGhlIHNhbWUgdmFsdWUgb25seSBlbWl0cyBvbkNoYW5nZSBvbmNlLlxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHVzZSBhIHJlZiBmb3IgdGhpcyBiZWNhdXNlIHdlIHNwZWNpZmljYWxseSBfZG9fIHdhbnQgdGhlIHZhbHVlIHRvXG4gICAgICAgICAgICAvLyByZXNldCBldmVyeSByZW5kZXIsIGFuZCBhc3NpZ25pbmcgdG8gYSByZWYgaW4gcmVuZGVyIGJyZWFrcyBhYm9ydGVkIHN1c3BlbmRlZCByZW5kZXJzLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV2UgY2FuIG5vdCBzdXBwb3J0IGEgZnVuY3Rpb24gY2FsbGJhY2suIFNlZSBHaXRodWIgSXNzdWVzIGZvciBkZXRhaWxzIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9pc3N1ZXMvMjMyMFwiKTtcbiAgICAgICAgICAgIC8vIHRoaXMgc3VwcG9ydHMgZnVuY3Rpb25hbCB1cGRhdGVzIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ob29rcy1yZWZlcmVuY2UuaHRtbCNmdW5jdGlvbmFsLXVwZGF0ZXNcbiAgICAgICAgICAgIC8vIHdoZW4gc29tZW9uZSB1c2luZyB1c2VDb250cm9sbGVkU3RhdGUgY2FsbHMgc2V0Q29udHJvbGxlZFN0YXRlKG15RnVuYylcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBjYWxsIG91ciB1c2VTdGF0ZSBzZXRTdGF0ZSB3aXRoIGEgZnVuY3Rpb24gYXMgd2VsbCB3aGljaCBpbnZva2VzIG15RnVuYyBhbmQgY2FsbHMgb25DaGFuZ2Ugd2l0aCB0aGUgdmFsdWUgZnJvbSBteUZ1bmNcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGluIGFuIHVuY29udHJvbGxlZCBzdGF0ZSwgdGhlbiB3ZSBhbHNvIHJldHVybiB0aGUgdmFsdWUgb2YgbXlGdW5jIHdoaWNoIHRvIHNldFN0YXRlIGxvb2tzIGFzIHRob3VnaCBpdCB3YXMganVzdCBjYWxsZWQgd2l0aCBteUZ1bmMgZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UganVzdCByZXR1cm4gdGhlIGNvbnRyb2xsZWQgdmFsdWUsIHdoaWNoIHdvbid0IGNhdXNlIGEgcmVyZW5kZXIgYmVjYXVzZSBSZWFjdCBrbm93cyB0byBiYWlsIG91dCB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgICAgICAgbGV0IHVwZGF0ZUZ1bmN0aW9uID0gKG9sZFZhbHVlLCAuLi5mdW5jdGlvbkFyZ3MpPT57XG4gICAgICAgICAgICAgICAgbGV0IGludGVyY2VwdGVkVmFsdWUgPSB2YWx1ZShpc0NvbnRyb2xsZWQgPyBjdXJyZW50VmFsdWUgOiBvbGRWYWx1ZSwgLi4uZnVuY3Rpb25BcmdzKTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZUNhbGxlcihpbnRlcmNlcHRlZFZhbHVlLCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxlZCkgcmV0dXJuIGludGVyY2VwdGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldFN0YXRlVmFsdWUodXBkYXRlRnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWQpIHNldFN0YXRlVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgb25DaGFuZ2VDYWxsZXIodmFsdWUsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc0NvbnRyb2xsZWQsXG4gICAgICAgIGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgb25DaGFuZ2VcbiAgICBdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjdXJyZW50VmFsdWUsXG4gICAgICAgIHNldFZhbHVlXG4gICAgXTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLyoqXG4gKiBUYWtlcyBhIHZhbHVlIGFuZCBmb3JjZXMgaXQgdG8gdGhlIGNsb3Nlc3QgbWluL21heCBpZiBpdCdzIG91dHNpZGUuIEFsc28gZm9yY2VzIGl0IHRvIHRoZSBjbG9zZXN0IHZhbGlkIHN0ZXAuXG4gKi8gZnVuY3Rpb24gJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JDdkMTViNjRjZjVhM2E0YzQodmFsdWUsIG1pbiA9IC1JbmZpbml0eSwgbWF4ID0gSW5maW5pdHkpIHtcbiAgICBsZXQgbmV3VmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbiAgICByZXR1cm4gbmV3VmFsdWU7XG59XG5mdW5jdGlvbiAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkY2I2ZTBiYjUwYmMxOTQ2Myh2YWx1ZSwgbWluLCBtYXgsIHN0ZXApIHtcbiAgICBtaW4gPSBOdW1iZXIobWluKTtcbiAgICBtYXggPSBOdW1iZXIobWF4KTtcbiAgICBsZXQgcmVtYWluZGVyID0gKHZhbHVlIC0gKGlzTmFOKG1pbikgPyAwIDogbWluKSkgJSBzdGVwO1xuICAgIGxldCBzbmFwcGVkVmFsdWUgPSBNYXRoLmFicyhyZW1haW5kZXIpICogMiA+PSBzdGVwID8gdmFsdWUgKyBNYXRoLnNpZ24ocmVtYWluZGVyKSAqIChzdGVwIC0gTWF0aC5hYnMocmVtYWluZGVyKSkgOiB2YWx1ZSAtIHJlbWFpbmRlcjtcbiAgICBpZiAoIWlzTmFOKG1pbikpIHtcbiAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZSA8IG1pbikgc25hcHBlZFZhbHVlID0gbWluO1xuICAgICAgICBlbHNlIGlmICghaXNOYU4obWF4KSAmJiBzbmFwcGVkVmFsdWUgPiBtYXgpIHNuYXBwZWRWYWx1ZSA9IG1pbiArIE1hdGguZmxvb3IoKG1heCAtIG1pbikgLyBzdGVwKSAqIHN0ZXA7XG4gICAgfSBlbHNlIGlmICghaXNOYU4obWF4KSAmJiBzbmFwcGVkVmFsdWUgPiBtYXgpIHNuYXBwZWRWYWx1ZSA9IE1hdGguZmxvb3IobWF4IC8gc3RlcCkgKiBzdGVwO1xuICAgIC8vIGNvcnJlY3QgZmxvYXRpbmcgcG9pbnQgYmVoYXZpb3IgYnkgcm91bmRpbmcgdG8gc3RlcCBwcmVjaXNpb25cbiAgICBsZXQgc3RyaW5nID0gc3RlcC50b1N0cmluZygpO1xuICAgIGxldCBpbmRleCA9IHN0cmluZy5pbmRleE9mKFwiLlwiKTtcbiAgICBsZXQgcHJlY2lzaW9uID0gaW5kZXggPj0gMCA/IHN0cmluZy5sZW5ndGggLSBpbmRleCA6IDA7XG4gICAgaWYgKHByZWNpc2lvbiA+IDApIHtcbiAgICAgICAgbGV0IHBvdyA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgICAgICBzbmFwcGVkVmFsdWUgPSBNYXRoLnJvdW5kKHNuYXBwZWRWYWx1ZSAqIHBvdykgLyBwb3c7XG4gICAgfVxuICAgIHJldHVybiBzbmFwcGVkVmFsdWU7XG59XG5mdW5jdGlvbiAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkYjYyNjg1NTRmYmE0NTFmKHZhbHVlLCBkaWdpdHMsIGJhc2UgPSAxMCkge1xuICAgIGNvbnN0IHBvdyA9IE1hdGgucG93KGJhc2UsIGRpZ2l0cyk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwb3cpIC8gcG93O1xufVxuXG5cblxuXG5leHBvcnQgeyQ0NThiMGE1NTM2YzFhN2NmJGV4cG9ydCQ0MGJmYThjN2IwODMyNzE1IGFzIHVzZUNvbnRyb2xsZWRTdGF0ZSwgJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JDdkMTViNjRjZjVhM2E0YzQgYXMgY2xhbXAsICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRjYjZlMGJiNTBiYzE5NDYzIGFzIHNuYXBWYWx1ZVRvU3RlcCwgJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGI2MjY4NTU0ZmJhNDUxZiBhcyB0b0ZpeGVkTnVtYmVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsIiQ2aW11aCR1c2VTdGF0ZSIsInVzZVJlZiIsIiQ2aW11aCR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkNmltdWgkdXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCIkNmltdWgkdXNlQ2FsbGJhY2siLCIkNDU4YjBhNTUzNmMxYTdjZiRleHBvcnQkNDBiZmE4YzdiMDgzMjcxNSIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwib25DaGFuZ2UiLCJzdGF0ZVZhbHVlIiwic2V0U3RhdGVWYWx1ZSIsImlzQ29udHJvbGxlZFJlZiIsInVuZGVmaW5lZCIsImlzQ29udHJvbGxlZCIsIndhc0NvbnRyb2xsZWQiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJjdXJyZW50VmFsdWUiLCJzZXRWYWx1ZSIsImFyZ3MiLCJvbkNoYW5nZUNhbGxlciIsIm9uQ2hhbmdlQXJncyIsIk9iamVjdCIsImlzIiwidXBkYXRlRnVuY3Rpb24iLCJvbGRWYWx1ZSIsImZ1bmN0aW9uQXJncyIsImludGVyY2VwdGVkVmFsdWUiLCIkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkN2QxNWI2NGNmNWEzYTRjNCIsIm1pbiIsIkluZmluaXR5IiwibWF4IiwibmV3VmFsdWUiLCJNYXRoIiwiJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGNiNmUwYmI1MGJjMTk0NjMiLCJzdGVwIiwiTnVtYmVyIiwicmVtYWluZGVyIiwiaXNOYU4iLCJzbmFwcGVkVmFsdWUiLCJhYnMiLCJzaWduIiwiZmxvb3IiLCJzdHJpbmciLCJ0b1N0cmluZyIsImluZGV4IiwiaW5kZXhPZiIsInByZWNpc2lvbiIsImxlbmd0aCIsInBvdyIsInJvdW5kIiwiJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGI2MjY4NTU0ZmJhNDUxZiIsImRpZ2l0cyIsImJhc2UiLCJ1c2VDb250cm9sbGVkU3RhdGUiLCJjbGFtcCIsInNuYXBWYWx1ZVRvU3RlcCIsInRvRml4ZWROdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/datepicker/node_modules/@react-stately/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/flags/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/flags/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enableTableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$d9d8a0f82de49530),\n/* harmony export */   tableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$1b00cb14a96194e6)\n/* harmony export */ });\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $f4e2df6bd15f8569$var$_tableNestedRows = false;\nfunction $f4e2df6bd15f8569$export$d9d8a0f82de49530() {\n    $f4e2df6bd15f8569$var$_tableNestedRows = true;\n}\nfunction $f4e2df6bd15f8569$export$1b00cb14a96194e6() {\n    return $f4e2df6bd15f8569$var$_tableNestedRows;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZmxhZ3MvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLElBQUlBLHlDQUF5QztBQUNqRCxTQUFTQztJQUNMRCx5Q0FBeUM7QUFDN0M7QUFDQSxTQUFTRTtJQUNMLE9BQU9GO0FBQ1g7QUFHMEksQ0FDMUksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZmxhZ3MvZGlzdC9pbXBvcnQubWpzP2E4MDAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGxldCAkZjRlMmRmNmJkMTVmODU2OSR2YXIkX3RhYmxlTmVzdGVkUm93cyA9IGZhbHNlO1xuZnVuY3Rpb24gJGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JGQ5ZDhhMGY4MmRlNDk1MzAoKSB7XG4gICAgJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF90YWJsZU5lc3RlZFJvd3MgPSB0cnVlO1xufVxuZnVuY3Rpb24gJGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JDFiMDBjYjE0YTk2MTk0ZTYoKSB7XG4gICAgcmV0dXJuICRmNGUyZGY2YmQxNWY4NTY5JHZhciRfdGFibGVOZXN0ZWRSb3dzO1xufVxuXG5cbmV4cG9ydCB7JGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JGQ5ZDhhMGY4MmRlNDk1MzAgYXMgZW5hYmxlVGFibGVOZXN0ZWRSb3dzLCAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkMWIwMGNiMTRhOTYxOTRlNiBhcyB0YWJsZU5lc3RlZFJvd3N9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbIiRmNGUyZGY2YmQxNWY4NTY5JHZhciRfdGFibGVOZXN0ZWRSb3dzIiwiJGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JGQ5ZDhhMGY4MmRlNDk1MzAiLCIkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkMWIwMGNiMTRhOTYxOTRlNiIsImVuYWJsZVRhYmxlTmVzdGVkUm93cyIsInRhYmxlTmVzdGVkUm93cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/form/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/form/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_VALIDATION_RESULT: () => (/* binding */ $e5be200c675c3b3a$export$dad6ae84456c676a),\n/* harmony export */   FormValidationContext: () => (/* binding */ $e5be200c675c3b3a$export$571b5131b7e65c11),\n/* harmony export */   VALID_VALIDITY_STATE: () => (/* binding */ $e5be200c675c3b3a$export$aca958c65c314e6c),\n/* harmony export */   mergeValidation: () => (/* binding */ $e5be200c675c3b3a$export$75ee7c75d68f5b0e),\n/* harmony export */   privateValidationStateProp: () => (/* binding */ $e5be200c675c3b3a$export$a763b9476acd3eb),\n/* harmony export */   useFormValidationState: () => (/* binding */ $e5be200c675c3b3a$export$fc1a364ae1f3ff10)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $e5be200c675c3b3a$export$aca958c65c314e6c = {\n    badInput: false,\n    customError: false,\n    patternMismatch: false,\n    rangeOverflow: false,\n    rangeUnderflow: false,\n    stepMismatch: false,\n    tooLong: false,\n    tooShort: false,\n    typeMismatch: false,\n    valueMissing: false,\n    valid: true\n};\nconst $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE = {\n    ...$e5be200c675c3b3a$export$aca958c65c314e6c,\n    customError: true,\n    valid: false\n};\nconst $e5be200c675c3b3a$export$dad6ae84456c676a = {\n    isInvalid: false,\n    validationDetails: $e5be200c675c3b3a$export$aca958c65c314e6c,\n    validationErrors: []\n};\nconst $e5be200c675c3b3a$export$571b5131b7e65c11 = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nconst $e5be200c675c3b3a$export$a763b9476acd3eb = \"__formValidationState\" + Date.now();\nfunction $e5be200c675c3b3a$export$fc1a364ae1f3ff10(props) {\n    // Private prop for parent components to pass state to children.\n    if (props[$e5be200c675c3b3a$export$a763b9476acd3eb]) {\n        let { realtimeValidation: realtimeValidation, displayValidation: displayValidation, updateValidation: updateValidation, resetValidation: resetValidation, commitValidation: commitValidation } = props[$e5be200c675c3b3a$export$a763b9476acd3eb];\n        return {\n            realtimeValidation: realtimeValidation,\n            displayValidation: displayValidation,\n            updateValidation: updateValidation,\n            resetValidation: resetValidation,\n            commitValidation: commitValidation\n        };\n    }\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return $e5be200c675c3b3a$var$useFormValidationStateImpl(props);\n}\nfunction $e5be200c675c3b3a$var$useFormValidationStateImpl(props) {\n    let { isInvalid: isInvalid, validationState: validationState, name: name, value: value, builtinValidation: builtinValidation, validate: validate, validationBehavior: validationBehavior = \"aria\" } = props;\n    // backward compatibility.\n    if (validationState) isInvalid || (isInvalid = validationState === \"invalid\");\n    // If the isInvalid prop is true, update validation result in realtime (controlled).\n    let controlledError = isInvalid ? {\n        isInvalid: true,\n        validationErrors: [],\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n    // Perform custom client side validation.\n    let clientError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult($e5be200c675c3b3a$var$runValidate(validate, value)), [\n        validate,\n        value\n    ]);\n    if (builtinValidation === null || builtinValidation === void 0 ? void 0 : builtinValidation.validationDetails.valid) builtinValidation = null;\n    // Get relevant server errors from the form.\n    let serverErrors = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($e5be200c675c3b3a$export$571b5131b7e65c11);\n    let serverErrorMessages = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (name) return Array.isArray(name) ? name.flatMap((name)=>$e5be200c675c3b3a$var$asArray(serverErrors[name])) : $e5be200c675c3b3a$var$asArray(serverErrors[name]);\n        return [];\n    }, [\n        serverErrors,\n        name\n    ]);\n    // Show server errors when the form gets a new value, and clear when the user changes the value.\n    let [lastServerErrors, setLastServerErrors] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(serverErrors);\n    let [isServerErrorCleared, setServerErrorCleared] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    if (serverErrors !== lastServerErrors) {\n        setLastServerErrors(serverErrors);\n        setServerErrorCleared(false);\n    }\n    let serverError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult(isServerErrorCleared ? [] : serverErrorMessages), [\n        isServerErrorCleared,\n        serverErrorMessages\n    ]);\n    // Track the next validation state in a ref until commitValidation is called.\n    let nextValidation = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let [currentValidity, setCurrentValidity] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let lastError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let commitValidation = ()=>{\n        if (!commitQueued) return;\n        setCommitQueued(false);\n        let error = clientError || builtinValidation || nextValidation.current;\n        if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n            lastError.current = error;\n            setCurrentValidity(error);\n        }\n    };\n    let [commitQueued, setCommitQueued] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(commitValidation);\n    // realtimeValidation is used to update the native input element's state based on custom validation logic.\n    // displayValidation is the currently displayed validation state that the user sees (e.g. on input change/form submit).\n    // With validationBehavior=\"aria\", all errors are displayed in realtime rather than on submit.\n    let realtimeValidation = controlledError || serverError || clientError || builtinValidation || $e5be200c675c3b3a$export$dad6ae84456c676a;\n    let displayValidation = validationBehavior === \"native\" ? controlledError || serverError || currentValidity : controlledError || serverError || clientError || builtinValidation || currentValidity;\n    return {\n        realtimeValidation: realtimeValidation,\n        displayValidation: displayValidation,\n        updateValidation (value) {\n            // If validationBehavior is 'aria', update in realtime. Otherwise, store in a ref until commit.\n            if (validationBehavior === \"aria\" && !$e5be200c675c3b3a$var$isEqualValidation(currentValidity, value)) setCurrentValidity(value);\n            else nextValidation.current = value;\n        },\n        resetValidation () {\n            // Update the currently displayed validation state to valid on form reset,\n            // even if the native validity says it isn't. It'll show again on the next form submit.\n            let error = $e5be200c675c3b3a$export$dad6ae84456c676a;\n            if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n                lastError.current = error;\n                setCurrentValidity(error);\n            }\n            // Do not commit validation after the next render. This avoids a condition where\n            // useSelect calls commitValidation inside an onReset handler.\n            if (validationBehavior === \"native\") setCommitQueued(false);\n            setServerErrorCleared(true);\n        },\n        commitValidation () {\n            // Commit validation state so the user sees it on blur/change/submit. Also clear any server errors.\n            // Wait until after the next render to commit so that the latest value has been validated.\n            if (validationBehavior === \"native\") setCommitQueued(true);\n            setServerErrorCleared(true);\n        }\n    };\n}\nfunction $e5be200c675c3b3a$var$asArray(v) {\n    if (!v) return [];\n    return Array.isArray(v) ? v : [\n        v\n    ];\n}\nfunction $e5be200c675c3b3a$var$runValidate(validate, value) {\n    if (typeof validate === \"function\") {\n        let e = validate(value);\n        if (e && typeof e !== \"boolean\") return $e5be200c675c3b3a$var$asArray(e);\n    }\n    return [];\n}\nfunction $e5be200c675c3b3a$var$getValidationResult(errors) {\n    return errors.length ? {\n        isInvalid: true,\n        validationErrors: errors,\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n}\nfunction $e5be200c675c3b3a$var$isEqualValidation(a, b) {\n    if (a === b) return true;\n    return a && b && a.isInvalid === b.isInvalid && a.validationErrors.length === b.validationErrors.length && a.validationErrors.every((a, i)=>a === b.validationErrors[i]) && Object.entries(a.validationDetails).every(([k, v])=>b.validationDetails[k] === v);\n}\nfunction $e5be200c675c3b3a$export$75ee7c75d68f5b0e(...results) {\n    let errors = new Set();\n    let isInvalid = false;\n    let validationDetails = {\n        ...$e5be200c675c3b3a$export$aca958c65c314e6c\n    };\n    for (let v of results){\n        var _validationDetails, _key;\n        for (let e of v.validationErrors)errors.add(e);\n        // Only these properties apply for checkboxes.\n        isInvalid || (isInvalid = v.isInvalid);\n        for(let key in validationDetails)(_validationDetails = validationDetails)[_key = key] || (_validationDetails[_key] = v.validationDetails[key]);\n    }\n    validationDetails.valid = !isInvalid;\n    return {\n        isInvalid: isInvalid,\n        validationErrors: [\n            ...errors\n        ],\n        validationDetails: validationDetails\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZm9ybS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2TTtBQUU3TTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNELE1BQU1ZLDRDQUE0QztJQUM5Q0MsVUFBVTtJQUNWQyxhQUFhO0lBQ2JDLGlCQUFpQjtJQUNqQkMsZUFBZTtJQUNmQyxnQkFBZ0I7SUFDaEJDLGNBQWM7SUFDZEMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxPQUFPO0FBQ1g7QUFDQSxNQUFNQyw4Q0FBOEM7SUFDaEQsR0FBR1oseUNBQXlDO0lBQzVDRSxhQUFhO0lBQ2JTLE9BQU87QUFDWDtBQUNBLE1BQU1FLDRDQUE0QztJQUM5Q0MsV0FBVztJQUNYQyxtQkFBbUJmO0lBQ25CZ0Isa0JBQWtCLEVBQUU7QUFDeEI7QUFDQSxNQUFNQyw0Q0FBNEMsQ0FBQyxHQUFHNUIsZ0RBQW1CLEVBQUcsQ0FBQztBQUM3RSxNQUFNNkIsMkNBQTJDLDBCQUEwQkMsS0FBS0MsR0FBRztBQUNuRixTQUFTQywwQ0FBMENDLEtBQUs7SUFDcEQsZ0VBQWdFO0lBQ2hFLElBQUlBLEtBQUssQ0FBQ0oseUNBQXlDLEVBQUU7UUFDakQsSUFBSSxFQUFFSyxvQkFBb0JBLGtCQUFrQixFQUFFQyxtQkFBbUJBLGlCQUFpQixFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFQyxpQkFBaUJBLGVBQWUsRUFBRUMsa0JBQWtCQSxnQkFBZ0IsRUFBRSxHQUFHTCxLQUFLLENBQUNKLHlDQUF5QztRQUNoUCxPQUFPO1lBQ0hLLG9CQUFvQkE7WUFDcEJDLG1CQUFtQkE7WUFDbkJDLGtCQUFrQkE7WUFDbEJDLGlCQUFpQkE7WUFDakJDLGtCQUFrQkE7UUFDdEI7SUFDSjtJQUNBLHNEQUFzRDtJQUN0RCxPQUFPQyxpREFBaUROO0FBQzVEO0FBQ0EsU0FBU00saURBQWlETixLQUFLO0lBQzNELElB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LGdCQUFnQixDQUFDOEMsTUFBTSxLQUFLRSxFQUFFaEQsZ0JBQWdCLENBQUM4QyxNQUFNLElBQUlDLEVBQUUvQyxnQkFBZ0IsQ0FBQ2lELEtBQUssQ0FBQyxDQUFDRixHQUFHRyxJQUFJSCxNQUFNQyxFQUFFaEQsZ0JBQWdCLENBQUNrRCxFQUFFLEtBQUtDLE9BQU9DLE9BQU8sQ0FBQ0wsRUFBRWhELGlCQUFpQixFQUFFa0QsS0FBSyxDQUFDLENBQUMsQ0FBQ0ksR0FBR1YsRUFBRSxHQUFHSyxFQUFFakQsaUJBQWlCLENBQUNzRCxFQUFFLEtBQUtWO0FBQy9QO0FBQ0EsU0FBU1csMENBQTBDLEdBQUdDLE9BQU87SUFDekQsSUFBSVYsU0FBUyxJQUFJVztJQUNqQixJQUFJMUQsWUFBWTtJQUNoQixJQUFJQyxvQkFBb0I7UUFDcEIsR0FBR2YseUNBQXlDO0lBQ2hEO0lBQ0EsS0FBSyxJQUFJMkQsS0FBS1ksUUFBUTtRQUNsQixJQUFJRSxvQkFBb0JDO1FBQ3hCLEtBQUssSUFBSWQsS0FBS0QsRUFBRTNDLGdCQUFnQixDQUFDNkMsT0FBT2MsR0FBRyxDQUFDZjtRQUM1Qyw4Q0FBOEM7UUFDOUM5QyxhQUFjQSxDQUFBQSxZQUFZNkMsRUFBRTdDLFNBQVM7UUFDckMsSUFBSSxJQUFJOEQsT0FBTzdELGtCQUFrQixDQUFDMEQscUJBQXFCMUQsaUJBQWdCLENBQUUsQ0FBQzJELE9BQU9FLElBQUksSUFBS0gsQ0FBQUEsa0JBQWtCLENBQUNDLEtBQUssR0FBR2YsRUFBRTVDLGlCQUFpQixDQUFDNkQsSUFBSTtJQUNqSjtJQUNBN0Qsa0JBQWtCSixLQUFLLEdBQUcsQ0FBQ0c7SUFDM0IsT0FBTztRQUNIQSxXQUFXQTtRQUNYRSxrQkFBa0I7ZUFDWDZDO1NBQ047UUFDRDlDLG1CQUFtQkE7SUFDdkI7QUFDSjtBQUtrYSxDQUNsYSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWR1c2EtbmV4dC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9mb3JtL2Rpc3QvaW1wb3J0Lm1qcz9mNTAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3JlYXRlQ29udGV4dCBhcyAkamNJT3ckY3JlYXRlQ29udGV4dCwgdXNlTWVtbyBhcyAkamNJT3ckdXNlTWVtbywgdXNlQ29udGV4dCBhcyAkamNJT3ckdXNlQ29udGV4dCwgdXNlU3RhdGUgYXMgJGpjSU93JHVzZVN0YXRlLCB1c2VSZWYgYXMgJGpjSU93JHVzZVJlZiwgdXNlRWZmZWN0IGFzICRqY0lPdyR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY29uc3QgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmMgPSB7XG4gICAgYmFkSW5wdXQ6IGZhbHNlLFxuICAgIGN1c3RvbUVycm9yOiBmYWxzZSxcbiAgICBwYXR0ZXJuTWlzbWF0Y2g6IGZhbHNlLFxuICAgIHJhbmdlT3ZlcmZsb3c6IGZhbHNlLFxuICAgIHJhbmdlVW5kZXJmbG93OiBmYWxzZSxcbiAgICBzdGVwTWlzbWF0Y2g6IGZhbHNlLFxuICAgIHRvb0xvbmc6IGZhbHNlLFxuICAgIHRvb1Nob3J0OiBmYWxzZSxcbiAgICB0eXBlTWlzbWF0Y2g6IGZhbHNlLFxuICAgIHZhbHVlTWlzc2luZzogZmFsc2UsXG4gICAgdmFsaWQ6IHRydWVcbn07XG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSR2YXIkQ1VTVE9NX1ZBTElESVRZX1NUQVRFID0ge1xuICAgIC4uLiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjLFxuICAgIGN1c3RvbUVycm9yOiB0cnVlLFxuICAgIHZhbGlkOiBmYWxzZVxufTtcbmNvbnN0ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhID0ge1xuICAgIGlzSW52YWxpZDogZmFsc2UsXG4gICAgdmFsaWRhdGlvbkRldGFpbHM6ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjLFxuICAgIHZhbGlkYXRpb25FcnJvcnM6IFtdXG59O1xuY29uc3QgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDU3MWI1MTMxYjdlNjVjMTEgPSAoMCwgJGpjSU93JGNyZWF0ZUNvbnRleHQpKHt9KTtcbmNvbnN0ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhNzYzYjk0NzZhY2QzZWIgPSBcIl9fZm9ybVZhbGlkYXRpb25TdGF0ZVwiICsgRGF0ZS5ub3coKTtcbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRmYzFhMzY0YWUxZjNmZjEwKHByb3BzKSB7XG4gICAgLy8gUHJpdmF0ZSBwcm9wIGZvciBwYXJlbnQgY29tcG9uZW50cyB0byBwYXNzIHN0YXRlIHRvIGNoaWxkcmVuLlxuICAgIGlmIChwcm9wc1skZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYTc2M2I5NDc2YWNkM2ViXSkge1xuICAgICAgICBsZXQgeyByZWFsdGltZVZhbGlkYXRpb246IHJlYWx0aW1lVmFsaWRhdGlvbiwgZGlzcGxheVZhbGlkYXRpb246IGRpc3BsYXlWYWxpZGF0aW9uLCB1cGRhdGVWYWxpZGF0aW9uOiB1cGRhdGVWYWxpZGF0aW9uLCByZXNldFZhbGlkYXRpb246IHJlc2V0VmFsaWRhdGlvbiwgY29tbWl0VmFsaWRhdGlvbjogY29tbWl0VmFsaWRhdGlvbiB9ID0gcHJvcHNbJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYl07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFsdGltZVZhbGlkYXRpb246IHJlYWx0aW1lVmFsaWRhdGlvbixcbiAgICAgICAgICAgIGRpc3BsYXlWYWxpZGF0aW9uOiBkaXNwbGF5VmFsaWRhdGlvbixcbiAgICAgICAgICAgIHVwZGF0ZVZhbGlkYXRpb246IHVwZGF0ZVZhbGlkYXRpb24sXG4gICAgICAgICAgICByZXNldFZhbGlkYXRpb246IHJlc2V0VmFsaWRhdGlvbixcbiAgICAgICAgICAgIGNvbW1pdFZhbGlkYXRpb246IGNvbW1pdFZhbGlkYXRpb25cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgcmV0dXJuICRlNWJlMjAwYzY3NWMzYjNhJHZhciR1c2VGb3JtVmFsaWRhdGlvblN0YXRlSW1wbChwcm9wcyk7XG59XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZUltcGwocHJvcHMpIHtcbiAgICBsZXQgeyBpc0ludmFsaWQ6IGlzSW52YWxpZCwgdmFsaWRhdGlvblN0YXRlOiB2YWxpZGF0aW9uU3RhdGUsIG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgYnVpbHRpblZhbGlkYXRpb246IGJ1aWx0aW5WYWxpZGF0aW9uLCB2YWxpZGF0ZTogdmFsaWRhdGUsIHZhbGlkYXRpb25CZWhhdmlvcjogdmFsaWRhdGlvbkJlaGF2aW9yID0gXCJhcmlhXCIgfSA9IHByb3BzO1xuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgaWYgKHZhbGlkYXRpb25TdGF0ZSkgaXNJbnZhbGlkIHx8IChpc0ludmFsaWQgPSB2YWxpZGF0aW9uU3RhdGUgPT09IFwiaW52YWxpZFwiKTtcbiAgICAvLyBJZiB0aGUgaXNJbnZhbGlkIHByb3AgaXMgdHJ1ZSwgdXBkYXRlIHZhbGlkYXRpb24gcmVzdWx0IGluIHJlYWx0aW1lIChjb250cm9sbGVkKS5cbiAgICBsZXQgY29udHJvbGxlZEVycm9yID0gaXNJbnZhbGlkID8ge1xuICAgICAgICBpc0ludmFsaWQ6IHRydWUsXG4gICAgICAgIHZhbGlkYXRpb25FcnJvcnM6IFtdLFxuICAgICAgICB2YWxpZGF0aW9uRGV0YWlsczogJGU1YmUyMDBjNjc1YzNiM2EkdmFyJENVU1RPTV9WQUxJRElUWV9TVEFURVxuICAgIH0gOiBudWxsO1xuICAgIC8vIFBlcmZvcm0gY3VzdG9tIGNsaWVudCBzaWRlIHZhbGlkYXRpb24uXG4gICAgbGV0IGNsaWVudEVycm9yID0gKDAsICRqY0lPdyR1c2VNZW1vKSgoKT0+JGU1YmUyMDBjNjc1YzNiM2EkdmFyJGdldFZhbGlkYXRpb25SZXN1bHQoJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHJ1blZhbGlkYXRlKHZhbGlkYXRlLCB2YWx1ZSkpLCBbXG4gICAgICAgIHZhbGlkYXRlLFxuICAgICAgICB2YWx1ZVxuICAgIF0pO1xuICAgIGlmIChidWlsdGluVmFsaWRhdGlvbiA9PT0gbnVsbCB8fCBidWlsdGluVmFsaWRhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnVpbHRpblZhbGlkYXRpb24udmFsaWRhdGlvbkRldGFpbHMudmFsaWQpIGJ1aWx0aW5WYWxpZGF0aW9uID0gbnVsbDtcbiAgICAvLyBHZXQgcmVsZXZhbnQgc2VydmVyIGVycm9ycyBmcm9tIHRoZSBmb3JtLlxuICAgIGxldCBzZXJ2ZXJFcnJvcnMgPSAoMCwgJGpjSU93JHVzZUNvbnRleHQpKCRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCQ1NzFiNTEzMWI3ZTY1YzExKTtcbiAgICBsZXQgc2VydmVyRXJyb3JNZXNzYWdlcyA9ICgwLCAkamNJT3ckdXNlTWVtbykoKCk9PntcbiAgICAgICAgaWYgKG5hbWUpIHJldHVybiBBcnJheS5pc0FycmF5KG5hbWUpID8gbmFtZS5mbGF0TWFwKChuYW1lKT0+JGU1YmUyMDBjNjc1YzNiM2EkdmFyJGFzQXJyYXkoc2VydmVyRXJyb3JzW25hbWVdKSkgOiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkYXNBcnJheShzZXJ2ZXJFcnJvcnNbbmFtZV0pO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfSwgW1xuICAgICAgICBzZXJ2ZXJFcnJvcnMsXG4gICAgICAgIG5hbWVcbiAgICBdKTtcbiAgICAvLyBTaG93IHNlcnZlciBlcnJvcnMgd2hlbiB0aGUgZm9ybSBnZXRzIGEgbmV3IHZhbHVlLCBhbmQgY2xlYXIgd2hlbiB0aGUgdXNlciBjaGFuZ2VzIHRoZSB2YWx1ZS5cbiAgICBsZXQgW2xhc3RTZXJ2ZXJFcnJvcnMsIHNldExhc3RTZXJ2ZXJFcnJvcnNdID0gKDAsICRqY0lPdyR1c2VTdGF0ZSkoc2VydmVyRXJyb3JzKTtcbiAgICBsZXQgW2lzU2VydmVyRXJyb3JDbGVhcmVkLCBzZXRTZXJ2ZXJFcnJvckNsZWFyZWRdID0gKDAsICRqY0lPdyR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGlmIChzZXJ2ZXJFcnJvcnMgIT09IGxhc3RTZXJ2ZXJFcnJvcnMpIHtcbiAgICAgICAgc2V0TGFzdFNlcnZlckVycm9ycyhzZXJ2ZXJFcnJvcnMpO1xuICAgICAgICBzZXRTZXJ2ZXJFcnJvckNsZWFyZWQoZmFsc2UpO1xuICAgIH1cbiAgICBsZXQgc2VydmVyRXJyb3IgPSAoMCwgJGpjSU93JHVzZU1lbW8pKCgpPT4kZTViZTIwMGM2NzVjM2IzYSR2YXIkZ2V0VmFsaWRhdGlvblJlc3VsdChpc1NlcnZlckVycm9yQ2xlYXJlZCA/IFtdIDogc2VydmVyRXJyb3JNZXNzYWdlcyksIFtcbiAgICAgICAgaXNTZXJ2ZXJFcnJvckNsZWFyZWQsXG4gICAgICAgIHNlcnZlckVycm9yTWVzc2FnZXNcbiAgICBdKTtcbiAgICAvLyBUcmFjayB0aGUgbmV4dCB2YWxpZGF0aW9uIHN0YXRlIGluIGEgcmVmIHVudGlsIGNvbW1pdFZhbGlkYXRpb24gaXMgY2FsbGVkLlxuICAgIGxldCBuZXh0VmFsaWRhdGlvbiA9ICgwLCAkamNJT3ckdXNlUmVmKSgkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSk7XG4gICAgbGV0IFtjdXJyZW50VmFsaWRpdHksIHNldEN1cnJlbnRWYWxpZGl0eV0gPSAoMCwgJGpjSU93JHVzZVN0YXRlKSgkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSk7XG4gICAgbGV0IGxhc3RFcnJvciA9ICgwLCAkamNJT3ckdXNlUmVmKSgkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSk7XG4gICAgbGV0IGNvbW1pdFZhbGlkYXRpb24gPSAoKT0+e1xuICAgICAgICBpZiAoIWNvbW1pdFF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBzZXRDb21taXRRdWV1ZWQoZmFsc2UpO1xuICAgICAgICBsZXQgZXJyb3IgPSBjbGllbnRFcnJvciB8fCBidWlsdGluVmFsaWRhdGlvbiB8fCBuZXh0VmFsaWRhdGlvbi5jdXJyZW50O1xuICAgICAgICBpZiAoISRlNWJlMjAwYzY3NWMzYjNhJHZhciRpc0VxdWFsVmFsaWRhdGlvbihlcnJvciwgbGFzdEVycm9yLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBsYXN0RXJyb3IuY3VycmVudCA9IGVycm9yO1xuICAgICAgICAgICAgc2V0Q3VycmVudFZhbGlkaXR5KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IFtjb21taXRRdWV1ZWQsIHNldENvbW1pdFF1ZXVlZF0gPSAoMCwgJGpjSU93JHVzZVN0YXRlKShmYWxzZSk7XG4gICAgKDAsICRqY0lPdyR1c2VFZmZlY3QpKGNvbW1pdFZhbGlkYXRpb24pO1xuICAgIC8vIHJlYWx0aW1lVmFsaWRhdGlvbiBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQncyBzdGF0ZSBiYXNlZCBvbiBjdXN0b20gdmFsaWRhdGlvbiBsb2dpYy5cbiAgICAvLyBkaXNwbGF5VmFsaWRhdGlvbiBpcyB0aGUgY3VycmVudGx5IGRpc3BsYXllZCB2YWxpZGF0aW9uIHN0YXRlIHRoYXQgdGhlIHVzZXIgc2VlcyAoZS5nLiBvbiBpbnB1dCBjaGFuZ2UvZm9ybSBzdWJtaXQpLlxuICAgIC8vIFdpdGggdmFsaWRhdGlvbkJlaGF2aW9yPVwiYXJpYVwiLCBhbGwgZXJyb3JzIGFyZSBkaXNwbGF5ZWQgaW4gcmVhbHRpbWUgcmF0aGVyIHRoYW4gb24gc3VibWl0LlxuICAgIGxldCByZWFsdGltZVZhbGlkYXRpb24gPSBjb250cm9sbGVkRXJyb3IgfHwgc2VydmVyRXJyb3IgfHwgY2xpZW50RXJyb3IgfHwgYnVpbHRpblZhbGlkYXRpb24gfHwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmE7XG4gICAgbGV0IGRpc3BsYXlWYWxpZGF0aW9uID0gdmFsaWRhdGlvbkJlaGF2aW9yID09PSBcIm5hdGl2ZVwiID8gY29udHJvbGxlZEVycm9yIHx8IHNlcnZlckVycm9yIHx8IGN1cnJlbnRWYWxpZGl0eSA6IGNvbnRyb2xsZWRFcnJvciB8fCBzZXJ2ZXJFcnJvciB8fCBjbGllbnRFcnJvciB8fCBidWlsdGluVmFsaWRhdGlvbiB8fCBjdXJyZW50VmFsaWRpdHk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVhbHRpbWVWYWxpZGF0aW9uOiByZWFsdGltZVZhbGlkYXRpb24sXG4gICAgICAgIGRpc3BsYXlWYWxpZGF0aW9uOiBkaXNwbGF5VmFsaWRhdGlvbixcbiAgICAgICAgdXBkYXRlVmFsaWRhdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElmIHZhbGlkYXRpb25CZWhhdmlvciBpcyAnYXJpYScsIHVwZGF0ZSBpbiByZWFsdGltZS4gT3RoZXJ3aXNlLCBzdG9yZSBpbiBhIHJlZiB1bnRpbCBjb21taXQuXG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkJlaGF2aW9yID09PSBcImFyaWFcIiAmJiAhJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGlzRXF1YWxWYWxpZGF0aW9uKGN1cnJlbnRWYWxpZGl0eSwgdmFsdWUpKSBzZXRDdXJyZW50VmFsaWRpdHkodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBuZXh0VmFsaWRhdGlvbi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0VmFsaWRhdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgdmFsaWRhdGlvbiBzdGF0ZSB0byB2YWxpZCBvbiBmb3JtIHJlc2V0LFxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aGUgbmF0aXZlIHZhbGlkaXR5IHNheXMgaXQgaXNuJ3QuIEl0J2xsIHNob3cgYWdhaW4gb24gdGhlIG5leHQgZm9ybSBzdWJtaXQuXG4gICAgICAgICAgICBsZXQgZXJyb3IgPSAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YTtcbiAgICAgICAgICAgIGlmICghJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGlzRXF1YWxWYWxpZGF0aW9uKGVycm9yLCBsYXN0RXJyb3IuY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IuY3VycmVudCA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRWYWxpZGl0eShlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyBub3QgY29tbWl0IHZhbGlkYXRpb24gYWZ0ZXIgdGhlIG5leHQgcmVuZGVyLiBUaGlzIGF2b2lkcyBhIGNvbmRpdGlvbiB3aGVyZVxuICAgICAgICAgICAgLy8gdXNlU2VsZWN0IGNhbGxzIGNvbW1pdFZhbGlkYXRpb24gaW5zaWRlIGFuIG9uUmVzZXQgaGFuZGxlci5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwibmF0aXZlXCIpIHNldENvbW1pdFF1ZXVlZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRTZXJ2ZXJFcnJvckNsZWFyZWQodHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1pdFZhbGlkYXRpb24gKCkge1xuICAgICAgICAgICAgLy8gQ29tbWl0IHZhbGlkYXRpb24gc3RhdGUgc28gdGhlIHVzZXIgc2VlcyBpdCBvbiBibHVyL2NoYW5nZS9zdWJtaXQuIEFsc28gY2xlYXIgYW55IHNlcnZlciBlcnJvcnMuXG4gICAgICAgICAgICAvLyBXYWl0IHVudGlsIGFmdGVyIHRoZSBuZXh0IHJlbmRlciB0byBjb21taXQgc28gdGhhdCB0aGUgbGF0ZXN0IHZhbHVlIGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwibmF0aXZlXCIpIHNldENvbW1pdFF1ZXVlZCh0cnVlKTtcbiAgICAgICAgICAgIHNldFNlcnZlckVycm9yQ2xlYXJlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkYXNBcnJheSh2KSB7XG4gICAgaWYgKCF2KSByZXR1cm4gW107XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodikgPyB2IDogW1xuICAgICAgICB2XG4gICAgXTtcbn1cbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJHZhciRydW5WYWxpZGF0ZSh2YWxpZGF0ZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbGlkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbGV0IGUgPSB2YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChlICYmIHR5cGVvZiBlICE9PSBcImJvb2xlYW5cIikgcmV0dXJuICRlNWJlMjAwYzY3NWMzYjNhJHZhciRhc0FycmF5KGUpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkZ2V0VmFsaWRhdGlvblJlc3VsdChlcnJvcnMpIHtcbiAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA/IHtcbiAgICAgICAgaXNJbnZhbGlkOiB0cnVlLFxuICAgICAgICB2YWxpZGF0aW9uRXJyb3JzOiBlcnJvcnMsXG4gICAgICAgIHZhbGlkYXRpb25EZXRhaWxzOiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkQ1VTVE9NX1ZBTElESVRZX1NUQVRFXG4gICAgfSA6IG51bGw7XG59XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24oYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gYSAmJiBiICYmIGEuaXNJbnZhbGlkID09PSBiLmlzSW52YWxpZCAmJiBhLnZhbGlkYXRpb25FcnJvcnMubGVuZ3RoID09PSBiLnZhbGlkYXRpb25FcnJvcnMubGVuZ3RoICYmIGEudmFsaWRhdGlvbkVycm9ycy5ldmVyeSgoYSwgaSk9PmEgPT09IGIudmFsaWRhdGlvbkVycm9yc1tpXSkgJiYgT2JqZWN0LmVudHJpZXMoYS52YWxpZGF0aW9uRGV0YWlscykuZXZlcnkoKFtrLCB2XSk9PmIudmFsaWRhdGlvbkRldGFpbHNba10gPT09IHYpO1xufVxuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDc1ZWU3Yzc1ZDY4ZjViMGUoLi4ucmVzdWx0cykge1xuICAgIGxldCBlcnJvcnMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xuICAgIGxldCB2YWxpZGF0aW9uRGV0YWlscyA9IHtcbiAgICAgICAgLi4uJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmNcbiAgICB9O1xuICAgIGZvciAobGV0IHYgb2YgcmVzdWx0cyl7XG4gICAgICAgIHZhciBfdmFsaWRhdGlvbkRldGFpbHMsIF9rZXk7XG4gICAgICAgIGZvciAobGV0IGUgb2Ygdi52YWxpZGF0aW9uRXJyb3JzKWVycm9ycy5hZGQoZSk7XG4gICAgICAgIC8vIE9ubHkgdGhlc2UgcHJvcGVydGllcyBhcHBseSBmb3IgY2hlY2tib3hlcy5cbiAgICAgICAgaXNJbnZhbGlkIHx8IChpc0ludmFsaWQgPSB2LmlzSW52YWxpZCk7XG4gICAgICAgIGZvcihsZXQga2V5IGluIHZhbGlkYXRpb25EZXRhaWxzKShfdmFsaWRhdGlvbkRldGFpbHMgPSB2YWxpZGF0aW9uRGV0YWlscylbX2tleSA9IGtleV0gfHwgKF92YWxpZGF0aW9uRGV0YWlsc1tfa2V5XSA9IHYudmFsaWRhdGlvbkRldGFpbHNba2V5XSk7XG4gICAgfVxuICAgIHZhbGlkYXRpb25EZXRhaWxzLnZhbGlkID0gIWlzSW52YWxpZDtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0ludmFsaWQ6IGlzSW52YWxpZCxcbiAgICAgICAgdmFsaWRhdGlvbkVycm9yczogW1xuICAgICAgICAgICAgLi4uZXJyb3JzXG4gICAgICAgIF0sXG4gICAgICAgIHZhbGlkYXRpb25EZXRhaWxzOiB2YWxpZGF0aW9uRGV0YWlsc1xuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDU3MWI1MTMxYjdlNjVjMTEgYXMgRm9ybVZhbGlkYXRpb25Db250ZXh0LCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZmMxYTM2NGFlMWYzZmYxMCBhcyB1c2VGb3JtVmFsaWRhdGlvblN0YXRlLCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSBhcyBERUZBVUxUX1ZBTElEQVRJT05fUkVTVUxULCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYWNhOTU4YzY1YzMxNGU2YyBhcyBWQUxJRF9WQUxJRElUWV9TVEFURSwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYiBhcyBwcml2YXRlVmFsaWRhdGlvblN0YXRlUHJvcCwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDc1ZWU3Yzc1ZDY4ZjViMGUgYXMgbWVyZ2VWYWxpZGF0aW9ufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwiJGpjSU93JGNyZWF0ZUNvbnRleHQiLCJ1c2VNZW1vIiwiJGpjSU93JHVzZU1lbW8iLCJ1c2VDb250ZXh0IiwiJGpjSU93JHVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsIiRqY0lPdyR1c2VTdGF0ZSIsInVzZVJlZiIsIiRqY0lPdyR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkamNJT3ckdXNlRWZmZWN0IiwiJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmMiLCJiYWRJbnB1dCIsImN1c3RvbUVycm9yIiwicGF0dGVybk1pc21hdGNoIiwicmFuZ2VPdmVyZmxvdyIsInJhbmdlVW5kZXJmbG93Iiwic3RlcE1pc21hdGNoIiwidG9vTG9uZyIsInRvb1Nob3J0IiwidHlwZU1pc21hdGNoIiwidmFsdWVNaXNzaW5nIiwidmFsaWQiLCIkZTViZTIwMGM2NzVjM2IzYSR2YXIkQ1VTVE9NX1ZBTElESVRZX1NUQVRFIiwiJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmEiLCJpc0ludmFsaWQiLCJ2YWxpZGF0aW9uRGV0YWlscyIsInZhbGlkYXRpb25FcnJvcnMiLCIkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNTcxYjUxMzFiN2U2NWMxMSIsIiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhNzYzYjk0NzZhY2QzZWIiLCJEYXRlIiwibm93IiwiJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGZjMWEzNjRhZTFmM2ZmMTAiLCJwcm9wcyIsInJlYWx0aW1lVmFsaWRhdGlvbiIsImRpc3BsYXlWYWxpZGF0aW9uIiwidXBkYXRlVmFsaWRhdGlvbiIsInJlc2V0VmFsaWRhdGlvbiIsImNvbW1pdFZhbGlkYXRpb24iLCIkZTViZTIwMGM2NzVjM2IzYSR2YXIkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZUltcGwiLCJ2YWxpZGF0aW9uU3RhdGUiLCJuYW1lIiwidmFsdWUiLCJidWlsdGluVmFsaWRhdGlvbiIsInZhbGlkYXRlIiwidmFsaWRhdGlvbkJlaGF2aW9yIiwiY29udHJvbGxlZEVycm9yIiwiY2xpZW50RXJyb3IiLCIkZTViZTIwMGM2NzVjM2IzYSR2YXIkZ2V0VmFsaWRhdGlvblJlc3VsdCIsIiRlNWJlMjAwYzY3NWMzYjNhJHZhciRydW5WYWxpZGF0ZSIsInNlcnZlckVycm9ycyIsInNlcnZlckVycm9yTWVzc2FnZXMiLCJBcnJheSIsImlzQXJyYXkiLCJmbGF0TWFwIiwiJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGFzQXJyYXkiLCJsYXN0U2VydmVyRXJyb3JzIiwic2V0TGFzdFNlcnZlckVycm9ycyIsImlzU2VydmVyRXJyb3JDbGVhcmVkIiwic2V0U2VydmVyRXJyb3JDbGVhcmVkIiwic2VydmVyRXJyb3IiLCJuZXh0VmFsaWRhdGlvbiIsImN1cnJlbnRWYWxpZGl0eSIsInNldEN1cnJlbnRWYWxpZGl0eSIsImxhc3RFcnJvciIsImNvbW1pdFF1ZXVlZCIsInNldENvbW1pdFF1ZXVlZCIsImVycm9yIiwiY3VycmVudCIsIiRlNWJlMjAwYzY3NWMzYjNhJHZhciRpc0VxdWFsVmFsaWRhdGlvbiIsInYiLCJlIiwiZXJyb3JzIiwibGVuZ3RoIiwiYSIsImIiLCJldmVyeSIsImkiLCJPYmplY3QiLCJlbnRyaWVzIiwiayIsIiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCQ3NWVlN2M3NWQ2OGY1YjBlIiwicmVzdWx0cyIsIlNldCIsIl92YWxpZGF0aW9uRGV0YWlscyIsIl9rZXkiLCJhZGQiLCJrZXkiLCJGb3JtVmFsaWRhdGlvbkNvbnRleHQiLCJ1c2VGb3JtVmFsaWRhdGlvblN0YXRlIiwiREVGQVVMVF9WQUxJREFUSU9OX1JFU1VMVCIsIlZBTElEX1ZBTElESVRZX1NUQVRFIiwicHJpdmF0ZVZhbGlkYXRpb25TdGF0ZVByb3AiLCJtZXJnZVZhbGlkYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/form/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/grid/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/grid/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridCollection: () => (/* binding */ $16805b1b18093c5f$export$de3fdf6493c353d),\n/* harmony export */   useGridState: () => (/* binding */ $62967d126f3aa823$export$4007ac09ff9c68ed)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n    let { collection: collection, focusMode: focusMode } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let setFocusedKey = selectionState.setFocusedKey;\n    selectionState.setFocusedKey = (key, child)=>{\n        // If focusMode is cell and an item is focused, focus a child cell instead.\n        if (focusMode === \"cell\" && key != null) {\n            let item = collection.getItem(key);\n            if ((item === null || item === void 0 ? void 0 : item.type) === \"item\") {\n                var _getLastItem, _getFirstItem;\n                let children = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, collection);\n                if (child === \"last\") key = (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n                else key = (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n            }\n        }\n        setFocusedKey(key, child);\n    };\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const node = cachedCollection.current.getItem(selectionState.focusedKey);\n            const parentNode = node.parentKey != null && (node.type === \"cell\" || node.type === \"rowheader\" || node.type === \"column\") ? cachedCollection.current.getItem(node.parentKey) : node;\n            const cachedRows = cachedCollection.current.rows;\n            const rows = collection.rows;\n            const diff = cachedRows.length - rows.length;\n            let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);\n            let newRow;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== \"headerrow\") {\n                    newRow = rows[index];\n                    break;\n                }\n                // Find next, not disabled row.\n                if (index < rows.length - 1) index++;\n                else {\n                    if (index > parentNode.index) index = parentNode.index;\n                    index--;\n                }\n            }\n            if (newRow) {\n                const childNodes = newRow.hasChildNodes ? [\n                    ...(0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(newRow, collection)\n                ] : [];\n                const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;\n                selectionState.setFocusedKey(keyToFocus);\n            } else selectionState.setFocusedKey(null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        isKeyboardNavigationDisabled: false,\n        selectionManager: selectionManager\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $16805b1b18093c5f$export$de3fdf6493c353d {\n    *[Symbol.iterator]() {\n        yield* [\n            ...this.rows\n        ];\n    }\n    get size() {\n        return [\n            ...this.rows\n        ].length;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _;\n        return (_ = [\n            ...this.rows\n        ][0]) === null || _ === void 0 ? void 0 : _.key;\n    }\n    getLastKey() {\n        var _rows_;\n        let rows = [\n            ...this.rows\n        ];\n        return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(opts){\n        this.keyMap = new Map();\n        this.keyMap = new Map();\n        this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n        this.rows = [];\n        let visit = (node)=>{\n            // If the node is the same object as the previous node for the same key,\n            // we can skip this node and its children. We always visit columns though,\n            // because we depend on order to build the columns array.\n            let prevNode = this.keyMap.get(node.key);\n            if (opts.visitNode) node = opts.visitNode(node);\n            this.keyMap.set(node.key, node);\n            let childKeys = new Set();\n            let last;\n            for (let child of node.childNodes){\n                if (child.type === \"cell\" && child.parentKey == null) child.parentKey = node.key;\n                childKeys.add(child.key);\n                if (last) {\n                    last.nextKey = child.key;\n                    child.prevKey = last.key;\n                } else child.prevKey = null;\n                visit(child);\n                last = child;\n            }\n            if (last) last.nextKey = null;\n            // Remove deleted nodes and their children from the key map\n            if (prevNode) {\n                for (let child of prevNode.childNodes)if (!childKeys.has(child.key)) remove(child);\n            }\n        };\n        let remove = (node)=>{\n            this.keyMap.delete(node.key);\n            for (let child of node.childNodes)if (this.keyMap.get(child.key) === child) remove(child);\n        };\n        let last;\n        opts.items.forEach((node, i)=>{\n            let rowNode = {\n                level: 0,\n                key: \"row-\" + i,\n                type: \"row\",\n                value: undefined,\n                hasChildNodes: true,\n                childNodes: [\n                    ...node.childNodes\n                ],\n                rendered: undefined,\n                textValue: undefined,\n                ...node\n            };\n            if (last) {\n                last.nextKey = rowNode.key;\n                rowNode.prevKey = last.key;\n            } else rowNode.prevKey = null;\n            this.rows.push(rowNode);\n            visit(rowNode);\n            last = rowNode;\n        });\n        if (last) last.nextKey = null;\n    }\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZ3JpZC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUo7QUFDTDtBQUM1QztBQUV4Rzs7Ozs7Ozs7OztDQVVDLEdBR0QsU0FBU2dCLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLEVBQUVDLFlBQVlBLFVBQVUsRUFBRUMsV0FBV0EsU0FBUyxFQUFFLEdBQUdGO0lBQ3ZELElBQUlHLGlCQUFpQixDQUFDLEdBQUdiLCtFQUErQixFQUFHVTtJQUMzRCxJQUFJSSxlQUFlLENBQUMsR0FBR1YsMENBQWEsRUFBRyxJQUFJTSxNQUFNSSxZQUFZLEdBQUcsSUFBSUMsSUFBSUwsTUFBTUksWUFBWSxJQUFJLElBQUlDLE9BQU87UUFDckdMLE1BQU1JLFlBQVk7S0FDckI7SUFDRCxJQUFJRSxnQkFBZ0JILGVBQWVHLGFBQWE7SUFDaERILGVBQWVHLGFBQWEsR0FBRyxDQUFDQyxLQUFLQztRQUNqQywyRUFBMkU7UUFDM0UsSUFBSU4sY0FBYyxVQUFVSyxPQUFPLE1BQU07WUFDckMsSUFBSUUsT0FBT1IsV0FBV1MsT0FBTyxDQUFDSDtZQUM5QixJQUFJLENBQUNFLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLRSxJQUFJLE1BQU0sUUFBUTtnQkFDcEUsSUFBSUMsY0FBY0M7Z0JBQ2xCLElBQUlDLFdBQVcsQ0FBQyxHQUFHOUIscUVBQW1CLEVBQUd5QixNQUFNUjtnQkFDL0MsSUFBSU8sVUFBVSxRQUFRRCxNQUFNLENBQUNLLGVBQWUsQ0FBQyxHQUFHMUIsbUVBQWlCLEVBQUc0QixTQUFRLE1BQU8sUUFBUUYsaUJBQWlCLEtBQUssSUFBSSxLQUFLLElBQUlBLGFBQWFMLEdBQUc7cUJBQ3pJQSxNQUFNLENBQUNNLGdCQUFnQixDQUFDLEdBQUd6QixvRUFBa0IsRUFBRzBCLFNBQVEsTUFBTyxRQUFRRCxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBY04sR0FB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Q0FBQzFELE1BQU1ELEdBQUcsR0FBRzRELE9BQU8zRDtZQUNoRjtRQUNKO1FBQ0EsSUFBSTJELFNBQVMsQ0FBQ2pEO1lBQ1YsSUFBSSxDQUFDdUIsTUFBTSxDQUFDMkIsTUFBTSxDQUFDbEQsS0FBS1gsR0FBRztZQUMzQixLQUFLLElBQUlDLFNBQVNVLEtBQUtjLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQ1MsTUFBTSxDQUFDRyxHQUFHLENBQUNwQyxNQUFNRCxHQUFHLE1BQU1DLE9BQU8yRCxPQUFPM0Q7UUFDdkY7UUFDQSxJQUFJd0Q7UUFDSlIsS0FBS2EsS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQ3BELE1BQU1xRDtZQUN0QixJQUFJQyxVQUFVO2dCQUNWQyxPQUFPO2dCQUNQbEUsS0FBSyxTQUFTZ0U7Z0JBQ2Q1RCxNQUFNO2dCQUNOK0QsT0FBT0M7Z0JBQ1AxQyxlQUFlO2dCQUNmRCxZQUFZO3VCQUNMZCxLQUFLYyxVQUFVO2lCQUNyQjtnQkFDRDRDLFVBQVVEO2dCQUNWRSxXQUFXRjtnQkFDWCxHQUFHekQsSUFBSTtZQUNYO1lBQ0EsSUFBSThDLE1BQU07Z0JBQ05BLEtBQUtqQixPQUFPLEdBQUd5QixRQUFRakUsR0FBRztnQkFDMUJpRSxRQUFRM0IsT0FBTyxHQUFHbUIsS0FBS3pELEdBQUc7WUFDOUIsT0FBT2lFLFFBQVEzQixPQUFPLEdBQUc7WUFDekIsSUFBSSxDQUFDdEIsSUFBSSxDQUFDdUQsSUFBSSxDQUFDTjtZQUNmYixNQUFNYTtZQUNOUixPQUFPUTtRQUNYO1FBQ0EsSUFBSVIsTUFBTUEsS0FBS2pCLE9BQU8sR0FBRztJQUM3QjtBQUNKO0FBSytILENBQy9ILGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2dyaWQvZGlzdC9pbXBvcnQubWpzP2I2YTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZXRDaGlsZE5vZGVzIGFzICRjQW41ZiRnZXRDaGlsZE5vZGVzLCBnZXRMYXN0SXRlbSBhcyAkY0FuNWYkZ2V0TGFzdEl0ZW0sIGdldEZpcnN0SXRlbSBhcyAkY0FuNWYkZ2V0Rmlyc3RJdGVtfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCB7dXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSBhcyAkY0FuNWYkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSwgU2VsZWN0aW9uTWFuYWdlciBhcyAkY0FuNWYkU2VsZWN0aW9uTWFuYWdlcn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3NlbGVjdGlvblwiO1xuaW1wb3J0IHt1c2VNZW1vIGFzICRjQW41ZiR1c2VNZW1vLCB1c2VSZWYgYXMgJGNBbjVmJHVzZVJlZiwgdXNlRWZmZWN0IGFzICRjQW41ZiR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuZnVuY3Rpb24gJDYyOTY3ZDEyNmYzYWE4MjMkZXhwb3J0JDQwMDdhYzA5ZmY5YzY4ZWQocHJvcHMpIHtcbiAgICBsZXQgeyBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLCBmb2N1c01vZGU6IGZvY3VzTW9kZSB9ID0gcHJvcHM7XG4gICAgbGV0IHNlbGVjdGlvblN0YXRlID0gKDAsICRjQW41ZiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlKShwcm9wcyk7XG4gICAgbGV0IGRpc2FibGVkS2V5cyA9ICgwLCAkY0FuNWYkdXNlTWVtbykoKCk9PnByb3BzLmRpc2FibGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGlzYWJsZWRLZXlzKSA6IG5ldyBTZXQoKSwgW1xuICAgICAgICBwcm9wcy5kaXNhYmxlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgc2V0Rm9jdXNlZEtleSA9IHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXk7XG4gICAgc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleSA9IChrZXksIGNoaWxkKT0+e1xuICAgICAgICAvLyBJZiBmb2N1c01vZGUgaXMgY2VsbCBhbmQgYW4gaXRlbSBpcyBmb2N1c2VkLCBmb2N1cyBhIGNoaWxkIGNlbGwgaW5zdGVhZC5cbiAgICAgICAgaWYgKGZvY3VzTW9kZSA9PT0gXCJjZWxsXCIgJiYga2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAoKGl0ZW0gPT09IG51bGwgfHwgaXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbS50eXBlKSA9PT0gXCJpdGVtXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2dldExhc3RJdGVtLCBfZ2V0Rmlyc3RJdGVtO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9ICgwLCAkY0FuNWYkZ2V0Q2hpbGROb2RlcykoaXRlbSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkID09PSBcImxhc3RcIikga2V5ID0gKF9nZXRMYXN0SXRlbSA9ICgwLCAkY0FuNWYkZ2V0TGFzdEl0ZW0pKGNoaWxkcmVuKSkgPT09IG51bGwgfHwgX2dldExhc3RJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0TGFzdEl0ZW0ua2V5O1xuICAgICAgICAgICAgICAgIGVsc2Uga2V5ID0gKF9nZXRGaXJzdEl0ZW0gPSAoMCwgJGNBbjVmJGdldEZpcnN0SXRlbSkoY2hpbGRyZW4pKSA9PT0gbnVsbCB8fCBfZ2V0Rmlyc3RJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0Rmlyc3RJdGVtLmtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRGb2N1c2VkS2V5KGtleSwgY2hpbGQpO1xuICAgIH07XG4gICAgbGV0IHNlbGVjdGlvbk1hbmFnZXIgPSAoMCwgJGNBbjVmJHVzZU1lbW8pKCgpPT5uZXcgKDAsICRjQW41ZiRTZWxlY3Rpb25NYW5hZ2VyKShjb2xsZWN0aW9uLCBzZWxlY3Rpb25TdGF0ZSksIFtcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgc2VsZWN0aW9uU3RhdGVcbiAgICBdKTtcbiAgICAvLyBSZXNldCBmb2N1c2VkIGtleSBpZiB0aGF0IGl0ZW0gaXMgZGVsZXRlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgIGNvbnN0IGNhY2hlZENvbGxlY3Rpb24gPSAoMCwgJGNBbjVmJHVzZVJlZikobnVsbCk7XG4gICAgKDAsICRjQW41ZiR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5ICE9IG51bGwgJiYgIWNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRJdGVtKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50S2V5ICE9IG51bGwgJiYgKG5vZGUudHlwZSA9PT0gXCJjZWxsXCIgfHwgbm9kZS50eXBlID09PSBcInJvd2hlYWRlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJjb2x1bW5cIikgPyBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQuZ2V0SXRlbShub2RlLnBhcmVudEtleSkgOiBub2RlO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkUm93cyA9IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5yb3dzO1xuICAgICAgICAgICAgY29uc3Qgcm93cyA9IGNvbGxlY3Rpb24ucm93cztcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjYWNoZWRSb3dzLmxlbmd0aCAtIHJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gTWF0aC5taW4oZGlmZiA+IDEgPyBNYXRoLm1heChwYXJlbnROb2RlLmluZGV4IC0gZGlmZiArIDEsIDApIDogcGFyZW50Tm9kZS5pbmRleCwgcm93cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGxldCBuZXdSb3c7XG4gICAgICAgICAgICB3aGlsZShpbmRleCA+PSAwKXtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbk1hbmFnZXIuaXNEaXNhYmxlZChyb3dzW2luZGV4XS5rZXkpICYmIHJvd3NbaW5kZXhdLnR5cGUgIT09IFwiaGVhZGVycm93XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Um93ID0gcm93c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaW5kIG5leHQsIG5vdCBkaXNhYmxlZCByb3cuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgcm93cy5sZW5ndGggLSAxKSBpbmRleCsrO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiBwYXJlbnROb2RlLmluZGV4KSBpbmRleCA9IHBhcmVudE5vZGUuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1Jvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBuZXdSb3cuaGFzQ2hpbGROb2RlcyA/IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uKDAsICRjQW41ZiRnZXRDaGlsZE5vZGVzKShuZXdSb3csIGNvbGxlY3Rpb24pXG4gICAgICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVRvRm9jdXMgPSBuZXdSb3cuaGFzQ2hpbGROb2RlcyAmJiBwYXJlbnROb2RlICE9PSBub2RlICYmIG5vZGUuaW5kZXggPCBjaGlsZE5vZGVzLmxlbmd0aCA/IGNoaWxkTm9kZXNbbm9kZS5pbmRleF0ua2V5IDogbmV3Um93LmtleTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5KGtleVRvRm9jdXMpO1xuICAgICAgICAgICAgfSBlbHNlIHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXkobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50ID0gY29sbGVjdGlvbjtcbiAgICB9LCBbXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXIsXG4gICAgICAgIHNlbGVjdGlvblN0YXRlLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5XG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIGlzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyXG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJDE2ODA1YjFiMTgwOTNjNWYkZXhwb3J0JGRlM2ZkZjY0OTNjMzUzZCB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICB5aWVsZCogW1xuICAgICAgICAgICAgLi4udGhpcy5yb3dzXG4gICAgICAgIF07XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udGhpcy5yb3dzXG4gICAgICAgIF0ubGVuZ3RoO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAua2V5cygpO1xuICAgIH1cbiAgICBnZXRLZXlCZWZvcmUoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0S2V5QWZ0ZXIoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5uZXh0S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Rmlyc3RLZXkoKSB7XG4gICAgICAgIHZhciBfO1xuICAgICAgICByZXR1cm4gKF8gPSBbXG4gICAgICAgICAgICAuLi50aGlzLnJvd3NcbiAgICAgICAgXVswXSkgPT09IG51bGwgfHwgXyA9PT0gdm9pZCAwID8gdm9pZCAwIDogXy5rZXk7XG4gICAgfVxuICAgIGdldExhc3RLZXkoKSB7XG4gICAgICAgIHZhciBfcm93c187XG4gICAgICAgIGxldCByb3dzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5yb3dzXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAoX3Jvd3NfID0gcm93c1tyb3dzLmxlbmd0aCAtIDFdKSA9PT0gbnVsbCB8fCBfcm93c18gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yb3dzXy5rZXk7XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICB9XG4gICAgYXQoaWR4KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmdldEtleXMoKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleXNbaWR4XSk7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5jaGlsZE5vZGVzKSB8fCBbXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0cyl7XG4gICAgICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5Db3VudCA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5jb2x1bW5Db3VudDtcbiAgICAgICAgdGhpcy5yb3dzID0gW107XG4gICAgICAgIGxldCB2aXNpdCA9IChub2RlKT0+e1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgdGhlIHNhbWUgb2JqZWN0IGFzIHRoZSBwcmV2aW91cyBub2RlIGZvciB0aGUgc2FtZSBrZXksXG4gICAgICAgICAgICAvLyB3ZSBjYW4gc2tpcCB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gV2UgYWx3YXlzIHZpc2l0IGNvbHVtbnMgdGhvdWdoLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBkZXBlbmQgb24gb3JkZXIgdG8gYnVpbGQgdGhlIGNvbHVtbnMgYXJyYXkuXG4gICAgICAgICAgICBsZXQgcHJldk5vZGUgPSB0aGlzLmtleU1hcC5nZXQobm9kZS5rZXkpO1xuICAgICAgICAgICAgaWYgKG9wdHMudmlzaXROb2RlKSBub2RlID0gb3B0cy52aXNpdE5vZGUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmtleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICAgICAgbGV0IGNoaWxkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGxldCBsYXN0O1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKXtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJjZWxsXCIgJiYgY2hpbGQucGFyZW50S2V5ID09IG51bGwpIC8vIGlmIGNoaWxkIGlzIGEgY2VsbCBwYXJlbnQga2V5IGlzbid0IGFscmVhZHkgZXN0YWJsaXNoZWQgYnkgdGhlIGNvbGxlY3Rpb24sIG1hdGNoIGNoaWxkIG5vZGUgdG8gcGFyZW50IHJvd1xuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudEtleSA9IG5vZGUua2V5O1xuICAgICAgICAgICAgICAgIGNoaWxkS2V5cy5hZGQoY2hpbGQua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnByZXZLZXkgPSBsYXN0LmtleTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgY2hpbGQucHJldktleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmlzaXQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGxhc3QgPSBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0KSBsYXN0Lm5leHRLZXkgPSBudWxsO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGRlbGV0ZWQgbm9kZXMgYW5kIHRoZWlyIGNoaWxkcmVuIGZyb20gdGhlIGtleSBtYXBcbiAgICAgICAgICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHByZXZOb2RlLmNoaWxkTm9kZXMpaWYgKCFjaGlsZEtleXMuaGFzKGNoaWxkLmtleSkpIHJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCByZW1vdmUgPSAobm9kZSk9PntcbiAgICAgICAgICAgIHRoaXMua2V5TWFwLmRlbGV0ZShub2RlLmtleSk7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpaWYgKHRoaXMua2V5TWFwLmdldChjaGlsZC5rZXkpID09PSBjaGlsZCkgcmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIG9wdHMuaXRlbXMuZm9yRWFjaCgobm9kZSwgaSk9PntcbiAgICAgICAgICAgIGxldCByb3dOb2RlID0ge1xuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgICAgIGtleTogXCJyb3ctXCIgKyBpLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwicm93XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZS5jaGlsZE5vZGVzXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC4uLm5vZGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IHJvd05vZGUua2V5O1xuICAgICAgICAgICAgICAgIHJvd05vZGUucHJldktleSA9IGxhc3Qua2V5O1xuICAgICAgICAgICAgfSBlbHNlIHJvd05vZGUucHJldktleSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJvd3MucHVzaChyb3dOb2RlKTtcbiAgICAgICAgICAgIHZpc2l0KHJvd05vZGUpO1xuICAgICAgICAgICAgbGFzdCA9IHJvd05vZGU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGFzdCkgbGFzdC5uZXh0S2V5ID0gbnVsbDtcbiAgICB9XG59XG5cblxuXG5cbmV4cG9ydCB7JDYyOTY3ZDEyNmYzYWE4MjMkZXhwb3J0JDQwMDdhYzA5ZmY5YzY4ZWQgYXMgdXNlR3JpZFN0YXRlLCAkMTY4MDViMWIxODA5M2M1ZiRleHBvcnQkZGUzZmRmNjQ5M2MzNTNkIGFzIEdyaWRDb2xsZWN0aW9ufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnZXRDaGlsZE5vZGVzIiwiJGNBbjVmJGdldENoaWxkTm9kZXMiLCJnZXRMYXN0SXRlbSIsIiRjQW41ZiRnZXRMYXN0SXRlbSIsImdldEZpcnN0SXRlbSIsIiRjQW41ZiRnZXRGaXJzdEl0ZW0iLCJ1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIiwiJGNBbjVmJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCJTZWxlY3Rpb25NYW5hZ2VyIiwiJGNBbjVmJFNlbGVjdGlvbk1hbmFnZXIiLCJ1c2VNZW1vIiwiJGNBbjVmJHVzZU1lbW8iLCJ1c2VSZWYiLCIkY0FuNWYkdXNlUmVmIiwidXNlRWZmZWN0IiwiJGNBbjVmJHVzZUVmZmVjdCIsIiQ2Mjk2N2QxMjZmM2FhODIzJGV4cG9ydCQ0MDA3YWMwOWZmOWM2OGVkIiwicHJvcHMiLCJjb2xsZWN0aW9uIiwiZm9jdXNNb2RlIiwic2VsZWN0aW9uU3RhdGUiLCJkaXNhYmxlZEtleXMiLCJTZXQiLCJzZXRGb2N1c2VkS2V5Iiwia2V5IiwiY2hpbGQiLCJpdGVtIiwiZ2V0SXRlbSIsInR5cGUiLCJfZ2V0TGFzdEl0ZW0iLCJfZ2V0Rmlyc3RJdGVtIiwiY2hpbGRyZW4iLCJzZWxlY3Rpb25NYW5hZ2VyIiwiY2FjaGVkQ29sbGVjdGlvbiIsImZvY3VzZWRLZXkiLCJub2RlIiwiY3VycmVudCIsInBhcmVudE5vZGUiLCJwYXJlbnRLZXkiLCJjYWNoZWRSb3dzIiwicm93cyIsImRpZmYiLCJsZW5ndGgiLCJpbmRleCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJuZXdSb3ciLCJpc0Rpc2FibGVkIiwiY2hpbGROb2RlcyIsImhhc0NoaWxkTm9kZXMiLCJrZXlUb0ZvY3VzIiwiaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCIsIiQxNjgwNWIxYjE4MDkzYzVmJGV4cG9ydCRkZTNmZGY2NDkzYzM1M2QiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNpemUiLCJnZXRLZXlzIiwia2V5TWFwIiwia2V5cyIsImdldEtleUJlZm9yZSIsImdldCIsInByZXZLZXkiLCJnZXRLZXlBZnRlciIsIm5leHRLZXkiLCJnZXRGaXJzdEtleSIsIl8iLCJnZXRMYXN0S2V5IiwiX3Jvd3NfIiwiYXQiLCJpZHgiLCJnZXRDaGlsZHJlbiIsImNvbnN0cnVjdG9yIiwib3B0cyIsIk1hcCIsImNvbHVtbkNvdW50IiwidmlzaXQiLCJwcmV2Tm9kZSIsInZpc2l0Tm9kZSIsInNldCIsImNoaWxkS2V5cyIsImxhc3QiLCJhZGQiLCJoYXMiLCJyZW1vdmUiLCJkZWxldGUiLCJpdGVtcyIsImZvckVhY2giLCJpIiwicm93Tm9kZSIsImxldmVsIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJyZW5kZXJlZCIsInRleHRWYWx1ZSIsInB1c2giLCJ1c2VHcmlkU3RhdGUiLCJHcmlkQ29sbGVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/list/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/list/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListCollection: () => (/* binding */ $a02d57049d202695$export$d085fb9e920b5ca7),\n/* harmony export */   useListState: () => (/* binding */ $e72dd72e1c76a225$export$2f645645f7bca764),\n/* harmony export */   useSingleSelectListState: () => (/* binding */ $a0d645289fe9b86b$export$e7f05e985daf4b5f)\n/* harmony export */ });\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $a02d57049d202695$export$d085fb9e920b5ca7 {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(nodes){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && node.type === \"section\") for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\nfunction $e72dd72e1c76a225$export$2f645645f7bca764(props) {\n    let { filter: filter } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let factory = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>filter ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes), [\n        filter\n    ]);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            suppressTextValueWarning: props.suppressTextValueWarning\n        }), [\n        props.suppressTextValueWarning\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, factory, context);\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const startItem = cachedCollection.current.getItem(selectionState.focusedKey);\n            const cachedItemNodes = [\n                ...cachedCollection.current.getKeys()\n            ].map((key)=>{\n                const itemNode = cachedCollection.current.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const itemNodes = [\n                ...collection.getKeys()\n            ].map((key)=>{\n                const itemNode = collection.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const diff = cachedItemNodes.length - itemNodes.length;\n            let index = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);\n            let newNode;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(itemNodes[index].key)) {\n                    newNode = itemNodes[index];\n                    break;\n                }\n                // Find next, not disabled item.\n                if (index < itemNodes.length - 1) index++;\n                else {\n                    if (index > startItem.index) index = startItem.index;\n                    index--;\n                }\n            }\n            selectionState.setFocusedKey(newNode ? newNode.key : null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {\n    var _props_defaultSelectedKey;\n    let [selectedKey, setSelectedKey] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.useControlledState)(props.selectedKey, (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : null, props.onSelectionChange);\n    let selectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>selectedKey != null ? [\n            selectedKey\n        ] : [], [\n        selectedKey\n    ]);\n    let { collection: collection, disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, $e72dd72e1c76a225$export$2f645645f7bca764)({\n        ...props,\n        selectionMode: \"single\",\n        disallowEmptySelection: true,\n        allowDuplicateSelectionEvents: true,\n        selectedKeys: selectedKeys,\n        onSelectionChange: (keys)=>{\n            var _keys_values_next_value;\n            let key = (_keys_values_next_value = keys.values().next().value) !== null && _keys_values_next_value !== void 0 ? _keys_values_next_value : null;\n            // Always fire onSelectionChange, even if the key is the same\n            // as the current key (useControlledState does not).\n            if (key === selectedKey && props.onSelectionChange) props.onSelectionChange(key);\n            setSelectedKey(key);\n        }\n    });\n    let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        selectedKey: selectedKey,\n        setSelectedKey: setSelectedKey,\n        selectedItem: selectedItem\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbGlzdC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvSjtBQUNUO0FBQzFEO0FBQ0k7QUFFckY7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsTUFBTWdCO0lBQ04sQ0FBQyxDQUFDQyxPQUFPQyxRQUFRLENBQUMsR0FBRztRQUNqQixPQUFPLElBQUksQ0FBQ0MsUUFBUTtJQUN4QjtJQUNBLElBQUlDLE9BQU87UUFDUCxPQUFPLElBQUksQ0FBQ0MsTUFBTSxDQUFDRCxJQUFJO0lBQzNCO0lBQ0FFLFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQ0QsTUFBTSxDQUFDRSxJQUFJO0lBQzNCO0lBQ0FDLGFBQWFDLEdBQUcsRUFBRTtRQUNkLElBQUlDLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUNNLEdBQUcsQ0FBQ0Y7UUFDM0IsT0FBT0MsT0FBT0EsS0FBS0UsT0FBTyxHQUFHO0lBQ2pDO0lBQ0FDLFlBQVlKLEdBQUcsRUFBRTtRQUNiLElBQUlDLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUNNLEdBQUcsQ0FBQ0Y7UUFDM0IsT0FBT0MsT0FBT0EsS0FBS0ksT0FBTyxHQUFHO0lBQ2pDO0lBQ0FDLGNBQWM7UUFDVixPQUFPLElBQUksQ0FBQ0MsUUFBUTtJQUN4QjtJQUNBQyxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNDLE9BQU87SUFDdkI7SUFDQUMsUUFBUVYsR0FBRyxFQUFFO1FBQ1QsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtJQUMzQjtJQUNBVyxHQUFHQyxHQUFHLEVBQUU7UUFDSixNQUFNZCxPQUFPO2VBQ04sSUFBSSxDQUFDRCxPQUFPO1NBQ2xCO1FBQ0QsT0FBTyxJQUFJLENBQUNhLE9BQU8sQ0FBQ1osSUFBSSxDQUFDYyxJQUFJO0lBQ2pDO0lBQ0FDLFlBQVliLEdBQUcsRUFBRTtRQUNi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QUFZQTtRQUNaTCxjQUFjQTtRQUNkTSxrQkFBa0JBO1FBQ2xCbUIsYUFBYUE7UUFDYkMsZ0JBQWdCQTtRQUNoQlcsY0FBY0E7SUFDbEI7QUFDSjtBQU11TSxDQUN2TSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWR1c2EtbmV4dC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9saXN0L2Rpc3QvaW1wb3J0Lm1qcz81MDEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSBhcyAkNThQaHMkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSwgU2VsZWN0aW9uTWFuYWdlciBhcyAkNThQaHMkU2VsZWN0aW9uTWFuYWdlcn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3NlbGVjdGlvblwiO1xuaW1wb3J0IHt1c2VNZW1vIGFzICQ1OFBocyR1c2VNZW1vLCB1c2VDYWxsYmFjayBhcyAkNThQaHMkdXNlQ2FsbGJhY2ssIHVzZVJlZiBhcyAkNThQaHMkdXNlUmVmLCB1c2VFZmZlY3QgYXMgJDU4UGhzJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUNvbGxlY3Rpb24gYXMgJDU4UGhzJHVzZUNvbGxlY3Rpb259IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJDU4UGhzJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICRhMDJkNTcwNDlkMjAyNjk1JGV4cG9ydCRkMDg1ZmI5ZTkyMGI1Y2E3IHtcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLml0ZXJhYmxlO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLnNpemU7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5rZXlzKCk7XG4gICAgfVxuICAgIGdldEtleUJlZm9yZShrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLnByZXZLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRLZXlBZnRlcihrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRGaXJzdEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RLZXk7XG4gICAgfVxuICAgIGdldExhc3RLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RLZXk7XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICB9XG4gICAgYXQoaWR4KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmdldEtleXMoKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleXNbaWR4XSk7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5jaGlsZE5vZGVzKSB8fCBbXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iobm9kZXMpe1xuICAgICAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG5vZGVzO1xuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIHRoaXMua2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzICYmIG5vZGUudHlwZSA9PT0gXCJzZWN0aW9uXCIpIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcyl2aXNpdChjaGlsZCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpdmlzaXQobm9kZSk7XG4gICAgICAgIGxldCBsYXN0O1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBba2V5LCBub2RlXSBvZiB0aGlzLmtleU1hcCl7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IGtleTtcbiAgICAgICAgICAgICAgICBub2RlLnByZXZLZXkgPSBsYXN0LmtleTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdEtleSA9IGtleTtcbiAgICAgICAgICAgICAgICBub2RlLnByZXZLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIml0ZW1cIikgbm9kZS5pbmRleCA9IGluZGV4Kys7XG4gICAgICAgICAgICBsYXN0ID0gbm9kZTtcbiAgICAgICAgICAgIC8vIFNldCBuZXh0S2V5IGFzIHVuZGVmaW5lZCBzaW5jZSB0aGlzIG1pZ2h0IGJlIHRoZSBsYXN0IG5vZGVcbiAgICAgICAgICAgIC8vIElmIGl0IGlzbid0IHRoZSBsYXN0IG5vZGUsIGxhc3QubmV4dEtleSB3aWxsIHByb3Blcmx5IHNldCBhdCBzdGFydCBvZiBuZXcgbG9vcFxuICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEtleSA9IGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC5rZXk7XG4gICAgfVxufVxuXG5cblxuXG5cbmZ1bmN0aW9uICRlNzJkZDcyZTFjNzZhMjI1JGV4cG9ydCQyZjY0NTY0NWY3YmNhNzY0KHByb3BzKSB7XG4gICAgbGV0IHsgZmlsdGVyOiBmaWx0ZXIgfSA9IHByb3BzO1xuICAgIGxldCBzZWxlY3Rpb25TdGF0ZSA9ICgwLCAkNThQaHMkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSkocHJvcHMpO1xuICAgIGxldCBkaXNhYmxlZEtleXMgPSAoMCwgJDU4UGhzJHVzZU1lbW8pKCgpPT5wcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCksIFtcbiAgICAgICAgcHJvcHMuZGlzYWJsZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IGZhY3RvcnkgPSAoMCwgJDU4UGhzJHVzZUNhbGxiYWNrKSgobm9kZXMpPT5maWx0ZXIgPyBuZXcgKDAsICRhMDJkNTcwNDlkMjAyNjk1JGV4cG9ydCRkMDg1ZmI5ZTkyMGI1Y2E3KShmaWx0ZXIobm9kZXMpKSA6IG5ldyAoMCwgJGEwMmQ1NzA0OWQyMDI2OTUkZXhwb3J0JGQwODVmYjllOTIwYjVjYTcpKG5vZGVzKSwgW1xuICAgICAgICBmaWx0ZXJcbiAgICBdKTtcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkNThQaHMkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmc6IHByb3BzLnN1cHByZXNzVGV4dFZhbHVlV2FybmluZ1xuICAgICAgICB9KSwgW1xuICAgICAgICBwcm9wcy5zdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmdcbiAgICBdKTtcbiAgICBsZXQgY29sbGVjdGlvbiA9ICgwLCAkNThQaHMkdXNlQ29sbGVjdGlvbikocHJvcHMsIGZhY3RvcnksIGNvbnRleHQpO1xuICAgIGxldCBzZWxlY3Rpb25NYW5hZ2VyID0gKDAsICQ1OFBocyR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkNThQaHMkU2VsZWN0aW9uTWFuYWdlcikoY29sbGVjdGlvbiwgc2VsZWN0aW9uU3RhdGUpLCBbXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIHNlbGVjdGlvblN0YXRlXG4gICAgXSk7XG4gICAgLy8gUmVzZXQgZm9jdXNlZCBrZXkgaWYgdGhhdCBpdGVtIGlzIGRlbGV0ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICBjb25zdCBjYWNoZWRDb2xsZWN0aW9uID0gKDAsICQ1OFBocyR1c2VSZWYpKG51bGwpO1xuICAgICgwLCAkNThQaHMkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSAhPSBudWxsICYmICFjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SXRlbSA9IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRJdGVtKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkSXRlbU5vZGVzID0gW1xuICAgICAgICAgICAgICAgIC4uLmNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRLZXlzKClcbiAgICAgICAgICAgIF0ubWFwKChrZXkpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbU5vZGUgPSBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQuZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtTm9kZS50eXBlID09PSBcIml0ZW1cIiA/IGl0ZW1Ob2RlIDogbnVsbDtcbiAgICAgICAgICAgIH0pLmZpbHRlcigobm9kZSk9Pm5vZGUgIT09IG51bGwpO1xuICAgICAgICAgICAgY29uc3QgaXRlbU5vZGVzID0gW1xuICAgICAgICAgICAgICAgIC4uLmNvbGxlY3Rpb24uZ2V0S2V5cygpXG4gICAgICAgICAgICBdLm1hcCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Ob2RlID0gY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1Ob2RlLnR5cGUgPT09IFwiaXRlbVwiID8gaXRlbU5vZGUgOiBudWxsO1xuICAgICAgICAgICAgfSkuZmlsdGVyKChub2RlKT0+bm9kZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gY2FjaGVkSXRlbU5vZGVzLmxlbmd0aCAtIGl0ZW1Ob2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBNYXRoLm1pbihkaWZmID4gMSA/IE1hdGgubWF4KHN0YXJ0SXRlbS5pbmRleCAtIGRpZmYgKyAxLCAwKSA6IHN0YXJ0SXRlbS5pbmRleCwgaXRlbU5vZGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgbGV0IG5ld05vZGU7XG4gICAgICAgICAgICB3aGlsZShpbmRleCA+PSAwKXtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbk1hbmFnZXIuaXNEaXNhYmxlZChpdGVtTm9kZXNbaW5kZXhdLmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZSA9IGl0ZW1Ob2Rlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaW5kIG5leHQsIG5vdCBkaXNhYmxlZCBpdGVtLlxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGl0ZW1Ob2Rlcy5sZW5ndGggLSAxKSBpbmRleCsrO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiBzdGFydEl0ZW0uaW5kZXgpIGluZGV4ID0gc3RhcnRJdGVtLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXkobmV3Tm9kZSA/IG5ld05vZGUua2V5IDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50ID0gY29sbGVjdGlvbjtcbiAgICB9LCBbXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXIsXG4gICAgICAgIHNlbGVjdGlvblN0YXRlLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5XG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXJcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkYTBkNjQ1Mjg5ZmU5Yjg2YiRleHBvcnQkZTdmMDVlOTg1ZGFmNGI1Zihwcm9wcykge1xuICAgIHZhciBfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5O1xuICAgIGxldCBbc2VsZWN0ZWRLZXksIHNldFNlbGVjdGVkS2V5XSA9ICgwLCAkNThQaHMkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5zZWxlY3RlZEtleSwgKF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgPSBwcm9wcy5kZWZhdWx0U2VsZWN0ZWRLZXkpICE9PSBudWxsICYmIF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgIT09IHZvaWQgMCA/IF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgOiBudWxsLCBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgbGV0IHNlbGVjdGVkS2V5cyA9ICgwLCAkNThQaHMkdXNlTWVtbykoKCk9PnNlbGVjdGVkS2V5ICE9IG51bGwgPyBbXG4gICAgICAgICAgICBzZWxlY3RlZEtleVxuICAgICAgICBdIDogW10sIFtcbiAgICAgICAgc2VsZWN0ZWRLZXlcbiAgICBdKTtcbiAgICBsZXQgeyBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLCBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cywgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlciB9ID0gKDAsICRlNzJkZDcyZTFjNzZhMjI1JGV4cG9ydCQyZjY0NTY0NWY3YmNhNzY0KSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBzZWxlY3Rpb25Nb2RlOiBcInNpbmdsZVwiLFxuICAgICAgICBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uOiB0cnVlLFxuICAgICAgICBhbGxvd0R1cGxpY2F0ZVNlbGVjdGlvbkV2ZW50czogdHJ1ZSxcbiAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXMsXG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlOiAoa2V5cyk9PntcbiAgICAgICAgICAgIHZhciBfa2V5c192YWx1ZXNfbmV4dF92YWx1ZTtcbiAgICAgICAgICAgIGxldCBrZXkgPSAoX2tleXNfdmFsdWVzX25leHRfdmFsdWUgPSBrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSkgIT09IG51bGwgJiYgX2tleXNfdmFsdWVzX25leHRfdmFsdWUgIT09IHZvaWQgMCA/IF9rZXlzX3ZhbHVlc19uZXh0X3ZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBmaXJlIG9uU2VsZWN0aW9uQ2hhbmdlLCBldmVuIGlmIHRoZSBrZXkgaXMgdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIGFzIHRoZSBjdXJyZW50IGtleSAodXNlQ29udHJvbGxlZFN0YXRlIGRvZXMgbm90KS5cbiAgICAgICAgICAgIGlmIChrZXkgPT09IHNlbGVjdGVkS2V5ICYmIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKSBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZShrZXkpO1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRLZXkoa2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBzZWxlY3RlZEl0ZW0gPSBzZWxlY3RlZEtleSAhPSBudWxsID8gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIsXG4gICAgICAgIHNlbGVjdGVkS2V5OiBzZWxlY3RlZEtleSxcbiAgICAgICAgc2V0U2VsZWN0ZWRLZXk6IHNldFNlbGVjdGVkS2V5LFxuICAgICAgICBzZWxlY3RlZEl0ZW06IHNlbGVjdGVkSXRlbVxuICAgIH07XG59XG5cblxuXG5cblxuZXhwb3J0IHskZTcyZGQ3MmUxYzc2YTIyNSRleHBvcnQkMmY2NDU2NDVmN2JjYTc2NCBhcyB1c2VMaXN0U3RhdGUsICRhMGQ2NDUyODlmZTliODZiJGV4cG9ydCRlN2YwNWU5ODVkYWY0YjVmIGFzIHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSwgJGEwMmQ1NzA0OWQyMDI2OTUkZXhwb3J0JGQwODVmYjllOTIwYjVjYTcgYXMgTGlzdENvbGxlY3Rpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCIkNThQaHMkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSIsIlNlbGVjdGlvbk1hbmFnZXIiLCIkNThQaHMkU2VsZWN0aW9uTWFuYWdlciIsInVzZU1lbW8iLCIkNThQaHMkdXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiJDU4UGhzJHVzZUNhbGxiYWNrIiwidXNlUmVmIiwiJDU4UGhzJHVzZVJlZiIsInVzZUVmZmVjdCIsIiQ1OFBocyR1c2VFZmZlY3QiLCJ1c2VDb2xsZWN0aW9uIiwiJDU4UGhzJHVzZUNvbGxlY3Rpb24iLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkNThQaHMkdXNlQ29udHJvbGxlZFN0YXRlIiwiJGEwMmQ1NzA0OWQyMDI2OTUkZXhwb3J0JGQwODVmYjllOTIwYjVjYTciLCJTeW1ib2wiLCJpdGVyYXRvciIsIml0ZXJhYmxlIiwic2l6ZSIsImtleU1hcCIsImdldEtleXMiLCJrZXlzIiwiZ2V0S2V5QmVmb3JlIiwia2V5Iiwibm9kZSIsImdldCIsInByZXZLZXkiLCJnZXRLZXlBZnRlciIsIm5leHRLZXkiLCJnZXRGaXJzdEtleSIsImZpcnN0S2V5IiwiZ2V0TGFzdEtleSIsImxhc3RLZXkiLCJnZXRJdGVtIiwiYXQiLCJpZHgiLCJnZXRDaGlsZHJlbiIsImNoaWxkTm9kZXMiLCJjb25zdHJ1Y3RvciIsIm5vZGVzIiwiTWFwIiwidmlzaXQiLCJzZXQiLCJ0eXBlIiwiY2hpbGQiLCJsYXN0IiwiaW5kZXgiLCJ1bmRlZmluZWQiLCIkZTcyZGQ3MmUxYzc2YTIyNSRleHBvcnQkMmY2NDU2NDVmN2JjYTc2NCIsInByb3BzIiwiZmlsdGVyIiwic2VsZWN0aW9uU3RhdGUiLCJkaXNhYmxlZEtleXMiLCJTZXQiLCJmYWN0b3J5IiwiY29udGV4dCIsInN1cHByZXNzVGV4dFZhbHVlV2FybmluZyIsImNvbGxlY3Rpb24iLCJzZWxlY3Rpb25NYW5hZ2VyIiwiY2FjaGVkQ29sbGVjdGlvbiIsImZvY3VzZWRLZXkiLCJzdGFydEl0ZW0iLCJjdXJyZW50IiwiY2FjaGVkSXRlbU5vZGVzIiwibWFwIiwiaXRlbU5vZGUiLCJpdGVtTm9kZXMiLCJkaWZmIiwibGVuZ3RoIiwiTWF0aCIsIm1pbiIsIm1heCIsIm5ld05vZGUiLCJpc0Rpc2FibGVkIiwic2V0Rm9jdXNlZEtleSIsIiRhMGQ2NDUyODlmZTliODZiJGV4cG9ydCRlN2YwNWU5ODVkYWY0YjVmIiwiX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSIsInNlbGVjdGVkS2V5Iiwic2V0U2VsZWN0ZWRLZXkiLCJkZWZhdWx0U2VsZWN0ZWRLZXkiLCJvblNlbGVjdGlvbkNoYW5nZSIsInNlbGVjdGVkS2V5cyIsInNlbGVjdGlvbk1vZGUiLCJkaXNhbGxvd0VtcHR5U2VsZWN0aW9uIiwiYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHMiLCJfa2V5c192YWx1ZXNfbmV4dF92YWx1ZSIsInZhbHVlcyIsIm5leHQiLCJ2YWx1ZSIsInNlbGVjdGVkSXRlbSIsInVzZUxpc3RTdGF0ZSIsInVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSIsIkxpc3RDb2xsZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/list/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/menu/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/menu/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UNSTABLE_useSubmenuTriggerState: () => (/* binding */ $e5614764aa47eb35$export$d39fdbfa42246ac4),\n/* harmony export */   useMenuTriggerState: () => (/* binding */ $a28c903ee9ad8dc5$export$79fefeb1c2091ac3)\n/* harmony export */ });\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {\n    let overlayTriggerState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let [expandedKeysStack, setExpandedKeysStack] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let closeAll = ()=>{\n        setExpandedKeysStack([]);\n        overlayTriggerState.close();\n    };\n    let openSubmenu = (triggerKey, level)=>{\n        setExpandedKeysStack((oldStack)=>{\n            if (level > oldStack.length) return oldStack;\n            return [\n                ...oldStack.slice(0, level),\n                triggerKey\n            ];\n        });\n    };\n    let closeSubmenu = (triggerKey, level)=>{\n        setExpandedKeysStack((oldStack)=>{\n            let key = oldStack[level];\n            if (key === triggerKey) return oldStack.slice(0, level);\n            else return oldStack;\n        });\n    };\n    return {\n        focusStrategy: focusStrategy,\n        ...overlayTriggerState,\n        open (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.open();\n        },\n        toggle (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.toggle();\n        },\n        close () {\n            closeAll();\n        },\n        UNSTABLE_expandedKeysStack: expandedKeysStack,\n        UNSTABLE_openSubmenu: openSubmenu,\n        UNSTABLE_closeSubmenu: closeSubmenu\n    };\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e5614764aa47eb35$export$d39fdbfa42246ac4(props, state) {\n    let { triggerKey: triggerKey } = props;\n    let { UNSTABLE_expandedKeysStack: UNSTABLE_expandedKeysStack, UNSTABLE_openSubmenu: UNSTABLE_openSubmenu, UNSTABLE_closeSubmenu: UNSTABLE_closeSubmenu, close: closeAll } = state;\n    let [submenuLevel] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(UNSTABLE_expandedKeysStack === null || UNSTABLE_expandedKeysStack === void 0 ? void 0 : UNSTABLE_expandedKeysStack.length);\n    let isOpen = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>UNSTABLE_expandedKeysStack[submenuLevel] === triggerKey, [\n        UNSTABLE_expandedKeysStack,\n        triggerKey,\n        submenuLevel\n    ]);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        setFocusStrategy(focusStrategy);\n        UNSTABLE_openSubmenu(triggerKey, submenuLevel);\n    }, [\n        UNSTABLE_openSubmenu,\n        submenuLevel,\n        triggerKey\n    ]);\n    let close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFocusStrategy(null);\n        UNSTABLE_closeSubmenu(triggerKey, submenuLevel);\n    }, [\n        UNSTABLE_closeSubmenu,\n        submenuLevel,\n        triggerKey\n    ]);\n    let toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        setFocusStrategy(focusStrategy);\n        if (isOpen) close();\n        else open(focusStrategy);\n    }, [\n        close,\n        open,\n        isOpen\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            focusStrategy: focusStrategy,\n            isOpen: isOpen,\n            open: open,\n            close: close,\n            closeAll: closeAll,\n            submenuLevel: submenuLevel,\n            // TODO: Placeholders that aren't used but give us parity with OverlayTriggerState so we can use this in Popover. Refactor if we update Popover via\n            // https://github.com/adobe/react-spectrum/pull/4976#discussion_r1336472863\n            setOpen: ()=>{},\n            toggle: toggle\n        }), [\n        isOpen,\n        open,\n        close,\n        closeAll,\n        focusStrategy,\n        toggle,\n        submenuLevel\n    ]);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbWVudS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNnQjtBQUVoSDs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELFNBQVNRLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJQyxzQkFBc0IsQ0FBQyxHQUFHVCwyRUFBNEIsRUFBR1E7SUFDN0QsSUFBSSxDQUFDRSxlQUFlQyxpQkFBaUIsR0FBRyxDQUFDLEdBQUdULDJDQUFjLEVBQUc7SUFDN0QsSUFBSSxDQUFDVSxtQkFBbUJDLHFCQUFxQixHQUFHLENBQUMsR0FBR1gsMkNBQWMsRUFBRyxFQUFFO0lBQ3ZFLElBQUlZLFdBQVc7UUFDWEQscUJBQXFCLEVBQUU7UUFDdkJKLG9CQUFvQk0sS0FBSztJQUM3QjtJQUNBLElBQUlDLGNBQWMsQ0FBQ0MsWUFBWUM7UUFDM0JMLHFCQUFxQixDQUFDTTtZQUNsQixJQUFJRCxRQUFRQyxTQUFTQyxNQUFNLEVBQUUsT0FBT0Q7WUFDcEMsT0FBTzttQkFDQUEsU0FBU0UsS0FBSyxDQUFDLEdBQUdIO2dCQUNyQkQ7YUFDSDtRQUNMO0lBQ0o7SUFDQSxJQUFJSyxlQUFlLENBQUNMLFlBQVlDO1FBQzVCTCxxQkFBcUIsQ0FBQ007WUFDbEIsSUFBSUksTUFBTUosUUFBUSxDQUFDRCxNQUFNO1lBQ3pCLElBQUlLLFFBQVFOLFlBQVksT0FBT0UsU0FBU0UsS0FBSyxDQUFDLEdBQUdIO2lCQUM1QyxPQUFPQztRQUNoQjtJQUNKO0lBQ0EsT0FBTztRQUNIVCxlQUFlQTtRQUNmLEdBQUdELG1CQUFtQjtRQUN0QmUsTUFBTWQsZ0JBQWdCLElBQUk7WUFDdEJDLGlCQUFpQkQ7WUFDakJELG9CQUFvQmUsSUFBSTtRQUM1QjtRQUNBQyxRQUFRZixnQkFBZ0IsSUFBSTtZQUN4QkMsaUJBQWlCRDtZQUNqQkQsb0JBQW9CZ0IsTUFBTTtRQUM5QjtRQUNBVjtZQUNJRDtRQUNKO1FBQ0FZLDRCQUE0QmQ7UUFDNUJlLHNCQUFzQlg7UUFDdEJZLHVCQUF1Qk47SUFDM0I7QUFDSjtBQUdBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTTywwQ0FBMENyQixLQUFLLEVBQUVzQixLQUFLO0lBQzNELElBQUksRUFBRWIsWUFBWUEsVUFBVSxFQUFFLEdBQUdUO0lBQ2pDLElBQUksRUFBRWtCLDRCQUE0QkEsMEJBQTBCLEVBQUVDLHNCQUFzQkEsb0JBQW9CLEVBQUVDLHVCQUF1QkEscUJBQXFCLEVBQUViLE9BQU9ELFFBQVEsRUFBRSxHQUFHZ0I7SUFDNUssSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQyxHQUFHN0IsMkNBQWMsRUFBR3dCLCtCQUErQixRQUFRQSwrQkFBK0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsMkJBQTJCTixNQUFNO0lBQ25LLElBQUlZLFNBQVMsQ0FBQyxHQUFHNUIsMENBQWEsRUFBRyxJQUFJc0IsMEJBQTBCLENBQUNLLGFBQWEsS0FBS2QsWUFBWTtRQUMxRlM7UUFDQVQ7UUFDQWM7S0FDSDtJQUNELElBQUksQ0FBQ3JCLGVBQWVDLGlCQUFpQixHQUFHLENBQUMsR0FBR1QsMkNBQWMsRUFBRztJQUM3RCxJQUFJc0IsT0FBTyxDQUFDLEdBQUdsQiw4Q0FBaUIsRUFBRyxDQUFDSSxnQkFBZ0IsSUFBSTtRQUNwREMsaUJBQWlCRDtRQUNqQmlCLHFCQUFxQlYsWUFBWWM7SUFDckMsR0FBRztRQUNDSjtRQUNBSTtRQUNBZDtLQUNIO0lBQ0QsSUFBSUYsUUFBUSxDQUFDLEdBQUdULDhDQUFpQixFQUFHO1FBQ2hDSyxpQkFBaUI7UUFDakJpQixzQkFBc0JYLFlBQVljO0lBQ3RDLEdBQUc7UUFDQ0g7UUFDQUc7UUFDQWQ7S0FDSDtJQUNELElBQUlRLFNBQVMsQ0FBQyxHQUFHbkIsOENBQWlCLEVBQUcsQ0FBQ0ksZ0JBQWdCLElBQUk7UUFDdERDLGlCQUFpQkQ7UUFDakIsSUFBSXNCLFFBQVFqQjthQUNQUyxLQUFLZDtJQUNkLEdBQUc7UUFDQ0s7UUFDQVM7UUFDQVE7S0FDSDtJQUNELE9BQU8sQ0FBQyxHQUFHNUIsMENBQWEsRUFBRyxJQUFLO1lBQ3hCTSxlQUFlQTtZQUNmc0IsUUFBUUE7WUFDUlIsTUFBTUE7WUFDTlQsT0FBT0E7WUFDUEQsVUFBVUE7WUFDVmlCLGNBQWNBO1lBQ2QsbUpBQW1KO1lBQ25KLDJFQUEyRTtZQUMzRUUsU0FBUyxLQUFLO1lBQ2RSLFFBQVFBO1FBQ1osSUFBSTtRQUNKTztRQUNBUjtRQUNBVDtRQUNBRDtRQUNBSjtRQUNBZTtRQUNBTTtLQUNIO0FBQ0w7QUFLd0osQ0FDeEosa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbWVudS9kaXN0L2ltcG9ydC5tanM/MWI1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZU92ZXJsYXlUcmlnZ2VyU3RhdGUgYXMgJDlYdm9oJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9vdmVybGF5c1wiO1xuaW1wb3J0IHt1c2VTdGF0ZSBhcyAkOVh2b2gkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDlYdm9oJHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICQ5WHZvaCR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICRhMjhjOTAzZWU5YWQ4ZGM1JGV4cG9ydCQ3OWZlZmViMWMyMDkxYWMzKHByb3BzKSB7XG4gICAgbGV0IG92ZXJsYXlUcmlnZ2VyU3RhdGUgPSAoMCwgJDlYdm9oJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUpKHByb3BzKTtcbiAgICBsZXQgW2ZvY3VzU3RyYXRlZ3ksIHNldEZvY3VzU3RyYXRlZ3ldID0gKDAsICQ5WHZvaCR1c2VTdGF0ZSkobnVsbCk7XG4gICAgbGV0IFtleHBhbmRlZEtleXNTdGFjaywgc2V0RXhwYW5kZWRLZXlzU3RhY2tdID0gKDAsICQ5WHZvaCR1c2VTdGF0ZSkoW10pO1xuICAgIGxldCBjbG9zZUFsbCA9ICgpPT57XG4gICAgICAgIHNldEV4cGFuZGVkS2V5c1N0YWNrKFtdKTtcbiAgICAgICAgb3ZlcmxheVRyaWdnZXJTdGF0ZS5jbG9zZSgpO1xuICAgIH07XG4gICAgbGV0IG9wZW5TdWJtZW51ID0gKHRyaWdnZXJLZXksIGxldmVsKT0+e1xuICAgICAgICBzZXRFeHBhbmRlZEtleXNTdGFjaygob2xkU3RhY2spPT57XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBvbGRTdGFjay5sZW5ndGgpIHJldHVybiBvbGRTdGFjaztcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLi4ub2xkU3RhY2suc2xpY2UoMCwgbGV2ZWwpLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJLZXlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgbGV0IGNsb3NlU3VibWVudSA9ICh0cmlnZ2VyS2V5LCBsZXZlbCk9PntcbiAgICAgICAgc2V0RXhwYW5kZWRLZXlzU3RhY2soKG9sZFN0YWNrKT0+e1xuICAgICAgICAgICAgbGV0IGtleSA9IG9sZFN0YWNrW2xldmVsXTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHRyaWdnZXJLZXkpIHJldHVybiBvbGRTdGFjay5zbGljZSgwLCBsZXZlbCk7XG4gICAgICAgICAgICBlbHNlIHJldHVybiBvbGRTdGFjaztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb2N1c1N0cmF0ZWd5OiBmb2N1c1N0cmF0ZWd5LFxuICAgICAgICAuLi5vdmVybGF5VHJpZ2dlclN0YXRlLFxuICAgICAgICBvcGVuIChmb2N1c1N0cmF0ZWd5ID0gbnVsbCkge1xuICAgICAgICAgICAgc2V0Rm9jdXNTdHJhdGVneShmb2N1c1N0cmF0ZWd5KTtcbiAgICAgICAgICAgIG92ZXJsYXlUcmlnZ2VyU3RhdGUub3BlbigpO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGUgKGZvY3VzU3RyYXRlZ3kgPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xuICAgICAgICAgICAgb3ZlcmxheVRyaWdnZXJTdGF0ZS50b2dnbGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2UgKCkge1xuICAgICAgICAgICAgY2xvc2VBbGwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2s6IGV4cGFuZGVkS2V5c1N0YWNrLFxuICAgICAgICBVTlNUQUJMRV9vcGVuU3VibWVudTogb3BlblN1Ym1lbnUsXG4gICAgICAgIFVOU1RBQkxFX2Nsb3NlU3VibWVudTogY2xvc2VTdWJtZW51XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkZTU2MTQ3NjRhYTQ3ZWIzNSRleHBvcnQkZDM5ZmRiZmE0MjI0NmFjNChwcm9wcywgc3RhdGUpIHtcbiAgICBsZXQgeyB0cmlnZ2VyS2V5OiB0cmlnZ2VyS2V5IH0gPSBwcm9wcztcbiAgICBsZXQgeyBVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjazogVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2ssIFVOU1RBQkxFX29wZW5TdWJtZW51OiBVTlNUQUJMRV9vcGVuU3VibWVudSwgVU5TVEFCTEVfY2xvc2VTdWJtZW51OiBVTlNUQUJMRV9jbG9zZVN1Ym1lbnUsIGNsb3NlOiBjbG9zZUFsbCB9ID0gc3RhdGU7XG4gICAgbGV0IFtzdWJtZW51TGV2ZWxdID0gKDAsICQ5WHZvaCR1c2VTdGF0ZSkoVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2sgPT09IG51bGwgfHwgVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IFVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrLmxlbmd0aCk7XG4gICAgbGV0IGlzT3BlbiA9ICgwLCAkOVh2b2gkdXNlTWVtbykoKCk9PlVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrW3N1Ym1lbnVMZXZlbF0gPT09IHRyaWdnZXJLZXksIFtcbiAgICAgICAgVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2ssXG4gICAgICAgIHRyaWdnZXJLZXksXG4gICAgICAgIHN1Ym1lbnVMZXZlbFxuICAgIF0pO1xuICAgIGxldCBbZm9jdXNTdHJhdGVneSwgc2V0Rm9jdXNTdHJhdGVneV0gPSAoMCwgJDlYdm9oJHVzZVN0YXRlKShudWxsKTtcbiAgICBsZXQgb3BlbiA9ICgwLCAkOVh2b2gkdXNlQ2FsbGJhY2spKChmb2N1c1N0cmF0ZWd5ID0gbnVsbCk9PntcbiAgICAgICAgc2V0Rm9jdXNTdHJhdGVneShmb2N1c1N0cmF0ZWd5KTtcbiAgICAgICAgVU5TVEFCTEVfb3BlblN1Ym1lbnUodHJpZ2dlcktleSwgc3VibWVudUxldmVsKTtcbiAgICB9LCBbXG4gICAgICAgIFVOU1RBQkxFX29wZW5TdWJtZW51LFxuICAgICAgICBzdWJtZW51TGV2ZWwsXG4gICAgICAgIHRyaWdnZXJLZXlcbiAgICBdKTtcbiAgICBsZXQgY2xvc2UgPSAoMCwgJDlYdm9oJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KG51bGwpO1xuICAgICAgICBVTlNUQUJMRV9jbG9zZVN1Ym1lbnUodHJpZ2dlcktleSwgc3VibWVudUxldmVsKTtcbiAgICB9LCBbXG4gICAgICAgIFVOU1RBQkxFX2Nsb3NlU3VibWVudSxcbiAgICAgICAgc3VibWVudUxldmVsLFxuICAgICAgICB0cmlnZ2VyS2V5XG4gICAgXSk7XG4gICAgbGV0IHRvZ2dsZSA9ICgwLCAkOVh2b2gkdXNlQ2FsbGJhY2spKChmb2N1c1N0cmF0ZWd5ID0gbnVsbCk9PntcbiAgICAgICAgc2V0Rm9jdXNTdHJhdGVneShmb2N1c1N0cmF0ZWd5KTtcbiAgICAgICAgaWYgKGlzT3BlbikgY2xvc2UoKTtcbiAgICAgICAgZWxzZSBvcGVuKGZvY3VzU3RyYXRlZ3kpO1xuICAgIH0sIFtcbiAgICAgICAgY2xvc2UsXG4gICAgICAgIG9wZW4sXG4gICAgICAgIGlzT3BlblxuICAgIF0pO1xuICAgIHJldHVybiAoMCwgJDlYdm9oJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgZm9jdXNTdHJhdGVneTogZm9jdXNTdHJhdGVneSxcbiAgICAgICAgICAgIGlzT3BlbjogaXNPcGVuLFxuICAgICAgICAgICAgb3Blbjogb3BlbixcbiAgICAgICAgICAgIGNsb3NlOiBjbG9zZSxcbiAgICAgICAgICAgIGNsb3NlQWxsOiBjbG9zZUFsbCxcbiAgICAgICAgICAgIHN1Ym1lbnVMZXZlbDogc3VibWVudUxldmVsLFxuICAgICAgICAgICAgLy8gVE9ETzogUGxhY2Vob2xkZXJzIHRoYXQgYXJlbid0IHVzZWQgYnV0IGdpdmUgdXMgcGFyaXR5IHdpdGggT3ZlcmxheVRyaWdnZXJTdGF0ZSBzbyB3ZSBjYW4gdXNlIHRoaXMgaW4gUG9wb3Zlci4gUmVmYWN0b3IgaWYgd2UgdXBkYXRlIFBvcG92ZXIgdmlhXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUvcmVhY3Qtc3BlY3RydW0vcHVsbC80OTc2I2Rpc2N1c3Npb25fcjEzMzY0NzI4NjNcbiAgICAgICAgICAgIHNldE9wZW46ICgpPT57fSxcbiAgICAgICAgICAgIHRvZ2dsZTogdG9nZ2xlXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGlzT3BlbixcbiAgICAgICAgb3BlbixcbiAgICAgICAgY2xvc2UsXG4gICAgICAgIGNsb3NlQWxsLFxuICAgICAgICBmb2N1c1N0cmF0ZWd5LFxuICAgICAgICB0b2dnbGUsXG4gICAgICAgIHN1Ym1lbnVMZXZlbFxuICAgIF0pO1xufVxuXG5cblxuXG5leHBvcnQgeyRhMjhjOTAzZWU5YWQ4ZGM1JGV4cG9ydCQ3OWZlZmViMWMyMDkxYWMzIGFzIHVzZU1lbnVUcmlnZ2VyU3RhdGUsICRlNTYxNDc2NGFhNDdlYjM1JGV4cG9ydCRkMzlmZGJmYTQyMjQ2YWM0IGFzIFVOU1RBQkxFX3VzZVN1Ym1lbnVUcmlnZ2VyU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUiLCIkOVh2b2gkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSIsInVzZVN0YXRlIiwiJDlYdm9oJHVzZVN0YXRlIiwidXNlTWVtbyIsIiQ5WHZvaCR1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCIkOVh2b2gkdXNlQ2FsbGJhY2siLCIkYTI4YzkwM2VlOWFkOGRjNSRleHBvcnQkNzlmZWZlYjFjMjA5MWFjMyIsInByb3BzIiwib3ZlcmxheVRyaWdnZXJTdGF0ZSIsImZvY3VzU3RyYXRlZ3kiLCJzZXRGb2N1c1N0cmF0ZWd5IiwiZXhwYW5kZWRLZXlzU3RhY2siLCJzZXRFeHBhbmRlZEtleXNTdGFjayIsImNsb3NlQWxsIiwiY2xvc2UiLCJvcGVuU3VibWVudSIsInRyaWdnZXJLZXkiLCJsZXZlbCIsIm9sZFN0YWNrIiwibGVuZ3RoIiwic2xpY2UiLCJjbG9zZVN1Ym1lbnUiLCJrZXkiLCJvcGVuIiwidG9nZ2xlIiwiVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2siLCJVTlNUQUJMRV9vcGVuU3VibWVudSIsIlVOU1RBQkxFX2Nsb3NlU3VibWVudSIsIiRlNTYxNDc2NGFhNDdlYjM1JGV4cG9ydCRkMzlmZGJmYTQyMjQ2YWM0Iiwic3RhdGUiLCJzdWJtZW51TGV2ZWwiLCJpc09wZW4iLCJzZXRPcGVuIiwidXNlTWVudVRyaWdnZXJTdGF0ZSIsIlVOU1RBQkxFX3VzZVN1Ym1lbnVUcmlnZ2VyU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/menu/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/overlays/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOverlayTriggerState: () => (/* binding */ $fc909762b330b746$export$61c6a8c84e605fb6)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $fc909762b330b746$export$61c6a8c84e605fb6(props) {\n    let [isOpen, setOpen] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.isOpen, props.defaultOpen || false, props.onOpenChange);\n    const open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(true);\n    }, [\n        setOpen\n    ]);\n    const close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(false);\n    }, [\n        setOpen\n    ]);\n    const toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(!isOpen);\n    }, [\n        setOpen,\n        isOpen\n    ]);\n    return {\n        isOpen: isOpen,\n        setOpen: setOpen,\n        open: open,\n        close: close,\n        toggle: toggle\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RDtBQUM2QjtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELFNBQVNJLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLENBQUNDLFFBQVFDLFFBQVEsR0FBRyxDQUFDLEdBQUdKLG9FQUF3QixFQUFHRSxNQUFNQyxNQUFNLEVBQUVELE1BQU1HLFdBQVcsSUFBSSxPQUFPSCxNQUFNSSxZQUFZO0lBQ25ILE1BQU1DLE9BQU8sQ0FBQyxHQUFHVCw4Q0FBaUIsRUFBRztRQUNqQ00sUUFBUTtJQUNaLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE1BQU1JLFFBQVEsQ0FBQyxHQUFHViw4Q0FBaUIsRUFBRztRQUNsQ00sUUFBUTtJQUNaLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE1BQU1LLFNBQVMsQ0FBQyxHQUFHWCw4Q0FBaUIsRUFBRztRQUNuQ00sUUFBUSxDQUFDRDtJQUNiLEdBQUc7UUFDQ0M7UUFDQUQ7S0FDSDtJQUNELE9BQU87UUFDSEEsUUFBUUE7UUFDUkMsU0FBU0E7UUFDVEcsTUFBTUE7UUFDTkMsT0FBT0E7UUFDUEMsUUFBUUE7SUFDWjtBQUNKO0FBSzZFLENBQzdFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L292ZXJsYXlzL2Rpc3QvaW1wb3J0Lm1qcz8wN2E0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlQ2FsbGJhY2sgYXMgJDRvQTNQJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICQ0b0EzUCR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkZmM5MDk3NjJiMzMwYjc0NiRleHBvcnQkNjFjNmE4Yzg0ZTYwNWZiNihwcm9wcykge1xuICAgIGxldCBbaXNPcGVuLCBzZXRPcGVuXSA9ICgwLCAkNG9BM1AkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5pc09wZW4sIHByb3BzLmRlZmF1bHRPcGVuIHx8IGZhbHNlLCBwcm9wcy5vbk9wZW5DaGFuZ2UpO1xuICAgIGNvbnN0IG9wZW4gPSAoMCwgJDRvQTNQJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRPcGVuKHRydWUpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0T3BlblxuICAgIF0pO1xuICAgIGNvbnN0IGNsb3NlID0gKDAsICQ0b0EzUCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0T3BlbihmYWxzZSk7XG4gICAgfSwgW1xuICAgICAgICBzZXRPcGVuXG4gICAgXSk7XG4gICAgY29uc3QgdG9nZ2xlID0gKDAsICQ0b0EzUCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0T3BlbighaXNPcGVuKTtcbiAgICB9LCBbXG4gICAgICAgIHNldE9wZW4sXG4gICAgICAgIGlzT3BlblxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzT3BlbjogaXNPcGVuLFxuICAgICAgICBzZXRPcGVuOiBzZXRPcGVuLFxuICAgICAgICBvcGVuOiBvcGVuLFxuICAgICAgICBjbG9zZTogY2xvc2UsXG4gICAgICAgIHRvZ2dsZTogdG9nZ2xlXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskZmM5MDk3NjJiMzMwYjc0NiRleHBvcnQkNjFjNmE4Yzg0ZTYwNWZiNiBhcyB1c2VPdmVybGF5VHJpZ2dlclN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsIiQ0b0EzUCR1c2VDYWxsYmFjayIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiQ0b0EzUCR1c2VDb250cm9sbGVkU3RhdGUiLCIkZmM5MDk3NjJiMzMwYjc0NiRleHBvcnQkNjFjNmE4Yzg0ZTYwNWZiNiIsInByb3BzIiwiaXNPcGVuIiwic2V0T3BlbiIsImRlZmF1bHRPcGVuIiwib25PcGVuQ2hhbmdlIiwib3BlbiIsImNsb3NlIiwidG9nZ2xlIiwidXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/radio/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/radio/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useRadioGroupState: () => (/* binding */ $a54cdc5c1942b639$export$bca9d026f8e704eb)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $a54cdc5c1942b639$var$instance = Math.round(Math.random() * 10000000000);\nlet $a54cdc5c1942b639$var$i = 0;\nfunction $a54cdc5c1942b639$export$bca9d026f8e704eb(props) {\n    // Preserved here for backward compatibility. React Aria now generates the name instead of stately.\n    let name = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.name || `radio-group-${$a54cdc5c1942b639$var$instance}-${++$a54cdc5c1942b639$var$i}`, [\n        props.name\n    ]);\n    var _props_defaultValue;\n    let [selectedValue, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : null, props.onChange);\n    let [lastFocusedValue, setLastFocusedValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.useFormValidationState)({\n        ...props,\n        value: selectedValue\n    });\n    let setSelectedValue = (value)=>{\n        if (!props.isReadOnly && !props.isDisabled) {\n            setSelected(value);\n            validation.commitValidation();\n        }\n    };\n    let isInvalid = validation.displayValidation.isInvalid;\n    return {\n        ...validation,\n        name: name,\n        selectedValue: selectedValue,\n        setSelectedValue: setSelectedValue,\n        lastFocusedValue: lastFocusedValue,\n        setLastFocusedValue: setLastFocusedValue,\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isRequired: props.isRequired || false,\n        validationState: props.validationState || (isInvalid ? \"invalid\" : null),\n        isInvalid: isInvalid\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvcmFkaW8vZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEY7QUFDUDtBQUNSO0FBRTdFOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBR0QsSUFBSVEsaUNBQWlDQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSztBQUNoRSxJQUFJQywwQkFBMEI7QUFDOUIsU0FBU0MsMENBQTBDQyxLQUFLO0lBQ3BELG1HQUFtRztJQUNuRyxJQUFJQyxPQUFPLENBQUMsR0FBR1YsMENBQWEsRUFBRyxJQUFJUyxNQUFNQyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUVQLCtCQUErQixDQUFDLEVBQUUsRUFBRUksd0JBQXdCLENBQUMsRUFBRTtRQUMzSEUsTUFBTUMsSUFBSTtLQUNiO0lBQ0QsSUFBSUM7SUFDSixJQUFJLENBQUNDLGVBQWVDLFlBQVksR0FBRyxDQUFDLEdBQUdmLG9FQUF3QixFQUFHVyxNQUFNSyxLQUFLLEVBQUUsQ0FBQ0gsc0JBQXNCRixNQUFNTSxZQUFZLE1BQU0sUUFBUUosd0JBQXdCLEtBQUssSUFBSUEsc0JBQXNCLE1BQU1GLE1BQU1PLFFBQVE7SUFDak4sSUFBSSxDQUFDQyxrQkFBa0JDLG9CQUFvQixHQUFHLENBQUMsR0FBR2hCLDJDQUFjLEVBQUc7SUFDbkUsSUFBSWlCLGFBQWEsQ0FBQyxHQUFHdkIsdUVBQTRCLEVBQUc7UUFDaEQsR0FBR2EsS0FBSztRQUNSSyxPQUFPRjtJQUNYO0lBQ0EsSUFBSVEsbUJBQW1CLENBQUNOO1FBQ3BCLElBQUksQ0FBQ0wsTUFBTVksVUFBVSxJQUFJLENBQUNaLE1BQU1hLFVBQVUsRUFBRTtZQUN4Q1QsWUFBWUM7WUFDWkssV0FBV0ksZ0JBQWdCO1FBQy9CO0lBQ0o7SUFDQSxJQUFJQyxZQUFZTCxXQUFXTSxpQkFBaUIsQ0FBQ0QsU0FBUztJQUN0RCxPQUFPO1FBQ0gsR0FBR0wsVUFBVTtRQUNiVCxNQUFNQTtRQUNORSxlQUFlQTtRQUNmUSxrQkFBa0JBO1FBQ2xCSCxrQkFBa0JBO1FBQ2xCQyxxQkFBcUJBO1FBQ3JCSSxZQUFZYixNQUFNYSxVQUFVLElBQUk7UUFDaENELFlBQVlaLE1BQU1ZLFVBQVUsSUFBSTtRQUNoQ0ssWUFBWWpCLE1BQU1pQixVQUFVLElBQUk7UUFDaENDLGlCQUFpQmxCLE1BQU1rQixlQUFlLElBQUtILENBQUFBLFlBQVksWUFBWSxJQUFHO1FBQ3RFQSxXQUFXQTtJQUNmO0FBQ0o7QUFLeUUsQ0FDekUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvcmFkaW8vZGlzdC9pbXBvcnQubWpzPzMzZTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VGb3JtVmFsaWRhdGlvblN0YXRlIGFzICRmUTJTRiR1c2VGb3JtVmFsaWRhdGlvblN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZm9ybVwiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJGZRMlNGJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZU1lbW8gYXMgJGZRMlNGJHVzZU1lbW8sIHVzZVN0YXRlIGFzICRmUTJTRiR1c2VTdGF0ZX0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxubGV0ICRhNTRjZGM1YzE5NDJiNjM5JHZhciRpbnN0YW5jZSA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKTtcbmxldCAkYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaSA9IDA7XG5mdW5jdGlvbiAkYTU0Y2RjNWMxOTQyYjYzOSRleHBvcnQkYmNhOWQwMjZmOGU3MDRlYihwcm9wcykge1xuICAgIC8vIFByZXNlcnZlZCBoZXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBSZWFjdCBBcmlhIG5vdyBnZW5lcmF0ZXMgdGhlIG5hbWUgaW5zdGVhZCBvZiBzdGF0ZWx5LlxuICAgIGxldCBuYW1lID0gKDAsICRmUTJTRiR1c2VNZW1vKSgoKT0+cHJvcHMubmFtZSB8fCBgcmFkaW8tZ3JvdXAtJHskYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaW5zdGFuY2V9LSR7KyskYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaX1gLCBbXG4gICAgICAgIHByb3BzLm5hbWVcbiAgICBdKTtcbiAgICB2YXIgX3Byb3BzX2RlZmF1bHRWYWx1ZTtcbiAgICBsZXQgW3NlbGVjdGVkVmFsdWUsIHNldFNlbGVjdGVkXSA9ICgwLCAkZlEyU0YkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy52YWx1ZSwgKF9wcm9wc19kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWUpICE9PSBudWxsICYmIF9wcm9wc19kZWZhdWx0VmFsdWUgIT09IHZvaWQgMCA/IF9wcm9wc19kZWZhdWx0VmFsdWUgOiBudWxsLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgbGV0IFtsYXN0Rm9jdXNlZFZhbHVlLCBzZXRMYXN0Rm9jdXNlZFZhbHVlXSA9ICgwLCAkZlEyU0YkdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCB2YWxpZGF0aW9uID0gKDAsICRmUTJTRiR1c2VGb3JtVmFsaWRhdGlvblN0YXRlKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICB2YWx1ZTogc2VsZWN0ZWRWYWx1ZVxuICAgIH0pO1xuICAgIGxldCBzZXRTZWxlY3RlZFZhbHVlID0gKHZhbHVlKT0+e1xuICAgICAgICBpZiAoIXByb3BzLmlzUmVhZE9ubHkgJiYgIXByb3BzLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbGlkYXRpb24uY29tbWl0VmFsaWRhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgaXNJbnZhbGlkID0gdmFsaWRhdGlvbi5kaXNwbGF5VmFsaWRhdGlvbi5pc0ludmFsaWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udmFsaWRhdGlvbixcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgc2V0U2VsZWN0ZWRWYWx1ZTogc2V0U2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgbGFzdEZvY3VzZWRWYWx1ZTogbGFzdEZvY3VzZWRWYWx1ZSxcbiAgICAgICAgc2V0TGFzdEZvY3VzZWRWYWx1ZTogc2V0TGFzdEZvY3VzZWRWYWx1ZSxcbiAgICAgICAgaXNEaXNhYmxlZDogcHJvcHMuaXNEaXNhYmxlZCB8fCBmYWxzZSxcbiAgICAgICAgaXNSZWFkT25seTogcHJvcHMuaXNSZWFkT25seSB8fCBmYWxzZSxcbiAgICAgICAgaXNSZXF1aXJlZDogcHJvcHMuaXNSZXF1aXJlZCB8fCBmYWxzZSxcbiAgICAgICAgdmFsaWRhdGlvblN0YXRlOiBwcm9wcy52YWxpZGF0aW9uU3RhdGUgfHwgKGlzSW52YWxpZCA/IFwiaW52YWxpZFwiIDogbnVsbCksXG4gICAgICAgIGlzSW52YWxpZDogaXNJbnZhbGlkXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskYTU0Y2RjNWMxOTQyYjYzOSRleHBvcnQkYmNhOWQwMjZmOGU3MDRlYiBhcyB1c2VSYWRpb0dyb3VwU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCIkZlEyU0YkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRmUTJTRiR1c2VDb250cm9sbGVkU3RhdGUiLCJ1c2VNZW1vIiwiJGZRMlNGJHVzZU1lbW8iLCJ1c2VTdGF0ZSIsIiRmUTJTRiR1c2VTdGF0ZSIsIiRhNTRjZGM1YzE5NDJiNjM5JHZhciRpbnN0YW5jZSIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsIiRhNTRjZGM1YzE5NDJiNjM5JHZhciRpIiwiJGE1NGNkYzVjMTk0MmI2MzkkZXhwb3J0JGJjYTlkMDI2ZjhlNzA0ZWIiLCJwcm9wcyIsIm5hbWUiLCJfcHJvcHNfZGVmYXVsdFZhbHVlIiwic2VsZWN0ZWRWYWx1ZSIsInNldFNlbGVjdGVkIiwidmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJvbkNoYW5nZSIsImxhc3RGb2N1c2VkVmFsdWUiLCJzZXRMYXN0Rm9jdXNlZFZhbHVlIiwidmFsaWRhdGlvbiIsInNldFNlbGVjdGVkVmFsdWUiLCJpc1JlYWRPbmx5IiwiaXNEaXNhYmxlZCIsImNvbW1pdFZhbGlkYXRpb24iLCJpc0ludmFsaWQiLCJkaXNwbGF5VmFsaWRhdGlvbiIsImlzUmVxdWlyZWQiLCJ2YWxpZGF0aW9uU3RhdGUiLCJ1c2VSYWRpb0dyb3VwU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/radio/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/selection/dist/import.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@react-stately/selection/dist/import.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SelectionManager: () => (/* binding */ $d496c0a20b6e58ec$export$6c8a5aaad13c9852),\n/* harmony export */   useMultipleSelectionState: () => (/* binding */ $7af3f5b51489e0b5$export$253fe78d46329472)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $e40ea825a81a3709$export$52baac22726c72bf extends Set {\n    constructor(keys, anchorKey, currentKey){\n        super(keys);\n        if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {\n            this.anchorKey = anchorKey || keys.anchorKey;\n            this.currentKey = currentKey || keys.currentKey;\n        } else {\n            this.anchorKey = anchorKey;\n            this.currentKey = currentKey;\n        }\n    }\n}\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n    if (setA.size !== setB.size) return false;\n    for (let item of setA){\n        if (!setB.has(item)) return false;\n    }\n    return true;\n}\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n    let { selectionMode: selectionMode = \"none\", disallowEmptySelection: disallowEmptySelection, allowDuplicateSelectionEvents: allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = \"toggle\", disabledBehavior: disabledBehavior = \"all\" } = props;\n    // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n    // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n    let isFocusedRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let [, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let focusedKeyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let childFocusStrategyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let [, setFocusedKey] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let selectedKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [\n        props.selectedKeys\n    ]);\n    let defaultSelectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [\n        props.defaultSelectedKeys\n    ]);\n    let [selectedKeys, setSelectedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n    let disabledKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let [selectionBehavior, setSelectionBehavior] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(selectionBehaviorProp);\n    // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n    // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n    if (selectionBehaviorProp === \"replace\" && selectionBehavior === \"toggle\" && typeof selectedKeys === \"object\" && selectedKeys.size === 0) setSelectionBehavior(\"replace\");\n    // If the selectionBehavior prop changes, update the state as well.\n    let lastSelectionBehavior = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selectionBehaviorProp);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n            setSelectionBehavior(selectionBehaviorProp);\n            lastSelectionBehavior.current = selectionBehaviorProp;\n        }\n    }, [\n        selectionBehaviorProp\n    ]);\n    return {\n        selectionMode: selectionMode,\n        disallowEmptySelection: disallowEmptySelection,\n        selectionBehavior: selectionBehavior,\n        setSelectionBehavior: setSelectionBehavior,\n        get isFocused () {\n            return isFocusedRef.current;\n        },\n        setFocused (f) {\n            isFocusedRef.current = f;\n            setFocused(f);\n        },\n        get focusedKey () {\n            return focusedKeyRef.current;\n        },\n        get childFocusStrategy () {\n            return childFocusStrategyRef.current;\n        },\n        setFocusedKey (k, childFocusStrategy = \"first\") {\n            focusedKeyRef.current = k;\n            childFocusStrategyRef.current = childFocusStrategy;\n            setFocusedKey(k);\n        },\n        selectedKeys: selectedKeys,\n        setSelectedKeys (keys) {\n            if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n        },\n        disabledKeys: disabledKeysProp,\n        disabledBehavior: disabledBehavior\n    };\n}\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n    if (!selection) return defaultValue;\n    return selection === \"all\" ? \"all\" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $d496c0a20b6e58ec$export$6c8a5aaad13c9852 {\n    /**\n   * The type of selection that is allowed in the collection.\n   */ get selectionMode() {\n        return this.state.selectionMode;\n    }\n    /**\n   * Whether the collection allows empty selection.\n   */ get disallowEmptySelection() {\n        return this.state.disallowEmptySelection;\n    }\n    /**\n   * The selection behavior for the collection.\n   */ get selectionBehavior() {\n        return this.state.selectionBehavior;\n    }\n    /**\n   * Sets the selection behavior for the collection.\n   */ setSelectionBehavior(selectionBehavior) {\n        this.state.setSelectionBehavior(selectionBehavior);\n    }\n    /**\n   * Whether the collection is currently focused.\n   */ get isFocused() {\n        return this.state.isFocused;\n    }\n    /**\n   * Sets whether the collection is focused.\n   */ setFocused(isFocused) {\n        this.state.setFocused(isFocused);\n    }\n    /**\n   * The current focused key in the collection.\n   */ get focusedKey() {\n        return this.state.focusedKey;\n    }\n    /** Whether the first or last child of the focused key should receive focus. */ get childFocusStrategy() {\n        return this.state.childFocusStrategy;\n    }\n    /**\n   * Sets the focused key.\n   */ setFocusedKey(key, childFocusStrategy) {\n        if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);\n    }\n    /**\n   * The currently selected keys in the collection.\n   */ get selectedKeys() {\n        return this.state.selectedKeys === \"all\" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n    }\n    /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */ get rawSelection() {\n        return this.state.selectedKeys;\n    }\n    /**\n   * Returns whether a key is selected.\n   */ isSelected(key) {\n        if (this.state.selectionMode === \"none\") return false;\n        key = this.getKey(key);\n        return this.state.selectedKeys === \"all\" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);\n    }\n    /**\n   * Whether the selection is empty.\n   */ get isEmpty() {\n        return this.state.selectedKeys !== \"all\" && this.state.selectedKeys.size === 0;\n    }\n    /**\n   * Whether all items in the collection are selected.\n   */ get isSelectAll() {\n        if (this.isEmpty) return false;\n        if (this.state.selectedKeys === \"all\") return true;\n        if (this._isSelectAll != null) return this._isSelectAll;\n        let allKeys = this.getSelectAllKeys();\n        let selectedKeys = this.state.selectedKeys;\n        this._isSelectAll = allKeys.every((k)=>selectedKeys.has(k));\n        return this._isSelectAll;\n    }\n    get firstSelectedKey() {\n        let first = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!first || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, first) < 0) first = item;\n        }\n        return first === null || first === void 0 ? void 0 : first.key;\n    }\n    get lastSelectedKey() {\n        let last = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!last || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, last) > 0) last = item;\n        }\n        return last === null || last === void 0 ? void 0 : last.key;\n    }\n    get disabledKeys() {\n        return this.state.disabledKeys;\n    }\n    get disabledBehavior() {\n        return this.state.disabledBehavior;\n    }\n    /**\n   * Extends the selection to the given key.\n   */ extendSelection(toKey) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            this.replaceSelection(toKey);\n            return;\n        }\n        toKey = this.getKey(toKey);\n        let selection;\n        // Only select the one key if coming from a select all.\n        if (this.state.selectedKeys === \"all\") selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            toKey\n        ], toKey, toKey);\n        else {\n            let selectedKeys = this.state.selectedKeys;\n            let anchorKey = selectedKeys.anchorKey || toKey;\n            selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);\n            for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey))selection.delete(key);\n            for (let key of this.getKeyRange(toKey, anchorKey))if (this.canSelectItem(key)) selection.add(key);\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getKeyRange(from, to) {\n        let fromItem = this.collection.getItem(from);\n        let toItem = this.collection.getItem(to);\n        if (fromItem && toItem) {\n            if ((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);\n            return this.getKeyRangeInternal(to, from);\n        }\n        return [];\n    }\n    getKeyRangeInternal(from, to) {\n        let keys = [];\n        let key = from;\n        while(key){\n            let item = this.collection.getItem(key);\n            if (item && item.type === \"item\" || item.type === \"cell\" && this.allowsCellSelection) keys.push(key);\n            if (key === to) return keys;\n            key = this.collection.getKeyAfter(key);\n        }\n        return [];\n    }\n    getKey(key) {\n        let item = this.collection.getItem(key);\n        if (!item) return key;\n        // If cell selection is allowed, just return the key.\n        if (item.type === \"cell\" && this.allowsCellSelection) return key;\n        // Find a parent item to select\n        while(item.type !== \"item\" && item.parentKey != null)item = this.collection.getItem(item.parentKey);\n        if (!item || item.type !== \"item\") return null;\n        return item.key;\n    }\n    /**\n   * Toggles whether the given key is selected.\n   */ toggleSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\" && !this.isSelected(key)) {\n            this.replaceSelection(key);\n            return;\n        }\n        key = this.getKey(key);\n        if (key == null) return;\n        let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === \"all\" ? this.getSelectAllKeys() : this.state.selectedKeys);\n        if (keys.has(key)) keys.delete(key);\n        else if (this.canSelectItem(key)) {\n            keys.add(key);\n            keys.anchorKey = key;\n            keys.currentKey = key;\n        }\n        if (this.disallowEmptySelection && keys.size === 0) return;\n        this.state.setSelectedKeys(keys);\n    }\n    /**\n   * Replaces the selection with only the given key.\n   */ replaceSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        key = this.getKey(key);\n        if (key == null) return;\n        let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            key\n        ], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        this.state.setSelectedKeys(selection);\n    }\n    /**\n   * Replaces the selection with the given keys.\n   */ setSelectedKeys(keys) {\n        if (this.selectionMode === \"none\") return;\n        let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        for (let key of keys){\n            key = this.getKey(key);\n            if (key != null) {\n                selection.add(key);\n                if (this.selectionMode === \"single\") break;\n            }\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getSelectAllKeys() {\n        let keys = [];\n        let addKeys = (key)=>{\n            while(key){\n                if (this.canSelectItem(key)) {\n                    let item = this.collection.getItem(key);\n                    if (item.type === \"item\") keys.push(key);\n                    // Add child keys. If cell selection is allowed, then include item children too.\n                    if (item.hasChildNodes && (this.allowsCellSelection || item.type !== \"item\")) addKeys((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, this.collection)).key);\n                }\n                key = this.collection.getKeyAfter(key);\n            }\n        };\n        addKeys(this.collection.getFirstKey());\n        return keys;\n    }\n    /**\n   * Selects all items in the collection.\n   */ selectAll() {\n        if (!this.isSelectAll && this.selectionMode === \"multiple\") this.state.setSelectedKeys(\"all\");\n    }\n    /**\n   * Removes all keys from the selection.\n   */ clearSelection() {\n        if (!this.disallowEmptySelection && (this.state.selectedKeys === \"all\" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());\n    }\n    /**\n   * Toggles between select all and an empty selection.\n   */ toggleSelectAll() {\n        if (this.isSelectAll) this.clearSelection();\n        else this.selectAll();\n    }\n    select(key, e) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);\n            else this.replaceSelection(key);\n        } else if (this.selectionBehavior === \"toggle\" || e && (e.pointerType === \"touch\" || e.pointerType === \"virtual\")) this.toggleSelection(key);\n        else this.replaceSelection(key);\n    }\n    /**\n   * Returns whether the current selection is equal to the given selection.\n   */ isSelectionEqual(selection) {\n        if (selection === this.state.selectedKeys) return true;\n        // Check if the set of keys match.\n        let selectedKeys = this.selectedKeys;\n        if (selection.size !== selectedKeys.size) return false;\n        for (let key of selection){\n            if (!selectedKeys.has(key)) return false;\n        }\n        for (let key of selectedKeys){\n            if (!selection.has(key)) return false;\n        }\n        return true;\n    }\n    canSelectItem(key) {\n        if (this.state.selectionMode === \"none\" || this.state.disabledKeys.has(key)) return false;\n        let item = this.collection.getItem(key);\n        if (!item || item.type === \"cell\" && !this.allowsCellSelection) return false;\n        return true;\n    }\n    isDisabled(key) {\n        return this.state.disabledKeys.has(key) && this.state.disabledBehavior === \"all\";\n    }\n    isLink(key) {\n        var _this_collection_getItem_props, _this_collection_getItem;\n        return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);\n    }\n    constructor(collection, state, options){\n        this.collection = collection;\n        this.state = state;\n        var _options_allowsCellSelection;\n        this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;\n        this._isSelectAll = null;\n    }\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRjtBQUNnRDtBQUM4QjtBQUVuSzs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRyxNQUFNZ0Isa0RBQWtEQztJQUN4REMsWUFBWUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsQ0FBQztRQUNwQyxLQUFLLENBQUNGO1FBQ04sSUFBSUEsZ0JBQWdCSCwyQ0FBMkM7WUFDM0QsSUFBSSxDQUFDSSxTQUFTLEdBQUdBLGFBQWFELEtBQUtDLFNBQVM7WUFDNUMsSUFBSSxDQUFDQyxVQUFVLEdBQUdBLGNBQWNGLEtBQUtFLFVBQVU7UUFDbkQsT0FBTztZQUNILElBQUksQ0FBQ0QsU0FBUyxHQUFHQTtZQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDdEI7SUFDSjtBQUNKO0FBS0EsU0FBU0MsZ0NBQWdDQyxJQUFJLEVBQUVDLElBQUk7SUFDL0MsSUFBSUQsS0FBS0UsSUFBSSxLQUFLRCxLQUFLQyxJQUFJLEVBQUUsT0FBTztJQUNwQyxLQUFLLElBQUlDLFFBQVFILEtBQUs7UUFDbEIsSUFBSSxDQUFDQyxLQUFLRyxHQUFHLENBQUNELE9BQU8sT0FBTztJQUNoQztJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNFLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLEVBQUVDLGVBQWVBLGdCQUFnQixNQUFNLEVBQUVDLHdCQUF3QkEsc0JBQXNCLEVBQUVDLCtCQUErQkEsNkJBQTZCLEVBQUVDLG1CQUFtQkMsd0JBQXdCLFFBQVEsRUFBRUMsa0JBQWtCQSxtQkFBbUIsS0FBSyxFQUFFLEdBQUdOO0lBQy9QLDhGQUE4RjtJQUM5RixrR0FBa0c7SUFDbEcsSUFBSU8sZUFBZSxDQUFDLEdBQUdqQyx5Q0FBWSxFQUFHO0lBQ3RDLElBQUksR0FBR2tDLFdBQVcsR0FBRyxDQUFD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YWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uL2Rpc3QvaW1wb3J0Lm1qcz9hZWQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICRRc3RvMiR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuaW1wb3J0IHt1c2VSZWYgYXMgJFFzdG8yJHVzZVJlZiwgdXNlU3RhdGUgYXMgJFFzdG8yJHVzZVN0YXRlLCB1c2VNZW1vIGFzICRRc3RvMiR1c2VNZW1vLCB1c2VFZmZlY3QgYXMgJFFzdG8yJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge2NvbXBhcmVOb2RlT3JkZXIgYXMgJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIsIGdldEZpcnN0SXRlbSBhcyAkUXN0bzIkZ2V0Rmlyc3RJdGVtLCBnZXRDaGlsZE5vZGVzIGFzICRRc3RvMiRnZXRDaGlsZE5vZGVzfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYgZXh0ZW5kcyBTZXQge1xuICAgIGNvbnN0cnVjdG9yKGtleXMsIGFuY2hvcktleSwgY3VycmVudEtleSl7XG4gICAgICAgIHN1cGVyKGtleXMpO1xuICAgICAgICBpZiAoa2V5cyBpbnN0YW5jZW9mICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvcktleSA9IGFuY2hvcktleSB8fCBrZXlzLmFuY2hvcktleTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEtleSA9IGN1cnJlbnRLZXkgfHwga2V5cy5jdXJyZW50S2V5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbmNob3JLZXkgPSBhbmNob3JLZXk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRLZXkgPSBjdXJyZW50S2V5O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuXG5mdW5jdGlvbiAkN2FmM2Y1YjUxNDg5ZTBiNSR2YXIkZXF1YWxTZXRzKHNldEEsIHNldEIpIHtcbiAgICBpZiAoc2V0QS5zaXplICE9PSBzZXRCLnNpemUpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpdGVtIG9mIHNldEEpe1xuICAgICAgICBpZiAoIXNldEIuaGFzKGl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJDdhZjNmNWI1MTQ4OWUwYjUkZXhwb3J0JDI1M2ZlNzhkNDYzMjk0NzIocHJvcHMpIHtcbiAgICBsZXQgeyBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlID0gXCJub25lXCIsIGRpc2FsbG93RW1wdHlTZWxlY3Rpb246IGRpc2FsbG93RW1wdHlTZWxlY3Rpb24sIGFsbG93RHVwbGljYXRlU2VsZWN0aW9uRXZlbnRzOiBhbGxvd0R1cGxpY2F0ZVNlbGVjdGlvbkV2ZW50cywgc2VsZWN0aW9uQmVoYXZpb3I6IHNlbGVjdGlvbkJlaGF2aW9yUHJvcCA9IFwidG9nZ2xlXCIsIGRpc2FibGVkQmVoYXZpb3I6IGRpc2FibGVkQmVoYXZpb3IgPSBcImFsbFwiIH0gPSBwcm9wcztcbiAgICAvLyBXZSB3YW50IHN5bmNocm9ub3VzIHVwZGF0ZXMgdG8gYGlzRm9jdXNlZGAgYW5kIGBmb2N1c2VkS2V5YCBhZnRlciB0aGVpciBzZXR0ZXJzIGFyZSBjYWxsZWQuXG4gICAgLy8gQnV0IHdlIGFsc28gbmVlZCB0byB0cmlnZ2VyIGEgcmVhY3QgcmUtcmVuZGVyLiBTbywgd2UgaGF2ZSBib3RoIGEgcmVmIChzeW5jKSBhbmQgc3RhdGUgKGFzeW5jKS5cbiAgICBsZXQgaXNGb2N1c2VkUmVmID0gKDAsICRRc3RvMiR1c2VSZWYpKGZhbHNlKTtcbiAgICBsZXQgWywgc2V0Rm9jdXNlZF0gPSAoMCwgJFFzdG8yJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IGZvY3VzZWRLZXlSZWYgPSAoMCwgJFFzdG8yJHVzZVJlZikobnVsbCk7XG4gICAgbGV0IGNoaWxkRm9jdXNTdHJhdGVneVJlZiA9ICgwLCAkUXN0bzIkdXNlUmVmKShudWxsKTtcbiAgICBsZXQgWywgc2V0Rm9jdXNlZEtleV0gPSAoMCwgJFFzdG8yJHVzZVN0YXRlKShudWxsKTtcbiAgICBsZXQgc2VsZWN0ZWRLZXlzUHJvcCA9ICgwLCAkUXN0bzIkdXNlTWVtbykoKCk9PiQ3YWYzZjViNTE0ODllMGI1JHZhciRjb252ZXJ0U2VsZWN0aW9uKHByb3BzLnNlbGVjdGVkS2V5cyksIFtcbiAgICAgICAgcHJvcHMuc2VsZWN0ZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IGRlZmF1bHRTZWxlY3RlZEtleXMgPSAoMCwgJFFzdG8yJHVzZU1lbW8pKCgpPT4kN2FmM2Y1YjUxNDg5ZTBiNSR2YXIkY29udmVydFNlbGVjdGlvbihwcm9wcy5kZWZhdWx0U2VsZWN0ZWRLZXlzLCBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSgpKSwgW1xuICAgICAgICBwcm9wcy5kZWZhdWx0U2VsZWN0ZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IFtzZWxlY3RlZEtleXMsIHNldFNlbGVjdGVkS2V5c10gPSAoMCwgJFFzdG8yJHVzZUNvbnRyb2xsZWRTdGF0ZSkoc2VsZWN0ZWRLZXlzUHJvcCwgZGVmYXVsdFNlbGVjdGVkS2V5cywgcHJvcHMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIGxldCBkaXNhYmxlZEtleXNQcm9wID0gKDAsICRRc3RvMiR1c2VNZW1vKSgoKT0+cHJvcHMuZGlzYWJsZWRLZXlzID8gbmV3IFNldChwcm9wcy5kaXNhYmxlZEtleXMpIDogbmV3IFNldCgpLCBbXG4gICAgICAgIHByb3BzLmRpc2FibGVkS2V5c1xuICAgIF0pO1xuICAgIGxldCBbc2VsZWN0aW9uQmVoYXZpb3IsIHNldFNlbGVjdGlvbkJlaGF2aW9yXSA9ICgwLCAkUXN0bzIkdXNlU3RhdGUpKHNlbGVjdGlvbkJlaGF2aW9yUHJvcCk7XG4gICAgLy8gSWYgdGhlIHNlbGVjdGlvbkJlaGF2aW9yIHByb3AgaXMgc2V0IHRvIHJlcGxhY2UsIGJ1dCB0aGUgY3VycmVudCBzdGF0ZSBpcyB0b2dnbGUgKGUuZy4gZHVlIHRvIGxvbmcgcHJlc3NcbiAgICAvLyB0byBlbnRlciBzZWxlY3Rpb24gbW9kZSBvbiB0b3VjaCksIGFuZCB0aGUgc2VsZWN0aW9uIGJlY29tZXMgZW1wdHksIHJlc2V0IHRoZSBzZWxlY3Rpb24gYmVoYXZpb3IuXG4gICAgaWYgKHNlbGVjdGlvbkJlaGF2aW9yUHJvcCA9PT0gXCJyZXBsYWNlXCIgJiYgc2VsZWN0aW9uQmVoYXZpb3IgPT09IFwidG9nZ2xlXCIgJiYgdHlwZW9mIHNlbGVjdGVkS2V5cyA9PT0gXCJvYmplY3RcIiAmJiBzZWxlY3RlZEtleXMuc2l6ZSA9PT0gMCkgc2V0U2VsZWN0aW9uQmVoYXZpb3IoXCJyZXBsYWNlXCIpO1xuICAgIC8vIElmIHRoZSBzZWxlY3Rpb25CZWhhdmlvciBwcm9wIGNoYW5nZXMsIHVwZGF0ZSB0aGUgc3RhdGUgYXMgd2VsbC5cbiAgICBsZXQgbGFzdFNlbGVjdGlvbkJlaGF2aW9yID0gKDAsICRRc3RvMiR1c2VSZWYpKHNlbGVjdGlvbkJlaGF2aW9yUHJvcCk7XG4gICAgKDAsICRRc3RvMiR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChzZWxlY3Rpb25CZWhhdmlvclByb3AgIT09IGxhc3RTZWxlY3Rpb25CZWhhdmlvci5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25CZWhhdmlvcihzZWxlY3Rpb25CZWhhdmlvclByb3ApO1xuICAgICAgICAgICAgbGFzdFNlbGVjdGlvbkJlaGF2aW9yLmN1cnJlbnQgPSBzZWxlY3Rpb25CZWhhdmlvclByb3A7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHNlbGVjdGlvbkJlaGF2aW9yUHJvcFxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsXG4gICAgICAgIGRpc2FsbG93RW1wdHlTZWxlY3Rpb246IGRpc2FsbG93RW1wdHlTZWxlY3Rpb24sXG4gICAgICAgIHNlbGVjdGlvbkJlaGF2aW9yOiBzZWxlY3Rpb25CZWhhdmlvcixcbiAgICAgICAgc2V0U2VsZWN0aW9uQmVoYXZpb3I6IHNldFNlbGVjdGlvbkJlaGF2aW9yLFxuICAgICAgICBnZXQgaXNGb2N1c2VkICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0ZvY3VzZWRSZWYuY3VycmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Rm9jdXNlZCAoZikge1xuICAgICAgICAgICAgaXNGb2N1c2VkUmVmLmN1cnJlbnQgPSBmO1xuICAgICAgICAgICAgc2V0Rm9jdXNlZChmKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGZvY3VzZWRLZXkgKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvY3VzZWRLZXlSZWYuY3VycmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkRm9jdXNTdHJhdGVneSAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRGb2N1c1N0cmF0ZWd5UmVmLmN1cnJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEZvY3VzZWRLZXkgKGssIGNoaWxkRm9jdXNTdHJhdGVneSA9IFwiZmlyc3RcIikge1xuICAgICAgICAgICAgZm9jdXNlZEtleVJlZi5jdXJyZW50ID0gaztcbiAgICAgICAgICAgIGNoaWxkRm9jdXNTdHJhdGVneVJlZi5jdXJyZW50ID0gY2hpbGRGb2N1c1N0cmF0ZWd5O1xuICAgICAgICAgICAgc2V0Rm9jdXNlZEtleShrKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXMsXG4gICAgICAgIHNldFNlbGVjdGVkS2V5cyAoa2V5cykge1xuICAgICAgICAgICAgaWYgKGFsbG93RHVwbGljYXRlU2VsZWN0aW9uRXZlbnRzIHx8ICEkN2FmM2Y1YjUxNDg5ZTBiNSR2YXIkZXF1YWxTZXRzKGtleXMsIHNlbGVjdGVkS2V5cykpIHNldFNlbGVjdGVkS2V5cyhrZXlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXNQcm9wLFxuICAgICAgICBkaXNhYmxlZEJlaGF2aW9yOiBkaXNhYmxlZEJlaGF2aW9yXG4gICAgfTtcbn1cbmZ1bmN0aW9uICQ3YWYzZjViNTE0ODllMGI1JHZhciRjb252ZXJ0U2VsZWN0aW9uKHNlbGVjdGlvbiwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgcmV0dXJuIHNlbGVjdGlvbiA9PT0gXCJhbGxcIiA/IFwiYWxsXCIgOiBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShzZWxlY3Rpb24pO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY2xhc3MgJGQ0OTZjMGEyMGI2ZTU4ZWMkZXhwb3J0JDZjOGE1YWFhZDEzYzk4NTIge1xuICAgIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBzZWxlY3Rpb24gdGhhdCBpcyBhbGxvd2VkIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi8gZ2V0IHNlbGVjdGlvbk1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGlvbk1vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjb2xsZWN0aW9uIGFsbG93cyBlbXB0eSBzZWxlY3Rpb24uXG4gICAqLyBnZXQgZGlzYWxsb3dFbXB0eVNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZGlzYWxsb3dFbXB0eVNlbGVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBzZWxlY3Rpb24gYmVoYXZpb3IgZm9yIHRoZSBjb2xsZWN0aW9uLlxuICAgKi8gZ2V0IHNlbGVjdGlvbkJlaGF2aW9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3Rpb25CZWhhdmlvcjtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdGlvbiBiZWhhdmlvciBmb3IgdGhlIGNvbGxlY3Rpb24uXG4gICAqLyBzZXRTZWxlY3Rpb25CZWhhdmlvcihzZWxlY3Rpb25CZWhhdmlvcikge1xuICAgICAgICB0aGlzLnN0YXRlLnNldFNlbGVjdGlvbkJlaGF2aW9yKHNlbGVjdGlvbkJlaGF2aW9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNvbGxlY3Rpb24gaXMgY3VycmVudGx5IGZvY3VzZWQuXG4gICAqLyBnZXQgaXNGb2N1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0ZvY3VzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhlIGNvbGxlY3Rpb24gaXMgZm9jdXNlZC5cbiAgICovIHNldEZvY3VzZWQoaXNGb2N1c2VkKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0Rm9jdXNlZChpc0ZvY3VzZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIGN1cnJlbnQgZm9jdXNlZCBrZXkgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqLyBnZXQgZm9jdXNlZEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZm9jdXNlZEtleTtcbiAgICB9XG4gICAgLyoqIFdoZXRoZXIgdGhlIGZpcnN0IG9yIGxhc3QgY2hpbGQgb2YgdGhlIGZvY3VzZWQga2V5IHNob3VsZCByZWNlaXZlIGZvY3VzLiAqLyBnZXQgY2hpbGRGb2N1c1N0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jaGlsZEZvY3VzU3RyYXRlZ3k7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXRzIHRoZSBmb2N1c2VkIGtleS5cbiAgICovIHNldEZvY3VzZWRLZXkoa2V5LCBjaGlsZEZvY3VzU3RyYXRlZ3kpIHtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSkpIHRoaXMuc3RhdGUuc2V0Rm9jdXNlZEtleShrZXksIGNoaWxkRm9jdXNTdHJhdGVneSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGtleXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqLyBnZXQgc2VsZWN0ZWRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIgPyBuZXcgU2V0KHRoaXMuZ2V0U2VsZWN0QWxsS2V5cygpKSA6IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIHJhdyBzZWxlY3Rpb24gdmFsdWUgZm9yIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBFaXRoZXIgJ2FsbCcgZm9yIHNlbGVjdCBhbGwsIG9yIGEgc2V0IG9mIGtleXMuXG4gICAqLyBnZXQgcmF3U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXM7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBrZXkgaXMgc2VsZWN0ZWQuXG4gICAqLyBpc1NlbGVjdGVkKGtleSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBrZXkgPSB0aGlzLmdldEtleShrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIgPyB0aGlzLmNhblNlbGVjdEl0ZW0oa2V5KSA6IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzLmhhcyhrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICogV2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5LlxuICAgKi8gZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyAhPT0gXCJhbGxcIiAmJiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cy5zaXplID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICogV2hldGhlciBhbGwgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gYXJlIHNlbGVjdGVkLlxuICAgKi8gZ2V0IGlzU2VsZWN0QWxsKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIikgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9pc1NlbGVjdEFsbCAhPSBudWxsKSByZXR1cm4gdGhpcy5faXNTZWxlY3RBbGw7XG4gICAgICAgIGxldCBhbGxLZXlzID0gdGhpcy5nZXRTZWxlY3RBbGxLZXlzKCk7XG4gICAgICAgIGxldCBzZWxlY3RlZEtleXMgPSB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICAgICAgdGhpcy5faXNTZWxlY3RBbGwgPSBhbGxLZXlzLmV2ZXJ5KChrKT0+c2VsZWN0ZWRLZXlzLmhhcyhrKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NlbGVjdEFsbDtcbiAgICB9XG4gICAgZ2V0IGZpcnN0U2VsZWN0ZWRLZXkoKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyl7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAoIWZpcnN0IHx8IGl0ZW0gJiYgKDAsICRRc3RvMiRjb21wYXJlTm9kZU9yZGVyKSh0aGlzLmNvbGxlY3Rpb24sIGl0ZW0sIGZpcnN0KSA8IDApIGZpcnN0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlyc3QgPT09IG51bGwgfHwgZmlyc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0LmtleTtcbiAgICB9XG4gICAgZ2V0IGxhc3RTZWxlY3RlZEtleSgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMpe1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKCFsYXN0IHx8IGl0ZW0gJiYgKDAsICRRc3RvMiRjb21wYXJlTm9kZU9yZGVyKSh0aGlzLmNvbGxlY3Rpb24sIGl0ZW0sIGxhc3QpID4gMCkgbGFzdCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC5rZXk7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRpc2FibGVkS2V5cztcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQmVoYXZpb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRpc2FibGVkQmVoYXZpb3I7XG4gICAgfVxuICAgIC8qKlxuICAgKiBFeHRlbmRzIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGdpdmVuIGtleS5cbiAgICovIGV4dGVuZFNlbGVjdGlvbih0b0tleSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VTZWxlY3Rpb24odG9LZXkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRvS2V5ID0gdGhpcy5nZXRLZXkodG9LZXkpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uO1xuICAgICAgICAvLyBPbmx5IHNlbGVjdCB0aGUgb25lIGtleSBpZiBjb21pbmcgZnJvbSBhIHNlbGVjdCBhbGwuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIikgc2VsZWN0aW9uID0gbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoW1xuICAgICAgICAgICAgdG9LZXlcbiAgICAgICAgXSwgdG9LZXksIHRvS2V5KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRLZXlzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXM7XG4gICAgICAgICAgICBsZXQgYW5jaG9yS2V5ID0gc2VsZWN0ZWRLZXlzLmFuY2hvcktleSB8fCB0b0tleTtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKHNlbGVjdGVkS2V5cywgYW5jaG9yS2V5LCB0b0tleSk7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5nZXRLZXlSYW5nZShhbmNob3JLZXksIHNlbGVjdGVkS2V5cy5jdXJyZW50S2V5IHx8IHRvS2V5KSlzZWxlY3Rpb24uZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5nZXRLZXlSYW5nZSh0b0tleSwgYW5jaG9yS2V5KSlpZiAodGhpcy5jYW5TZWxlY3RJdGVtKGtleSkpIHNlbGVjdGlvbi5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnNldFNlbGVjdGVkS2V5cyhzZWxlY3Rpb24pO1xuICAgIH1cbiAgICBnZXRLZXlSYW5nZShmcm9tLCB0bykge1xuICAgICAgICBsZXQgZnJvbUl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShmcm9tKTtcbiAgICAgICAgbGV0IHRvSXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKHRvKTtcbiAgICAgICAgaWYgKGZyb21JdGVtICYmIHRvSXRlbSkge1xuICAgICAgICAgICAgaWYgKCgwLCAkUXN0bzIkY29tcGFyZU5vZGVPcmRlcikodGhpcy5jb2xsZWN0aW9uLCBmcm9tSXRlbSwgdG9JdGVtKSA8PSAwKSByZXR1cm4gdGhpcy5nZXRLZXlSYW5nZUludGVybmFsKGZyb20sIHRvKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleVJhbmdlSW50ZXJuYWwodG8sIGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZ2V0S2V5UmFuZ2VJbnRlcm5hbChmcm9tLCB0bykge1xuICAgICAgICBsZXQga2V5cyA9IFtdO1xuICAgICAgICBsZXQga2V5ID0gZnJvbTtcbiAgICAgICAgd2hpbGUoa2V5KXtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0udHlwZSA9PT0gXCJpdGVtXCIgfHwgaXRlbS50eXBlID09PSBcImNlbGxcIiAmJiB0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24pIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdG8pIHJldHVybiBrZXlzO1xuICAgICAgICAgICAga2V5ID0gdGhpcy5jb2xsZWN0aW9uLmdldEtleUFmdGVyKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXRLZXkoa2V5KSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSAvLyDCr1xcXyjjg4QpXy/Cr1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAvLyBJZiBjZWxsIHNlbGVjdGlvbiBpcyBhbGxvd2VkLCBqdXN0IHJldHVybiB0aGUga2V5LlxuICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcImNlbGxcIiAmJiB0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24pIHJldHVybiBrZXk7XG4gICAgICAgIC8vIEZpbmQgYSBwYXJlbnQgaXRlbSB0byBzZWxlY3RcbiAgICAgICAgd2hpbGUoaXRlbS50eXBlICE9PSBcIml0ZW1cIiAmJiBpdGVtLnBhcmVudEtleSAhPSBudWxsKWl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShpdGVtLnBhcmVudEtleSk7XG4gICAgICAgIGlmICghaXRlbSB8fCBpdGVtLnR5cGUgIT09IFwiaXRlbVwiKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGl0ZW0ua2V5O1xuICAgIH1cbiAgICAvKipcbiAgICogVG9nZ2xlcyB3aGV0aGVyIHRoZSBnaXZlbiBrZXkgaXMgc2VsZWN0ZWQuXG4gICAqLyB0b2dnbGVTZWxlY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwic2luZ2xlXCIgJiYgIXRoaXMuaXNTZWxlY3RlZChrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VTZWxlY3Rpb24oa2V5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSB0aGlzLmdldEtleShrZXkpO1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybjtcbiAgICAgICAgbGV0IGtleXMgPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSh0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiA/IHRoaXMuZ2V0U2VsZWN0QWxsS2V5cygpIDogdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMpO1xuICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkga2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jYW5TZWxlY3RJdGVtKGtleSkpIHtcbiAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBrZXlzLmFuY2hvcktleSA9IGtleTtcbiAgICAgICAgICAgIGtleXMuY3VycmVudEtleSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNhbGxvd0VtcHR5U2VsZWN0aW9uICYmIGtleXMuc2l6ZSA9PT0gMCkgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlLnNldFNlbGVjdGVkS2V5cyhrZXlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBzZWxlY3Rpb24gd2l0aCBvbmx5IHRoZSBnaXZlbiBrZXkuXG4gICAqLyByZXBsYWNlU2VsZWN0aW9uKGtleSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikgcmV0dXJuO1xuICAgICAgICBrZXkgPSB0aGlzLmdldEtleShrZXkpO1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybjtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpID8gbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoW1xuICAgICAgICAgICAga2V5XG4gICAgICAgIF0sIGtleSwga2V5KSA6IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKCk7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKHNlbGVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIGtleXMuXG4gICAqLyBzZXRTZWxlY3RlZEtleXMoa2V5cykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikgcmV0dXJuO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoKTtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGtleXMpe1xuICAgICAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5KTtcbiAgICAgICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcInNpbmdsZVwiKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnNldFNlbGVjdGVkS2V5cyhzZWxlY3Rpb24pO1xuICAgIH1cbiAgICBnZXRTZWxlY3RBbGxLZXlzKCkge1xuICAgICAgICBsZXQga2V5cyA9IFtdO1xuICAgICAgICBsZXQgYWRkS2V5cyA9IChrZXkpPT57XG4gICAgICAgICAgICB3aGlsZShrZXkpe1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhblNlbGVjdEl0ZW0oa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiaXRlbVwiKSBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGNoaWxkIGtleXMuIElmIGNlbGwgc2VsZWN0aW9uIGlzIGFsbG93ZWQsIHRoZW4gaW5jbHVkZSBpdGVtIGNoaWxkcmVuIHRvby5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGFzQ2hpbGROb2RlcyAmJiAodGhpcy5hbGxvd3NDZWxsU2VsZWN0aW9uIHx8IGl0ZW0udHlwZSAhPT0gXCJpdGVtXCIpKSBhZGRLZXlzKCgwLCAkUXN0bzIkZ2V0Rmlyc3RJdGVtKSgoMCwgJFFzdG8yJGdldENoaWxkTm9kZXMpKGl0ZW0sIHRoaXMuY29sbGVjdGlvbikpLmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuY29sbGVjdGlvbi5nZXRLZXlBZnRlcihrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhZGRLZXlzKHRoaXMuY29sbGVjdGlvbi5nZXRGaXJzdEtleSgpKTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZWxlY3RzIGFsbCBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovIHNlbGVjdEFsbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0QWxsICYmIHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJtdWx0aXBsZVwiKSB0aGlzLnN0YXRlLnNldFNlbGVjdGVkS2V5cyhcImFsbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGtleXMgZnJvbSB0aGUgc2VsZWN0aW9uLlxuICAgKi8gY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhbGxvd0VtcHR5U2VsZWN0aW9uICYmICh0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiB8fCB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cy5zaXplID4gMCkpIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICogVG9nZ2xlcyBiZXR3ZWVuIHNlbGVjdCBhbGwgYW5kIGFuIGVtcHR5IHNlbGVjdGlvbi5cbiAgICovIHRvZ2dsZVNlbGVjdEFsbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RBbGwpIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgZWxzZSB0aGlzLnNlbGVjdEFsbCgpO1xuICAgIH1cbiAgICBzZWxlY3Qoa2V5LCBlKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwic2luZ2xlXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQoa2V5KSAmJiAhdGhpcy5kaXNhbGxvd0VtcHR5U2VsZWN0aW9uKSB0aGlzLnRvZ2dsZVNlbGVjdGlvbihrZXkpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLnJlcGxhY2VTZWxlY3Rpb24oa2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbkJlaGF2aW9yID09PSBcInRvZ2dsZVwiIHx8IGUgJiYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInZpcnR1YWxcIikpIC8vIGlmIHRvdWNoIG9yIHZpcnR1YWwgKFZPKSB0aGVuIHdlIGp1c3Qgd2FudCB0byB0b2dnbGUsIG90aGVyd2lzZSBpdCdzIGltcG9zc2libGUgdG8gbXVsdGkgc2VsZWN0IGJlY2F1c2UgdGhleSBkb24ndCBoYXZlIG1vZGlmaWVyIGtleXNcbiAgICAgICAgdGhpcy50b2dnbGVTZWxlY3Rpb24oa2V5KTtcbiAgICAgICAgZWxzZSB0aGlzLnJlcGxhY2VTZWxlY3Rpb24oa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgZXF1YWwgdG8gdGhlIGdpdmVuIHNlbGVjdGlvbi5cbiAgICovIGlzU2VsZWN0aW9uRXF1YWwoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb24gPT09IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNldCBvZiBrZXlzIG1hdGNoLlxuICAgICAgICBsZXQgc2VsZWN0ZWRLZXlzID0gdGhpcy5zZWxlY3RlZEtleXM7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uc2l6ZSAhPT0gc2VsZWN0ZWRLZXlzLnNpemUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHNlbGVjdGlvbil7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkS2V5cy5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBzZWxlY3RlZEtleXMpe1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24uaGFzKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2FuU2VsZWN0SXRlbShrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIgfHwgdGhpcy5zdGF0ZS5kaXNhYmxlZEtleXMuaGFzKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0gfHwgaXRlbS50eXBlID09PSBcImNlbGxcIiAmJiAhdGhpcy5hbGxvd3NDZWxsU2VsZWN0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc0Rpc2FibGVkKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kaXNhYmxlZEtleXMuaGFzKGtleSkgJiYgdGhpcy5zdGF0ZS5kaXNhYmxlZEJlaGF2aW9yID09PSBcImFsbFwiO1xuICAgIH1cbiAgICBpc0xpbmsoa2V5KSB7XG4gICAgICAgIHZhciBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW1fcHJvcHMsIF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbTtcbiAgICAgICAgcmV0dXJuICEhKChfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpKSA9PT0gbnVsbCB8fCBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW1fcHJvcHMgPSBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW0ucHJvcHMpID09PSBudWxsIHx8IF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtX3Byb3BzLmhyZWYpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uLCBzdGF0ZSwgb3B0aW9ucyl7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdmFyIF9vcHRpb25zX2FsbG93c0NlbGxTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbiA9IChfb3B0aW9uc19hbGxvd3NDZWxsU2VsZWN0aW9uID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFsbG93c0NlbGxTZWxlY3Rpb24pICE9PSBudWxsICYmIF9vcHRpb25zX2FsbG93c0NlbGxTZWxlY3Rpb24gIT09IHZvaWQgMCA/IF9vcHRpb25zX2FsbG93c0NlbGxTZWxlY3Rpb24gOiBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RBbGwgPSBudWxsO1xuICAgIH1cbn1cblxuXG5cblxuZXhwb3J0IHskN2FmM2Y1YjUxNDg5ZTBiNSRleHBvcnQkMjUzZmU3OGQ0NjMyOTQ3MiBhcyB1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlLCAkZDQ5NmMwYTIwYjZlNThlYyRleHBvcnQkNmM4YTVhYWFkMTNjOTg1MiBhcyBTZWxlY3Rpb25NYW5hZ2VyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VDb250cm9sbGVkU3RhdGUiLCIkUXN0bzIkdXNlQ29udHJvbGxlZFN0YXRlIiwidXNlUmVmIiwiJFFzdG8yJHVzZVJlZiIsInVzZVN0YXRlIiwiJFFzdG8yJHVzZVN0YXRlIiwidXNlTWVtbyIsIiRRc3RvMiR1c2VNZW1vIiwidXNlRWZmZWN0IiwiJFFzdG8yJHVzZUVmZmVjdCIsImNvbXBhcmVOb2RlT3JkZXIiLCIkUXN0bzIkY29tcGFyZU5vZGVPcmRlciIsImdldEZpcnN0SXRlbSIsIiRRc3RvMiRnZXRGaXJzdEl0ZW0iLCJnZXRDaGlsZE5vZGVzIiwiJFFzdG8yJGdldENoaWxkTm9kZXMiLCIkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZiIsIlNldCIsImNvbnN0cnVjdG9yIiwia2V5cyIsImFuY2hvcktleSIsImN1cnJlbnRLZXkiLCIkN2FmM2Y1YjUxNDg5ZTBiNSR2YXIkZXF1YWxTZXRzIiwic2V0QSIsInNldEIiLCJzaXplIiwiaXRlbSIsImhhcyIsIiQ3YWYzZjViNTE0ODllMGI1JGV4cG9ydCQyNTNmZTc4ZDQ2MzI5NDcyIiwicHJvcHMiLCJzZWxlY3Rpb25Nb2RlIiwiZGlzYWxsb3dFbXB0eVNlbGVjdGlvbiIsImFsbG93RHVwbGljYXRlU2VsZWN0aW9uRXZlbnRzIiwic2VsZWN0aW9uQmVoYXZpb3IiLCJzZWxlY3Rpb25CZWhhdmlvclByb3AiLCJkaXNhYmxlZEJlaGF2aW9yIiwiaXNGb2N1c2VkUmVmIiwic2V0Rm9jdXNlZCIsImZvY3VzZWRLZXlSZWYiLCJjaGlsZEZvY3VzU3RyYXRlZ3lSZWYiLCJzZXRGb2N1c2VkS2V5Iiwic2VsZWN0ZWRLZXlzUHJvcCIsIiQ3YWYzZjViNTE0ODllMGI1JHZhciRjb252ZXJ0U2VsZWN0aW9uIiwic2VsZWN0ZWRLZXlzIiwiZGVmYXVsdFNlbGVjdGVkS2V5cyIsInNldFNlbGVjdGVkS2V5cyIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwiZGlzYWJsZWRLZXlzUHJvcCIsImRpc2FibGVkS2V5cyIsInNldFNlbGVjdGlvbkJlaGF2aW9yIiwibGFzdFNlbGVjdGlvbkJlaGF2aW9yIiwiY3VycmVudCIsImlzRm9jdXNlZCIsImYiLCJmb2N1c2VkS2V5IiwiY2hpbGRGb2N1c1N0cmF0ZWd5IiwiayIsInNlbGVjdGlvbiIsImRlZmF1bHRWYWx1ZSIsIiRkNDk2YzBhMjBiNmU1OGVjJGV4cG9ydCQ2YzhhNWFhYWQxM2M5ODUyIiwic3RhdGUiLCJrZXkiLCJjb2xsZWN0aW9uIiwiZ2V0SXRlbSIsImdldFNlbGVjdEFsbEtleXMiLCJyYXdTZWxlY3Rpb24iLCJpc1NlbGVjdGVkIiwiZ2V0S2V5IiwiY2FuU2VsZWN0SXRlbSIsImlzRW1wdHkiLCJpc1NlbGVjdEFsbCIsIl9pc1NlbGVjdEFsbCIsImFsbEtleXMiLCJldmVyeSIsImZpcnN0U2VsZWN0ZWRLZXkiLCJmaXJzdCIsImxhc3RTZWxlY3RlZEtleSIsImxhc3QiLCJleHRlbmRTZWxlY3Rpb24iLCJ0b0tleSIsInJlcGxhY2VTZWxlY3Rpb24iLCJnZXRLZXlSYW5nZSIsImRlbGV0ZSIsImFkZCIsImZyb20iLCJ0byIsImZyb21JdGVtIiwidG9JdGVtIiwiZ2V0S2V5UmFuZ2VJbnRlcm5hbCIsInR5cGUiLCJhbGxvd3NDZWxsU2VsZWN0aW9uIiwicHVzaCIsImdldEtleUFmdGVyIiwicGFyZW50S2V5IiwidG9nZ2xlU2VsZWN0aW9uIiwiYWRkS2V5cyIsImhhc0NoaWxkTm9kZXMiLCJnZXRGaXJzdEtleSIsInNlbGVjdEFsbCIsImNsZWFyU2VsZWN0aW9uIiwidG9nZ2xlU2VsZWN0QWxsIiwic2VsZWN0IiwiZSIsInBvaW50ZXJUeXBlIiwiaXNTZWxlY3Rpb25FcXVhbCIsImlzRGlzYWJsZWQiLCJpc0xpbmsiLCJfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW1fcHJvcHMiLCJfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW0iLCJocmVmIiwib3B0aW9ucyIsIl9vcHRpb25zX2FsbG93c0NlbGxTZWxlY3Rpb24iLCJ1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIiwiU2VsZWN0aW9uTWFuYWdlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/slider/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/slider/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSliderState: () => (/* binding */ $28f99e3e86e6ec45$export$e5fda3247f5d67f9)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE = 0;\nconst $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE = 100;\nconst $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE = 1;\nfunction $28f99e3e86e6ec45$export$e5fda3247f5d67f9(props) {\n    const { isDisabled: isDisabled = false, minValue: minValue = $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE, maxValue: maxValue = $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE, numberFormatter: formatter, step: step = $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE, orientation: orientation = \"horizontal\" } = props;\n    // Page step should be at least equal to step and always a multiple of the step.\n    let pageSize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let calcPageSize = (maxValue - minValue) / 10;\n        calcPageSize = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(calcPageSize, 0, calcPageSize + step, step);\n        return Math.max(calcPageSize, step);\n    }, [\n        step,\n        maxValue,\n        minValue\n    ]);\n    let restrictValues = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((values)=>values === null || values === void 0 ? void 0 : values.map((val, idx)=>{\n            let min = idx === 0 ? minValue : val[idx - 1];\n            let max = idx === values.length - 1 ? maxValue : val[idx + 1];\n            return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(val, min, max, step);\n        }), [\n        minValue,\n        maxValue,\n        step\n    ]);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>restrictValues($28f99e3e86e6ec45$var$convertValue(props.value)), [\n        props.value\n    ]);\n    let defaultValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _convertValue;\n        return restrictValues((_convertValue = $28f99e3e86e6ec45$var$convertValue(props.defaultValue)) !== null && _convertValue !== void 0 ? _convertValue : [\n            minValue\n        ]);\n    }, [\n        props.defaultValue,\n        minValue\n    ]);\n    let onChange = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChange);\n    let onChangeEnd = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChangeEnd);\n    const [values, setValuesState] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(value, defaultValue, onChange);\n    const [isDraggings, setDraggingsState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Array(values.length).fill(false));\n    const isEditablesRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(values.length).fill(true));\n    const [focusedIndex, setFocusedIndex] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    const valuesRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(values);\n    const isDraggingsRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isDraggings);\n    let setValues = (values)=>{\n        valuesRef.current = values;\n        setValuesState(values);\n    };\n    let setDraggings = (draggings)=>{\n        isDraggingsRef.current = draggings;\n        setDraggingsState(draggings);\n    };\n    function getValuePercent(value) {\n        return (value - minValue) / (maxValue - minValue);\n    }\n    function getThumbMinValue(index) {\n        return index === 0 ? minValue : values[index - 1];\n    }\n    function getThumbMaxValue(index) {\n        return index === values.length - 1 ? maxValue : values[index + 1];\n    }\n    function isThumbEditable(index) {\n        return isEditablesRef.current[index];\n    }\n    function setThumbEditable(index, editable) {\n        isEditablesRef.current[index] = editable;\n    }\n    function updateValue(index, value) {\n        if (isDisabled || !isThumbEditable(index)) return;\n        const thisMin = getThumbMinValue(index);\n        const thisMax = getThumbMaxValue(index);\n        // Round value to multiple of step, clamp value between min and max\n        value = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(value, thisMin, thisMax, step);\n        let newValues = $28f99e3e86e6ec45$var$replaceIndex(valuesRef.current, index, value);\n        setValues(newValues);\n    }\n    function updateDragging(index, dragging) {\n        if (isDisabled || !isThumbEditable(index)) return;\n        if (dragging) valuesRef.current = values;\n        const wasDragging = isDraggingsRef.current[index];\n        isDraggingsRef.current = $28f99e3e86e6ec45$var$replaceIndex(isDraggingsRef.current, index, dragging);\n        setDraggings(isDraggingsRef.current);\n        // Call onChangeEnd if no handles are dragging.\n        if (onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) onChangeEnd(valuesRef.current);\n    }\n    function getFormattedValue(value) {\n        return formatter.format(value);\n    }\n    function setThumbPercent(index, percent) {\n        updateValue(index, getPercentValue(percent));\n    }\n    function getRoundedValue(value) {\n        return Math.round((value - minValue) / step) * step + minValue;\n    }\n    function getPercentValue(percent) {\n        const val = percent * (maxValue - minValue) + minValue;\n        return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.clamp)(getRoundedValue(val), minValue, maxValue);\n    }\n    function incrementThumb(index, stepSize = 1) {\n        let s = Math.max(stepSize, step);\n        updateValue(index, (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(values[index] + s, minValue, maxValue, step));\n    }\n    function decrementThumb(index, stepSize = 1) {\n        let s = Math.max(stepSize, step);\n        updateValue(index, (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(values[index] - s, minValue, maxValue, step));\n    }\n    return {\n        values: values,\n        getThumbValue: (index)=>values[index],\n        setThumbValue: updateValue,\n        setThumbPercent: setThumbPercent,\n        isThumbDragging: (index)=>isDraggings[index],\n        setThumbDragging: updateDragging,\n        focusedThumb: focusedIndex,\n        setFocusedThumb: setFocusedIndex,\n        getThumbPercent: (index)=>getValuePercent(values[index]),\n        getValuePercent: getValuePercent,\n        getThumbValueLabel: (index)=>getFormattedValue(values[index]),\n        getFormattedValue: getFormattedValue,\n        getThumbMinValue: getThumbMinValue,\n        getThumbMaxValue: getThumbMaxValue,\n        getPercentValue: getPercentValue,\n        isThumbEditable: isThumbEditable,\n        setThumbEditable: setThumbEditable,\n        incrementThumb: incrementThumb,\n        decrementThumb: decrementThumb,\n        step: step,\n        pageSize: pageSize,\n        orientation: orientation,\n        isDisabled: isDisabled\n    };\n}\nfunction $28f99e3e86e6ec45$var$replaceIndex(array, index, value) {\n    if (array[index] === value) return array;\n    return [\n        ...array.slice(0, index),\n        value,\n        ...array.slice(index + 1)\n    ];\n}\nfunction $28f99e3e86e6ec45$var$convertValue(value) {\n    if (value == null) return undefined;\n    return Array.isArray(value) ? value : [\n        value\n    ];\n}\nfunction $28f99e3e86e6ec45$var$createOnChange(value, defaultValue, onChange) {\n    return (newValue)=>{\n        if (typeof value === \"number\" || typeof defaultValue === \"number\") onChange === null || onChange === void 0 ? void 0 : onChange(newValue[0]);\n        else onChange === null || onChange === void 0 ? void 0 : onChange(newValue);\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2xpZGVyL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUo7QUFDZDtBQUV6STs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELE1BQU1jLDBDQUEwQztBQUNoRCxNQUFNQywwQ0FBMEM7QUFDaEQsTUFBTUMsMkNBQTJDO0FBQ2pELFNBQVNDLDBDQUEwQ0MsS0FBSztJQUNwRCxNQUFNLEVBQUVDLFlBQVlBLGFBQWEsS0FBSyxFQUFFQyxVQUFVQSxXQUFXTix1Q0FBdUMsRUFBRU8sVUFBVUEsV0FBV04sdUNBQXVDLEVBQUVPLGlCQUFpQkMsU0FBUyxFQUFFQyxNQUFNQSxPQUFPUix3Q0FBd0MsRUFBRVMsYUFBYUEsY0FBYyxZQUFZLEVBQUUsR0FBR1A7SUFDblMsZ0ZBQWdGO0lBQ2hGLElBQUlRLFdBQVcsQ0FBQyxHQUFHbkIsMENBQWEsRUFBRztRQUMvQixJQUFJb0IsZUFBZSxDQUFDTixXQUFXRCxRQUFPLElBQUs7UUFDM0NPLGVBQWUsQ0FBQyxHQUFHMUIsaUVBQXFCLEVBQUcwQixjQUFjLEdBQUdBLGVBQWVILE1BQU1BO1FBQ2pGLE9BQU9JLEtBQUtDLEdBQUcsQ0FBQ0YsY0FBY0g7SUFDbEMsR0FBRztRQUNDQTtRQUNBSDtRQUNBRDtLQUNIO0lBQ0QsSUFBSVUsaUJBQWlCLENBQUMsR0FBR3JCLDhDQUFpQixFQUFHLENBQUNzQixTQUFTQSxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT0MsR0FBRyxDQUFDLENBQUNDLEtBQUtDO1lBQ2hILElBQUlDLE1BQU1ELFFBQVEsSUFBSWQsV0FBV2EsR0FBRyxDQUFDQyxNQUFNLEVBQUU7WUFDN0MsSUFBSUwsTUFBTUssUUFBUUgsT0FBT0ssTUFBTSxHQUFHLElBQUlmLFdBQVdZLEdBQUcsQ0FBQ0MsTUFBTSxFQUFFO1lBQzdELE9BQU8sQ0FBQyxHQUFHakMsaUVBQXFCLEVBQUdnQyxL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RUFBRUUsUUFBUTtJQUN2RSxPQUFPLENBQUN5RDtRQUNKLElBQUksT0FBTzdELFVBQVUsWUFBWSxPQUFPRSxpQkFBaUIsVUFBVUUsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN5RCxRQUFRLENBQUMsRUFBRTthQUN0SXpELGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTeUQ7SUFDdEU7QUFDSjtBQUtxRSxDQUNyRSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWR1c2EtbmV4dC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9zbGlkZXIvZGlzdC9pbXBvcnQubWpzPzgxODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtzbmFwVmFsdWVUb1N0ZXAgYXMgJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCwgdXNlQ29udHJvbGxlZFN0YXRlIGFzICRhVHd1eCR1c2VDb250cm9sbGVkU3RhdGUsIGNsYW1wIGFzICRhVHd1eCRjbGFtcH0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZU1lbW8gYXMgJGFUd3V4JHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICRhVHd1eCR1c2VDYWxsYmFjaywgdXNlU3RhdGUgYXMgJGFUd3V4JHVzZVN0YXRlLCB1c2VSZWYgYXMgJGFUd3V4JHVzZVJlZn0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNvbnN0ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01JTl9WQUxVRSA9IDA7XG5jb25zdCAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkREVGQVVMVF9NQVhfVkFMVUUgPSAxMDA7XG5jb25zdCAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkREVGQVVMVF9TVEVQX1ZBTFVFID0gMTtcbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JGV4cG9ydCRlNWZkYTMyNDdmNWQ2N2Y5KHByb3BzKSB7XG4gICAgY29uc3QgeyBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkID0gZmFsc2UsIG1pblZhbHVlOiBtaW5WYWx1ZSA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01JTl9WQUxVRSwgbWF4VmFsdWU6IG1heFZhbHVlID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfTUFYX1ZBTFVFLCBudW1iZXJGb3JtYXR0ZXI6IGZvcm1hdHRlciwgc3RlcDogc3RlcCA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX1NURVBfVkFMVUUsIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiIH0gPSBwcm9wcztcbiAgICAvLyBQYWdlIHN0ZXAgc2hvdWxkIGJlIGF0IGxlYXN0IGVxdWFsIHRvIHN0ZXAgYW5kIGFsd2F5cyBhIG11bHRpcGxlIG9mIHRoZSBzdGVwLlxuICAgIGxldCBwYWdlU2l6ZSA9ICgwLCAkYVR3dXgkdXNlTWVtbykoKCk9PntcbiAgICAgICAgbGV0IGNhbGNQYWdlU2l6ZSA9IChtYXhWYWx1ZSAtIG1pblZhbHVlKSAvIDEwO1xuICAgICAgICBjYWxjUGFnZVNpemUgPSAoMCwgJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCkoY2FsY1BhZ2VTaXplLCAwLCBjYWxjUGFnZVNpemUgKyBzdGVwLCBzdGVwKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGNhbGNQYWdlU2l6ZSwgc3RlcCk7XG4gICAgfSwgW1xuICAgICAgICBzdGVwLFxuICAgICAgICBtYXhWYWx1ZSxcbiAgICAgICAgbWluVmFsdWVcbiAgICBdKTtcbiAgICBsZXQgcmVzdHJpY3RWYWx1ZXMgPSAoMCwgJGFUd3V4JHVzZUNhbGxiYWNrKSgodmFsdWVzKT0+dmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLm1hcCgodmFsLCBpZHgpPT57XG4gICAgICAgICAgICBsZXQgbWluID0gaWR4ID09PSAwID8gbWluVmFsdWUgOiB2YWxbaWR4IC0gMV07XG4gICAgICAgICAgICBsZXQgbWF4ID0gaWR4ID09PSB2YWx1ZXMubGVuZ3RoIC0gMSA/IG1heFZhbHVlIDogdmFsW2lkeCArIDFdO1xuICAgICAgICAgICAgcmV0dXJuICgwLCAkYVR3dXgkc25hcFZhbHVlVG9TdGVwKSh2YWwsIG1pbiwgbWF4LCBzdGVwKTtcbiAgICAgICAgfSksIFtcbiAgICAgICAgbWluVmFsdWUsXG4gICAgICAgIG1heFZhbHVlLFxuICAgICAgICBzdGVwXG4gICAgXSk7XG4gICAgbGV0IHZhbHVlID0gKDAsICRhVHd1eCR1c2VNZW1vKSgoKT0+cmVzdHJpY3RWYWx1ZXMoJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNvbnZlcnRWYWx1ZShwcm9wcy52YWx1ZSkpLCBbXG4gICAgICAgIHByb3BzLnZhbHVlXG4gICAgXSk7XG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9ICgwLCAkYVR3dXgkdXNlTWVtbykoKCk9PntcbiAgICAgICAgdmFyIF9jb252ZXJ0VmFsdWU7XG4gICAgICAgIHJldHVybiByZXN0cmljdFZhbHVlcygoX2NvbnZlcnRWYWx1ZSA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjb252ZXJ0VmFsdWUocHJvcHMuZGVmYXVsdFZhbHVlKSkgIT09IG51bGwgJiYgX2NvbnZlcnRWYWx1ZSAhPT0gdm9pZCAwID8gX2NvbnZlcnRWYWx1ZSA6IFtcbiAgICAgICAgICAgIG1pblZhbHVlXG4gICAgICAgIF0pO1xuICAgIH0sIFtcbiAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICBtaW5WYWx1ZVxuICAgIF0pO1xuICAgIGxldCBvbkNoYW5nZSA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjcmVhdGVPbkNoYW5nZShwcm9wcy52YWx1ZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgbGV0IG9uQ2hhbmdlRW5kID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNyZWF0ZU9uQ2hhbmdlKHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHByb3BzLm9uQ2hhbmdlRW5kKTtcbiAgICBjb25zdCBbdmFsdWVzLCBzZXRWYWx1ZXNTdGF0ZV0gPSAoMCwgJGFUd3V4JHVzZUNvbnRyb2xsZWRTdGF0ZSkodmFsdWUsIGRlZmF1bHRWYWx1ZSwgb25DaGFuZ2UpO1xuICAgIGNvbnN0IFtpc0RyYWdnaW5ncywgc2V0RHJhZ2dpbmdzU3RhdGVdID0gKDAsICRhVHd1eCR1c2VTdGF0ZSkobmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpLmZpbGwoZmFsc2UpKTtcbiAgICBjb25zdCBpc0VkaXRhYmxlc1JlZiA9ICgwLCAkYVR3dXgkdXNlUmVmKShuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCkuZmlsbCh0cnVlKSk7XG4gICAgY29uc3QgW2ZvY3VzZWRJbmRleCwgc2V0Rm9jdXNlZEluZGV4XSA9ICgwLCAkYVR3dXgkdXNlU3RhdGUpKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgdmFsdWVzUmVmID0gKDAsICRhVHd1eCR1c2VSZWYpKHZhbHVlcyk7XG4gICAgY29uc3QgaXNEcmFnZ2luZ3NSZWYgPSAoMCwgJGFUd3V4JHVzZVJlZikoaXNEcmFnZ2luZ3MpO1xuICAgIGxldCBzZXRWYWx1ZXMgPSAodmFsdWVzKT0+e1xuICAgICAgICB2YWx1ZXNSZWYuY3VycmVudCA9IHZhbHVlcztcbiAgICAgICAgc2V0VmFsdWVzU3RhdGUodmFsdWVzKTtcbiAgICB9O1xuICAgIGxldCBzZXREcmFnZ2luZ3MgPSAoZHJhZ2dpbmdzKT0+e1xuICAgICAgICBpc0RyYWdnaW5nc1JlZi5jdXJyZW50ID0gZHJhZ2dpbmdzO1xuICAgICAgICBzZXREcmFnZ2luZ3NTdGF0ZShkcmFnZ2luZ3MpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVQZXJjZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgLSBtaW5WYWx1ZSkgLyAobWF4VmFsdWUgLSBtaW5WYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRodW1iTWluVmFsdWUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAwID8gbWluVmFsdWUgOiB2YWx1ZXNbaW5kZXggLSAxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGh1bWJNYXhWYWx1ZShpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IHZhbHVlcy5sZW5ndGggLSAxID8gbWF4VmFsdWUgOiB2YWx1ZXNbaW5kZXggKyAxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUaHVtYkVkaXRhYmxlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0VkaXRhYmxlc1JlZi5jdXJyZW50W2luZGV4XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VGh1bWJFZGl0YWJsZShpbmRleCwgZWRpdGFibGUpIHtcbiAgICAgICAgaXNFZGl0YWJsZXNSZWYuY3VycmVudFtpbmRleF0gPSBlZGl0YWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0Rpc2FibGVkIHx8ICFpc1RodW1iRWRpdGFibGUoaW5kZXgpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRoaXNNaW4gPSBnZXRUaHVtYk1pblZhbHVlKGluZGV4KTtcbiAgICAgICAgY29uc3QgdGhpc01heCA9IGdldFRodW1iTWF4VmFsdWUoaW5kZXgpO1xuICAgICAgICAvLyBSb3VuZCB2YWx1ZSB0byBtdWx0aXBsZSBvZiBzdGVwLCBjbGFtcCB2YWx1ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gICAgICAgIHZhbHVlID0gKDAsICRhVHd1eCRzbmFwVmFsdWVUb1N0ZXApKHZhbHVlLCB0aGlzTWluLCB0aGlzTWF4LCBzdGVwKTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlcyA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRyZXBsYWNlSW5kZXgodmFsdWVzUmVmLmN1cnJlbnQsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIHNldFZhbHVlcyhuZXdWYWx1ZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVEcmFnZ2luZyhpbmRleCwgZHJhZ2dpbmcpIHtcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgIWlzVGh1bWJFZGl0YWJsZShpbmRleCkpIHJldHVybjtcbiAgICAgICAgaWYgKGRyYWdnaW5nKSB2YWx1ZXNSZWYuY3VycmVudCA9IHZhbHVlcztcbiAgICAgICAgY29uc3Qgd2FzRHJhZ2dpbmcgPSBpc0RyYWdnaW5nc1JlZi5jdXJyZW50W2luZGV4XTtcbiAgICAgICAgaXNEcmFnZ2luZ3NSZWYuY3VycmVudCA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRyZXBsYWNlSW5kZXgoaXNEcmFnZ2luZ3NSZWYuY3VycmVudCwgaW5kZXgsIGRyYWdnaW5nKTtcbiAgICAgICAgc2V0RHJhZ2dpbmdzKGlzRHJhZ2dpbmdzUmVmLmN1cnJlbnQpO1xuICAgICAgICAvLyBDYWxsIG9uQ2hhbmdlRW5kIGlmIG5vIGhhbmRsZXMgYXJlIGRyYWdnaW5nLlxuICAgICAgICBpZiAob25DaGFuZ2VFbmQgJiYgd2FzRHJhZ2dpbmcgJiYgIWlzRHJhZ2dpbmdzUmVmLmN1cnJlbnQuc29tZShCb29sZWFuKSkgb25DaGFuZ2VFbmQodmFsdWVzUmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFRodW1iUGVyY2VudChpbmRleCwgcGVyY2VudCkge1xuICAgICAgICB1cGRhdGVWYWx1ZShpbmRleCwgZ2V0UGVyY2VudFZhbHVlKHBlcmNlbnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Um91bmRlZFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCh2YWx1ZSAtIG1pblZhbHVlKSAvIHN0ZXApICogc3RlcCArIG1pblZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQZXJjZW50VmFsdWUocGVyY2VudCkge1xuICAgICAgICBjb25zdCB2YWwgPSBwZXJjZW50ICogKG1heFZhbHVlIC0gbWluVmFsdWUpICsgbWluVmFsdWU7XG4gICAgICAgIHJldHVybiAoMCwgJGFUd3V4JGNsYW1wKShnZXRSb3VuZGVkVmFsdWUodmFsKSwgbWluVmFsdWUsIG1heFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5jcmVtZW50VGh1bWIoaW5kZXgsIHN0ZXBTaXplID0gMSkge1xuICAgICAgICBsZXQgcyA9IE1hdGgubWF4KHN0ZXBTaXplLCBzdGVwKTtcbiAgICAgICAgdXBkYXRlVmFsdWUoaW5kZXgsICgwLCAkYVR3dXgkc25hcFZhbHVlVG9TdGVwKSh2YWx1ZXNbaW5kZXhdICsgcywgbWluVmFsdWUsIG1heFZhbHVlLCBzdGVwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY3JlbWVudFRodW1iKGluZGV4LCBzdGVwU2l6ZSA9IDEpIHtcbiAgICAgICAgbGV0IHMgPSBNYXRoLm1heChzdGVwU2l6ZSwgc3RlcCk7XG4gICAgICAgIHVwZGF0ZVZhbHVlKGluZGV4LCAoMCwgJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCkodmFsdWVzW2luZGV4XSAtIHMsIG1pblZhbHVlLCBtYXhWYWx1ZSwgc3RlcCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgZ2V0VGh1bWJWYWx1ZTogKGluZGV4KT0+dmFsdWVzW2luZGV4XSxcbiAgICAgICAgc2V0VGh1bWJWYWx1ZTogdXBkYXRlVmFsdWUsXG4gICAgICAgIHNldFRodW1iUGVyY2VudDogc2V0VGh1bWJQZXJjZW50LFxuICAgICAgICBpc1RodW1iRHJhZ2dpbmc6IChpbmRleCk9PmlzRHJhZ2dpbmdzW2luZGV4XSxcbiAgICAgICAgc2V0VGh1bWJEcmFnZ2luZzogdXBkYXRlRHJhZ2dpbmcsXG4gICAgICAgIGZvY3VzZWRUaHVtYjogZm9jdXNlZEluZGV4LFxuICAgICAgICBzZXRGb2N1c2VkVGh1bWI6IHNldEZvY3VzZWRJbmRleCxcbiAgICAgICAgZ2V0VGh1bWJQZXJjZW50OiAoaW5kZXgpPT5nZXRWYWx1ZVBlcmNlbnQodmFsdWVzW2luZGV4XSksXG4gICAgICAgIGdldFZhbHVlUGVyY2VudDogZ2V0VmFsdWVQZXJjZW50LFxuICAgICAgICBnZXRUaHVtYlZhbHVlTGFiZWw6IChpbmRleCk9PmdldEZvcm1hdHRlZFZhbHVlKHZhbHVlc1tpbmRleF0pLFxuICAgICAgICBnZXRGb3JtYXR0ZWRWYWx1ZTogZ2V0Rm9ybWF0dGVkVmFsdWUsXG4gICAgICAgIGdldFRodW1iTWluVmFsdWU6IGdldFRodW1iTWluVmFsdWUsXG4gICAgICAgIGdldFRodW1iTWF4VmFsdWU6IGdldFRodW1iTWF4VmFsdWUsXG4gICAgICAgIGdldFBlcmNlbnRWYWx1ZTogZ2V0UGVyY2VudFZhbHVlLFxuICAgICAgICBpc1RodW1iRWRpdGFibGU6IGlzVGh1bWJFZGl0YWJsZSxcbiAgICAgICAgc2V0VGh1bWJFZGl0YWJsZTogc2V0VGh1bWJFZGl0YWJsZSxcbiAgICAgICAgaW5jcmVtZW50VGh1bWI6IGluY3JlbWVudFRodW1iLFxuICAgICAgICBkZWNyZW1lbnRUaHVtYjogZGVjcmVtZW50VGh1bWIsXG4gICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZSxcbiAgICAgICAgb3JpZW50YXRpb246IG9yaWVudGF0aW9uLFxuICAgICAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkXG4gICAgfTtcbn1cbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRyZXBsYWNlSW5kZXgoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSByZXR1cm4gYXJyYXk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLi4uYXJyYXkuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4uYXJyYXkuc2xpY2UoaW5kZXggKyAxKVxuICAgIF07XG59XG5mdW5jdGlvbiAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkY29udmVydFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXG4gICAgICAgIHZhbHVlXG4gICAgXTtcbn1cbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjcmVhdGVPbkNoYW5nZSh2YWx1ZSwgZGVmYXVsdFZhbHVlLCBvbkNoYW5nZSkge1xuICAgIHJldHVybiAobmV3VmFsdWUpPT57XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJudW1iZXJcIikgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKG5ld1ZhbHVlWzBdKTtcbiAgICAgICAgZWxzZSBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UobmV3VmFsdWUpO1xuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JDI4Zjk5ZTNlODZlNmVjNDUkZXhwb3J0JGU1ZmRhMzI0N2Y1ZDY3ZjkgYXMgdXNlU2xpZGVyU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInNuYXBWYWx1ZVRvU3RlcCIsIiRhVHd1eCRzbmFwVmFsdWVUb1N0ZXAiLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkYVR3dXgkdXNlQ29udHJvbGxlZFN0YXRlIiwiY2xhbXAiLCIkYVR3dXgkY2xhbXAiLCJ1c2VNZW1vIiwiJGFUd3V4JHVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsIiRhVHd1eCR1c2VDYWxsYmFjayIsInVzZVN0YXRlIiwiJGFUd3V4JHVzZVN0YXRlIiwidXNlUmVmIiwiJGFUd3V4JHVzZVJlZiIsIiQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01JTl9WQUxVRSIsIiQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01BWF9WQUxVRSIsIiQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX1NURVBfVkFMVUUiLCIkMjhmOTllM2U4NmU2ZWM0NSRleHBvcnQkZTVmZGEzMjQ3ZjVkNjdmOSIsInByb3BzIiwiaXNEaXNhYmxlZCIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJudW1iZXJGb3JtYXR0ZXIiLCJmb3JtYXR0ZXIiLCJzdGVwIiwib3JpZW50YXRpb24iLCJwYWdlU2l6ZSIsImNhbGNQYWdlU2l6ZSIsIk1hdGgiLCJtYXgiLCJyZXN0cmljdFZhbHVlcyIsInZhbHVlcyIsIm1hcCIsInZhbCIsImlkeCIsIm1pbiIsImxlbmd0aCIsInZhbHVlIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNvbnZlcnRWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsIl9jb252ZXJ0VmFsdWUiLCJvbkNoYW5nZSIsIiQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjcmVhdGVPbkNoYW5nZSIsIm9uQ2hhbmdlRW5kIiwic2V0VmFsdWVzU3RhdGUiLCJpc0RyYWdnaW5ncyIsInNldERyYWdnaW5nc1N0YXRlIiwiQXJyYXkiLCJmaWxsIiwiaXNFZGl0YWJsZXNSZWYiLCJmb2N1c2VkSW5kZXgiLCJzZXRGb2N1c2VkSW5kZXgiLCJ1bmRlZmluZWQiLCJ2YWx1ZXNSZWYiLCJpc0RyYWdnaW5nc1JlZiIsInNldFZhbHVlcyIsImN1cnJlbnQiLCJzZXREcmFnZ2luZ3MiLCJkcmFnZ2luZ3MiLCJnZXRWYWx1ZVBlcmNlbnQiLCJnZXRUaHVtYk1pblZhbHVlIiwiaW5kZXgiLCJnZXRUaHVtYk1heFZhbHVlIiwiaXNUaHVtYkVkaXRhYmxlIiwic2V0VGh1bWJFZGl0YWJsZSIsImVkaXRhYmxlIiwidXBkYXRlVmFsdWUiLCJ0aGlzTWluIiwidGhpc01heCIsIm5ld1ZhbHVlcyIsIiQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRyZXBsYWNlSW5kZXgiLCJ1cGRhdGVEcmFnZ2luZyIsImRyYWdnaW5nIiwid2FzRHJhZ2dpbmciLCJzb21lIiwiQm9vbGVhbiIsImdldEZvcm1hdHRlZFZhbHVlIiwiZm9ybWF0Iiwic2V0VGh1bWJQZXJjZW50IiwicGVyY2VudCIsImdldFBlcmNlbnRWYWx1ZSIsImdldFJvdW5kZWRWYWx1ZSIsInJvdW5kIiwiaW5jcmVtZW50VGh1bWIiLCJzdGVwU2l6ZSIsInMiLCJkZWNyZW1lbnRUaHVtYiIsImdldFRodW1iVmFsdWUiLCJzZXRUaHVtYlZhbHVlIiwiaXNUaHVtYkRyYWdnaW5nIiwic2V0VGh1bWJEcmFnZ2luZyIsImZvY3VzZWRUaHVtYiIsInNldEZvY3VzZWRUaHVtYiIsImdldFRodW1iUGVyY2VudCIsImdldFRodW1iVmFsdWVMYWJlbCIsImFycmF5Iiwic2xpY2UiLCJpc0FycmF5IiwibmV3VmFsdWUiLCJ1c2VTbGlkZXJTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/slider/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/table/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/table/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ $941d1d9a6a28982a$export$f6f0c3fe4ec306ea),\n/* harmony export */   Column: () => (/* binding */ $1cd244557c2f97d5$export$816b5d811295e6bc),\n/* harmony export */   Row: () => (/* binding */ $70d70eb16ea48428$export$b59bdbef9ce70de2),\n/* harmony export */   Section: () => (/* reexport safe */ _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.Section),\n/* harmony export */   TableBody: () => (/* binding */ $4ae5314bf50db1a3$export$76ccd210b9029917),\n/* harmony export */   TableCollection: () => (/* binding */ $788781baa30117fa$export$596e1b2e2cf93690),\n/* harmony export */   TableColumnLayout: () => (/* binding */ $a9e7ae544a4e41dd$export$7ff77a162970b30e),\n/* harmony export */   TableHeader: () => (/* binding */ $312ae3b56a94a86e$export$f850895b287ef28e),\n/* harmony export */   UNSTABLE_useTreeGridState: () => (/* binding */ $ee65a0057fd99531$export$34dfa8a1622185a4),\n/* harmony export */   buildHeaderRows: () => (/* binding */ $788781baa30117fa$export$7c127db850d4e81e),\n/* harmony export */   useTableColumnResizeState: () => (/* binding */ $292bc4e09cd0eb62$export$cb895dcf85db1319),\n/* harmony export */   useTableState: () => (/* binding */ $4a0dd036d492cee4$export$907bcc6c48325fd6)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/grid */ \"(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\");\n/* harmony import */ var _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/flags */ \"(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {\n    return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\nfunction $6818b1c4fc67028d$export$9078bad4c3934604(width) {\n    if (!width) return 1;\n    let match = width.match(/^(.+)(?=fr$)/);\n    // if width is the incorrect format, just default it to a 1fr\n    if (!match) {\n        console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, \"defaulting to '1fr'\");\n        return 1;\n    }\n    return parseFloat(match[0]);\n}\nfunction $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {\n    if (typeof width === \"string\") {\n        let match = width.match(/^(\\d+)(?=%$)/);\n        if (!match) throw new Error(\"Only percentages or numbers are supported for static column widths\");\n        return tableWidth * (parseFloat(match[0]) / 100);\n    }\n    return width;\n}\nfunction $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {\n    return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;\n}\nfunction $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {\n    return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;\n}\nfunction $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {\n    let hasNonFrozenItems = false;\n    let flexItems = columns.map((column, index)=>{\n        var _column_width, _ref, _ref1;\n        let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : \"1fr\";\n        let frozen = false;\n        let baseSize = 0;\n        let flex = 0;\n        let targetMainSize = null;\n        if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {\n            baseSize = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);\n            frozen = true;\n        } else {\n            flex = $6818b1c4fc67028d$export$9078bad4c3934604(width);\n            if (flex <= 0) frozen = true;\n        }\n        var _column_minWidth, _ref2;\n        let min = $6818b1c4fc67028d$export$f556054ce4358701((_ref2 = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index)) !== null && _ref2 !== void 0 ? _ref2 : 0, availableWidth);\n        let max = $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth);\n        let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));\n        // 9.7.1\n        // We don't make use of flex basis, it's always 0, so we are always in 'grow' mode.\n        // 9.7.2\n        if (frozen) targetMainSize = hypotheticalMainSize;\n        else if (baseSize > hypotheticalMainSize) {\n            frozen = true;\n            targetMainSize = hypotheticalMainSize;\n        }\n        // 9.7.3\n        if (!frozen) hasNonFrozenItems = true;\n        return {\n            frozen: frozen,\n            baseSize: baseSize,\n            hypotheticalMainSize: hypotheticalMainSize,\n            min: min,\n            max: max,\n            flex: flex,\n            targetMainSize: targetMainSize,\n            violation: 0\n        };\n    });\n    // 9.7.4\n    // 9.7.4.a\n    while(hasNonFrozenItems){\n        // 9.7.4.b\n        /**\n     * Calculate the remaining free space as for initial free space,\n     * above (9.7.3). If the sum of the unfrozen flex itemsâ€™ flex factors is\n     * less than one, multiply the initial free space by this sum (of flex factors).\n     * If the magnitude of this value is less than the magnitude of\n     * the remaining free space, use this as the remaining free space.\n     */ let usedWidth = 0;\n        let flexFactors = 0;\n        flexItems.forEach((item)=>{\n            if (item.frozen) usedWidth += item.targetMainSize;\n            else {\n                usedWidth += item.baseSize;\n                flexFactors += item.flex;\n            }\n        });\n        let remainingFreeSpace = availableWidth - usedWidth;\n        // we only support integer FR's, and because of hasNonFrozenItems, we know that flexFactors > 0\n        // so no need to check for flexFactors < 1\n        // 9.7.4.c\n        /**\n     * If the remaining free space is zero\n     * - Do nothing.\n     * Else // remember, we're always in grow mode\n     * - Find the ratio of the itemâ€™s flex grow factor to the\n     * sum of the flex grow factors of all unfrozen items on\n     * the line. Set the itemâ€™s target main size to its flex\n     * base size plus a fraction of the remaining free space\n     * proportional to the ratio.\n     */ if (remainingFreeSpace > 0) flexItems.forEach((item)=>{\n            if (!item.frozen) {\n                let ratio = item.flex / flexFactors;\n                item.targetMainSize = item.baseSize + ratio * remainingFreeSpace;\n            }\n        });\n        // 9.7.4.d\n        /**\n     * Fix min/max violations. Clamp each non-frozen itemâ€™s\n     * target main size by its used min and max main sizes\n     * and floor its content-box size at zero. If the itemâ€™s\n     * target main size was made smaller by this, itâ€™s a max\n     * violation. If the itemâ€™s target main size was made\n     * larger by this, itâ€™s a min violation.\n     */ let totalViolation = 0;\n        flexItems.forEach((item)=>{\n            item.violation = 0;\n            if (!item.frozen) {\n                let { min: min, max: max, targetMainSize: targetMainSize } = item;\n                item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));\n                item.violation = item.targetMainSize - targetMainSize;\n                totalViolation += item.violation;\n            }\n        });\n        // 9.7.4.e\n        /**\n     * Freeze over-flexed items. The total violation is the\n     * sum of the adjustments from the previous step\n     * âˆ‘(clamped size - unclamped size). If the total violation is:\n     * Zero\n     * - Freeze all items.\n     *\n     * Positive\n     * - Freeze all the items with min violations.\n     *\n     * Negative\n     * - Freeze all the items with max violations.\n     */ hasNonFrozenItems = false;\n        flexItems.forEach((item)=>{\n            if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation)) item.frozen = true;\n            else if (!item.frozen) hasNonFrozenItems = true;\n        });\n    }\n    return $6818b1c4fc67028d$var$cascadeRounding(flexItems);\n}\nfunction $6818b1c4fc67028d$var$cascadeRounding(flexItems) {\n    /*\n  Given an array of floats that sum to an integer, this rounds the floats\n  and returns an array of integers with the same sum.\n  */ let fpTotal = 0;\n    let intTotal = 0;\n    let roundedArray = [];\n    flexItems.forEach(function(item) {\n        let float = item.targetMainSize;\n        let integer = Math.round(float + fpTotal) - intTotal;\n        fpTotal += float;\n        intTotal += integer;\n        roundedArray.push(integer);\n    });\n    return roundedArray;\n}\nclass $a9e7ae544a4e41dd$export$7ff77a162970b30e {\n    /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */ splitColumnsIntoControlledAndUncontrolled(columns) {\n        return columns.reduce((acc, col)=>{\n            if (col.props.width != null) acc[0].set(col.key, col);\n            else acc[1].set(col.key, col);\n            return acc;\n        }, [\n            new Map(),\n            new Map()\n        ]);\n    }\n    /** Takes uncontrolled and controlled widths and joins them into a single Map. */ recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {\n        return new Map(columns.map((col)=>{\n            if (uncontrolledColumns.has(col.key)) return [\n                col.key,\n                uncontrolledWidths.get(col.key)\n            ];\n            else return [\n                col.key,\n                controlledColumns.get(col.key).props.width\n            ];\n        }));\n    }\n    /** Used to make an initial Map of the uncontrolled widths based on default widths. */ getInitialUncontrolledWidths(uncontrolledColumns) {\n        return new Map(Array.from(uncontrolledColumns).map(([key, col])=>{\n            var _this_getDefaultWidth, _this;\n            var _col_props_defaultWidth, _ref;\n            return [\n                key,\n                (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : \"1fr\"\n            ];\n        }));\n    }\n    getColumnWidth(key) {\n        var _this_columnWidths_get;\n        return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n    }\n    getColumnMinWidth(key) {\n        var _this_columnMinWidths_get;\n        return (_this_columnMinWidths_get = this.columnMinWidths.get(key)) !== null && _this_columnMinWidths_get !== void 0 ? _this_columnMinWidths_get : 0;\n    }\n    getColumnMaxWidth(key) {\n        var _this_columnMaxWidths_get;\n        return (_this_columnMaxWidths_get = this.columnMaxWidths.get(key)) !== null && _this_columnMaxWidths_get !== void 0 ? _this_columnMaxWidths_get : 0;\n    }\n    resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {\n        let prevColumnWidths = this.columnWidths;\n        // resizing a column\n        let resizeIndex = Infinity;\n        let resizingChanged = new Map([\n            ...controlledWidths,\n            ...uncontrolledWidths\n        ]);\n        let percentKeys = new Map();\n        let frKeysToTheRight = new Map();\n        let minWidths = new Map();\n        // freeze columns to the left to their previous pixel value\n        collection.columns.forEach((column, i)=>{\n            var _column_props_width_endsWith, _column_props_width;\n            let frKey;\n            let frValue;\n            minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n            if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {\n                // uncontrolled don't have props.width for us, so instead get from our state\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));\n            } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {\n                // controlledWidths will be the same in the collection\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);\n            } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, \"%\"))) percentKeys.set(column.key, column.props.width);\n            // don't freeze columns to the right of the resizing one\n            if (resizeIndex < i) {\n                if (frKey) frKeysToTheRight.set(frKey, frValue);\n                return;\n            }\n            // we already know the new size of the resizing column\n            if (column.key === col) {\n                resizeIndex = i;\n                resizingChanged.set(column.key, Math.floor(width));\n                return;\n            }\n            // freeze column to previous value\n            resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n        });\n        // predict pixels sizes for all columns based on resize\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), resizingChanged, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // set all new column widths for onResize event\n        // columns going in will be the same order as the columns coming out\n        let newWidths = new Map();\n        // set all column widths based on calculateColumnSize\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            newWidths.set(key, width);\n        });\n        // add FR's back as they were to columns to the right\n        Array.from(frKeysToTheRight).forEach(([key])=>{\n            newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n        });\n        // put back in percents\n        Array.from(percentKeys).forEach(([key, width])=>{\n            // resizing locks a column to a px width\n            if (key === col) return;\n            newWidths.set(key, width);\n        });\n        return newWidths;\n    }\n    buildColumnWidths(tableWidth, collection, widths) {\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        // initial layout or table/window resizing\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), widths, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // columns going in will be the same order as the columns coming out\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            let column = collection.columns[index];\n            this.columnWidths.set(key, width);\n            var _column_props_minWidth;\n            this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));\n            this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));\n        });\n        return this.columnWidths;\n    }\n    constructor(options){\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        var _options_getDefaultWidth;\n        this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : ()=>\"1fr\";\n        var _options_getDefaultMinWidth;\n        this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : ()=>75;\n    }\n}\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n    let { getDefaultWidth: getDefaultWidth, getDefaultMinWidth: getDefaultMinWidth, tableWidth: tableWidth = 0 } = props;\n    let [resizingColumn, setResizingColumn] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let columnLayout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({\n            getDefaultWidth: getDefaultWidth,\n            getDefaultMinWidth: getDefaultMinWidth\n        }), [\n        getDefaultWidth,\n        getDefaultMinWidth\n    ]);\n    let [controlledColumns, uncontrolledColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [\n        state.collection.columns,\n        columnLayout\n    ]);\n    // uncontrolled column widths\n    let [uncontrolledWidths, setUncontrolledWidths] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));\n    // Update uncontrolled widths if the columns changed.\n    let [lastColumns, setLastColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(state.collection.columns);\n    if (state.collection.columns !== lastColumns) {\n        if (state.collection.columns.length !== lastColumns.length || state.collection.columns.some((c, i)=>c.key !== lastColumns[i].key)) {\n            let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n            setUncontrolledWidths(newUncontrolledWidths);\n        }\n        setLastColumns(state.collection.columns);\n    }\n    // combine columns back into one map that maintains same order as the columns\n    let colWidths = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [\n        state.collection.columns,\n        uncontrolledWidths,\n        uncontrolledColumns,\n        controlledColumns,\n        columnLayout\n    ]);\n    let startResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key)=>{\n        setResizingColumn(key);\n    }, [\n        setResizingColumn\n    ]);\n    let updateResizedColumns = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key, width)=>{\n        let newControlled = new Map(Array.from(controlledColumns).map(([key, entry])=>[\n                key,\n                entry.props.width\n            ]));\n        let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n        let map = new Map(Array.from(uncontrolledColumns).map(([key])=>[\n                key,\n                newSizes.get(key)\n            ]));\n        map.set(key, width);\n        setUncontrolledWidths(map);\n        return newSizes;\n    }, [\n        controlledColumns,\n        uncontrolledColumns,\n        setUncontrolledWidths,\n        tableWidth,\n        columnLayout,\n        state.collection,\n        uncontrolledWidths\n    ]);\n    let endResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResizingColumn(null);\n    }, [\n        setResizingColumn\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [\n        tableWidth,\n        state.collection,\n        colWidths,\n        columnLayout\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            resizingColumn: resizingColumn,\n            updateResizedColumns: updateResizedColumns,\n            startResize: startResize,\n            endResize: endResize,\n            getColumnWidth: (key)=>columnLayout.getColumnWidth(key),\n            getColumnMinWidth: (key)=>columnLayout.getColumnMinWidth(key),\n            getColumnMaxWidth: (key)=>columnLayout.getColumnMaxWidth(key),\n            tableState: state\n        }), [\n        columnLayout,\n        resizingColumn,\n        updateResizedColumns,\n        startResize,\n        endResize,\n        state\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = \"row-header-column-\" + Math.random().toString(36).slice(2);\nlet $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nwhile($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG)$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {\n    if (columnNodes.length === 0) return [];\n    let columns = [];\n    let seen = new Map();\n    for (let column of columnNodes){\n        let parentKey = column.parentKey;\n        let col = [\n            column\n        ];\n        while(parentKey){\n            let parent = keyMap.get(parentKey);\n            if (!parent) break;\n            // If we've already seen this parent, than it is shared\n            // with a previous column. If the current column is taller\n            // than the previous column, than we need to shift the parent\n            // in the previous column so it's level with the current column.\n            if (seen.has(parent)) {\n                parent.colspan++;\n                let { column: column, index: index } = seen.get(parent);\n                if (index > col.length) break;\n                for(let i = index; i < col.length; i++)column.splice(i, 0, null);\n                // Adjust shifted indices\n                for(let i = col.length; i < column.length; i++)if (column[i] && seen.has(column[i])) seen.get(column[i]).index = i;\n            } else {\n                parent.colspan = 1;\n                col.push(parent);\n                seen.set(parent, {\n                    column: col,\n                    index: col.length - 1\n                });\n            }\n            parentKey = parent.parentKey;\n        }\n        columns.push(col);\n        column.index = columns.length - 1;\n    }\n    let maxLength = Math.max(...columns.map((c)=>c.length));\n    let headerRows = Array(maxLength).fill(0).map(()=>[]);\n    // Convert columns into rows.\n    let colIndex = 0;\n    for (let column of columns){\n        let i = maxLength - 1;\n        for (let item of column){\n            if (item) {\n                // Fill the space up until the current column with a placeholder\n                let row = headerRows[i];\n                let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n                if (rowLength < colIndex) {\n                    let placeholder = {\n                        type: \"placeholder\",\n                        key: \"placeholder-\" + item.key,\n                        colspan: colIndex - rowLength,\n                        index: rowLength,\n                        value: null,\n                        rendered: null,\n                        level: i,\n                        hasChildNodes: false,\n                        childNodes: [],\n                        textValue: null\n                    };\n                    // eslint-disable-next-line max-depth\n                    if (row.length > 0) {\n                        row[row.length - 1].nextKey = placeholder.key;\n                        placeholder.prevKey = row[row.length - 1].key;\n                    }\n                    row.push(placeholder);\n                }\n                if (row.length > 0) {\n                    row[row.length - 1].nextKey = item.key;\n                    item.prevKey = row[row.length - 1].key;\n                }\n                item.level = i;\n                item.colIndex = colIndex;\n                row.push(item);\n            }\n            i--;\n        }\n        colIndex++;\n    }\n    // Add placeholders at the end of each row that is shorter than the maximum\n    let i = 0;\n    for (let row of headerRows){\n        let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n        if (rowLength < columnNodes.length) {\n            let placeholder = {\n                type: \"placeholder\",\n                key: \"placeholder-\" + row[row.length - 1].key,\n                colspan: columnNodes.length - rowLength,\n                index: rowLength,\n                value: null,\n                rendered: null,\n                level: i,\n                hasChildNodes: false,\n                childNodes: [],\n                textValue: null,\n                prevKey: row[row.length - 1].key\n            };\n            row.push(placeholder);\n        }\n        i++;\n    }\n    return headerRows.map((childNodes, index)=>{\n        let row = {\n            type: \"headerrow\",\n            key: \"headerrow-\" + index,\n            index: index,\n            value: null,\n            rendered: null,\n            level: 0,\n            hasChildNodes: true,\n            childNodes: childNodes,\n            textValue: null\n        };\n        return row;\n    });\n}\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.GridCollection) {\n    *[Symbol.iterator]() {\n        yield* this.body.childNodes;\n    }\n    get size() {\n        return this._size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _getFirstItem;\n        return (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n    }\n    getLastKey() {\n        var _getLastItem;\n        return (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getTextValue(key) {\n        let row = this.getItem(key);\n        if (!row) return \"\";\n        // If the row has a textValue, use that.\n        if (row.textValue) return row.textValue;\n        // Otherwise combine the text of each of the row header columns.\n        let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n        if (rowHeaderColumnKeys) {\n            let text = [];\n            for (let cell of row.childNodes){\n                let column = this.columns[cell.index];\n                if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);\n                if (text.length === rowHeaderColumnKeys.size) break;\n            }\n            return text.join(\" \");\n        }\n        return \"\";\n    }\n    constructor(nodes, prev, opts){\n        let rowHeaderColumnKeys = new Set();\n        let body;\n        let columns = [];\n        // Add cell for selection checkboxes if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        // Add cell for drag buttons if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        let rows = [];\n        let columnKeyMap = new Map();\n        let visit = (node)=>{\n            switch(node.type){\n                case \"body\":\n                    body = node;\n                    break;\n                case \"column\":\n                    columnKeyMap.set(node.key, node);\n                    if (!node.hasChildNodes) {\n                        columns.push(node);\n                        if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n                    }\n                    break;\n                case \"item\":\n                    rows.push(node);\n                    return; // do not go into childNodes\n            }\n            for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);\n        headerRows.forEach((row, i)=>rows.splice(i, 0, row));\n        super({\n            columnCount: columns.length,\n            items: rows,\n            visitNode: (node)=>{\n                node.column = columns[node.index];\n                return node;\n            }\n        });\n        this._size = 0;\n        this.columns = columns;\n        this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n        this.body = body;\n        this.headerRows = headerRows;\n        this._size = [\n            ...body.childNodes\n        ].length;\n        // Default row header column to the first one.\n        if (this.rowHeaderColumnKeys.size === 0) this.rowHeaderColumnKeys.add(this.columns.find((column)=>{\n            var _column_props, _column_props1;\n            return !((_column_props = column.props) === null || _column_props === void 0 ? void 0 : _column_props.isDragButtonCell) && !((_column_props1 = column.props) === null || _column_props1 === void 0 ? void 0 : _column_props1.isSelectionCell);\n        }).key);\n    }\n}\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n    ascending: \"descending\",\n    descending: \"ascending\"\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n    let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons } = props;\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        props.children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, null, context), [\n        context\n    ]), context);\n    let { disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.useGridState)({\n        ...props,\n        collection: collection,\n        disabledBehavior: props.disabledBehavior || \"selection\"\n    });\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n        sortDescriptor: props.sortDescriptor,\n        isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n        setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n        sort (columnKey, direction) {\n            var _props_sortDescriptor;\n            props.onSortChange({\n                column: columnKey,\n                direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : \"ascending\"\n            });\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $312ae3b56a94a86e$var$TableHeader(props) {\n    return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, columns: columns } = props;\n    // Clear columns so they aren't double added in strict mode.\n    context.columns = [];\n    if (typeof children === \"function\") {\n        if (!columns) throw new Error(\"props.children was a function but props.columns is missing\");\n        for (let column of columns)yield {\n            type: \"column\",\n            value: column,\n            renderer: children\n        };\n    } else {\n        let columns = [];\n        (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (column)=>{\n            columns.push({\n                type: \"column\",\n                element: column\n            });\n        });\n        yield* columns;\n    }\n};\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $4ae5314bf50db1a3$var$TableBody(props) {\n    return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, items: items } = props;\n    yield {\n        type: \"body\",\n        hasChildNodes: true,\n        props: props,\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (item)=>{\n                    items.push({\n                        type: \"item\",\n                        element: item\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $1cd244557c2f97d5$var$Column(props) {\n    return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context) {\n    let { title: title, children: children, childColumns: childColumns } = props;\n    let rendered = title || children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"];\n    let fullNodes = yield {\n        type: \"column\",\n        hasChildNodes: !!childColumns || title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(children) > 0,\n        rendered: rendered,\n        textValue: textValue,\n        props: props,\n        *childNodes () {\n            if (childColumns) for (let child of childColumns)yield {\n                type: \"column\",\n                value: child\n            };\n            else if (title) {\n                let childColumns = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    childColumns.push({\n                        type: \"column\",\n                        element: child\n                    });\n                });\n                yield* childColumns;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // This is a bit of a hack, but it works.\n            // If this method is called, then there's a cached version of this node available.\n            // But, we need to keep the list of columns in the new context up to date.\n            updateContext(newContext);\n            return false;\n        }\n    };\n    let updateContext = (context)=>{\n        // register leaf columns on the context so that <Row> can access them\n        for (let node of fullNodes)if (!node.hasChildNodes) context.columns.push(node);\n    };\n    updateContext(context);\n};\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $70d70eb16ea48428$var$Row(props) {\n    return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, textValue: textValue, UNSTABLE_childItems: UNSTABLE_childItems } = props;\n    yield {\n        type: \"item\",\n        props: props,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: true,\n        *childNodes () {\n            // Process cells first\n            if (context.showDragButtons) yield {\n                type: \"cell\",\n                key: \"header-drag\",\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            if (context.showSelectionCheckboxes && context.selectionMode !== \"none\") yield {\n                type: \"cell\",\n                key: \"header\",\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            if (typeof children === \"function\") {\n                for (let column of context.columns)yield {\n                    type: \"cell\",\n                    element: children(column.key),\n                    key: column.key // this is combined with the row key by CollectionBuilder\n                };\n                if (UNSTABLE_childItems) for (let child of UNSTABLE_childItems)// the parent renderer and use that to build the full node of this child row, using the value provided here to generate the cells\n                yield {\n                    type: \"item\",\n                    value: child\n                };\n            } else {\n                let cells = [];\n                let childRows = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (node)=>{\n                    if (node.type === $70d70eb16ea48428$var$Row) {\n                        if (cells.length < context.columns.length) throw new Error(\"All of a Row's child Cells must be positioned before any child Rows.\");\n                        childRows.push({\n                            type: \"item\",\n                            element: node\n                        });\n                    } else cells.push({\n                        type: \"cell\",\n                        element: node\n                    });\n                });\n                if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n                yield* cells;\n                yield* childRows;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // Invalidate all rows if the columns changed.\n            return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i)=>c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.showDragButtons !== context.showDragButtons || newContext.selectionMode !== context.selectionMode;\n        }\n    };\n};\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $941d1d9a6a28982a$var$Cell(props) {\n    return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children } = props;\n    let textValue = props.textValue || (typeof children === \"string\" ? children : \"\") || props[\"aria-label\"] || \"\";\n    yield {\n        type: \"cell\",\n        props: props,\n        rendered: children,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: false\n    };\n};\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $ee65a0057fd99531$export$34dfa8a1622185a4(props) {\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons, UNSTABLE_expandedKeys: propExpandedKeys, UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys, UNSTABLE_onExpandedChange: UNSTABLE_onExpandedChange, children: children } = props;\n    if (!(0, _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__.tableNestedRows)()) throw new Error(\"Feature flag for table nested rows must be enabled to use useTreeGridState.\");\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__.useControlledState)(propExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propDefaultExpandedKeys) : new Set(), UNSTABLE_onExpandedChange);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.CollectionBuilder)(), []);\n    let nodes = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>builder.build({\n            children: children\n        }, context), [\n        builder,\n        children,\n        context\n    ]);\n    let treeGridCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return $ee65a0057fd99531$var$generateTreeGridCollection(nodes, {\n            showSelectionCheckboxes: showSelectionCheckboxes,\n            showDragButtons: showDragButtons,\n            expandedKeys: expandedKeys\n        });\n    }, [\n        nodes,\n        showSelectionCheckboxes,\n        showDragButtons,\n        expandedKeys\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($ee65a0057fd99531$var$toggleKey(expandedKeys, key, treeGridCollection));\n    };\n    let collection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new (0, $788781baa30117fa$export$596e1b2e2cf93690)(treeGridCollection.tableNodes, null, context);\n    }, [\n        context,\n        treeGridCollection.tableNodes\n    ]);\n    let tableState = (0, $4a0dd036d492cee4$export$907bcc6c48325fd6)({\n        ...props,\n        collection: collection\n    });\n    return {\n        ...tableState,\n        keyMap: treeGridCollection.keyMap,\n        userColumnCount: treeGridCollection.userColumnCount,\n        expandedKeys: expandedKeys,\n        toggleKey: onToggle\n    };\n}\nfunction $ee65a0057fd99531$var$toggleKey(currentExpandedKeys, key, collection) {\n    let updatedExpandedKeys;\n    if (currentExpandedKeys === \"all\") {\n        updatedExpandedKeys = new Set(collection.flattenedRows.filter((row)=>row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map((row)=>row.key));\n        updatedExpandedKeys.delete(key);\n    } else {\n        updatedExpandedKeys = new Set(currentExpandedKeys);\n        if (updatedExpandedKeys.has(key)) updatedExpandedKeys.delete(key);\n        else updatedExpandedKeys.add(key);\n    }\n    return updatedExpandedKeys;\n}\nfunction $ee65a0057fd99531$var$convertExpanded(expanded) {\n    if (!expanded) return new Set();\n    return expanded === \"all\" ? \"all\" : new Set(expanded);\n}\nfunction $ee65a0057fd99531$var$generateTreeGridCollection(nodes, opts) {\n    let { expandedKeys: expandedKeys = new Set() } = opts;\n    let body;\n    let flattenedRows = [];\n    let columnCount = 0;\n    let userColumnCount = 0;\n    let originalColumns = [];\n    let keyMap = new Map();\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) columnCount++;\n    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) columnCount++;\n    let topLevelRows = [];\n    let visit = (node)=>{\n        switch(node.type){\n            case \"body\":\n                body = node;\n                keyMap.set(body.key, body);\n                break;\n            case \"column\":\n                if (!node.hasChildNodes) userColumnCount++;\n                break;\n            case \"item\":\n                topLevelRows.push(node);\n                return;\n        }\n        for (let child of node.childNodes)visit(child);\n    };\n    for (let node of nodes){\n        if (node.type === \"column\") originalColumns.push(node);\n        visit(node);\n    }\n    columnCount += userColumnCount;\n    // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n    let globalRowCount = 0;\n    let visitNode = (node, i)=>{\n        // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n        // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n        // values automatically calculated via CollectionBuilder\n        if (node.type === \"item\") {\n            let childNodes = [];\n            for (let child of node.childNodes)if (child.type === \"cell\") {\n                let cellClone = {\n                    ...child\n                };\n                if (cellClone.index + 1 === columnCount) cellClone.nextKey = null;\n                childNodes.push({\n                    ...cellClone\n                });\n            }\n            let clone = {\n                ...node,\n                childNodes: childNodes,\n                parentKey: body.key,\n                level: 1,\n                index: globalRowCount++\n            };\n            flattenedRows.push(clone);\n        }\n        let newProps = {};\n        // Assign indexOfType to cells and rows for aria-posinset\n        if (node.type !== \"placeholder\" && node.type !== \"column\") newProps[\"indexOfType\"] = i;\n        // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n        // via .childNodes returns the same object as the one found via keyMap look up\n        Object.assign(node, newProps);\n        keyMap.set(node.key, node);\n        let lastNode;\n        let rowIndex = 0;\n        for (let child of node.childNodes)if (!(child.type === \"item\" && expandedKeys !== \"all\" && !expandedKeys.has(node.key))) {\n            if (child.parentKey == null) child.parentKey = node.key;\n            if (lastNode) {\n                lastNode.nextKey = child.key;\n                child.prevKey = lastNode.key;\n            } else child.prevKey = null;\n            if (child.type === \"item\") visitNode(child, rowIndex++);\n            else visitNode(child, child.index);\n            lastNode = child;\n        }\n        if (lastNode) lastNode.nextKey = null;\n    };\n    let last;\n    topLevelRows.forEach((node, i)=>{\n        visitNode(node, i);\n        if (last) {\n            last.nextKey = node.key;\n            node.prevKey = last.key;\n        } else node.prevKey = null;\n        last = node;\n    });\n    if (last) last.nextKey = null;\n    return {\n        keyMap: keyMap,\n        userColumnCount: userColumnCount,\n        flattenedRows: flattenedRows,\n        tableNodes: [\n            ...originalColumns,\n            {\n                ...body,\n                childNodes: flattenedRows\n            }\n        ]\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFibGUvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdQO0FBQzFIO0FBQ2I7QUFDbEM7QUFDTTtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsU0FBU3lCLDBDQUEwQ0MsS0FBSztJQUN4RCxPQUFPQSxTQUFTLFFBQVMsRUFBQ0MsTUFBTUQsVUFBVUUsT0FBT0YsT0FBT0csS0FBSyxDQUFDLG9CQUFvQixJQUFHO0FBQ3pGO0FBQ0EsU0FBU0MsMENBQTBDSixLQUFLO0lBQ3BELElBQUksQ0FBQ0EsT0FBTyxPQUFPO0lBQ25CLElBQUlHLFFBQVFILE1BQU1HLEtBQUssQ0FBQztJQUN4Qiw2REFBNkQ7SUFDN0QsSUFBSSxDQUFDQSxPQUFPO1FBQ1JFLFFBQVFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRU4sTUFBTSw2R0FBNkcsQ0FBQyxFQUFFO1FBQzdJLE9BQU87SUFDWDtJQUNBLE9BQU9PLFdBQVdKLEtBQUssQ0FBQyxFQUFFO0FBQzlCO0FBQ0EsU0FBU0ssMENBQTBDUixLQUFLLEVBQUVTLFVBQVU7SUFDaEUsSUFBSSxPQUFPVCxVQUFVLFVBQVU7UUFDM0IsSUFBSUcsUUFBUUgsTUFBTUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQ0EsT0FBTyxNQUFNLElBQUlPLE1BQU07UUFDNUIsT0FBT0QsYUFBY0YsQ0FBQUEsV0FBV0osS0FBSyxDQUFDLEVBQUUsSUFBSSxHQUFFO0lBQ2xEO0lBQ0EsT0FBT0g7QUFDWDtBQUNBLFNBQVNXLDBDQUEwQ0MsUUFBUSxFQUFFSCxVQUFVO0lBQ25FLE9BQU9HLFlBQVksT0FBT0osMENBQTBDSSxVQUFVSCxjQUFjSSxPQUFPQyxnQkFBZ0I7QUFDdkg7QUFDQSxTQUFTQywwQ0FBMENDLFFBQVEsRUFBRVAsVUFBVTtJ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QUFZO2VBQ0xTO1lBQ0g7Z0JBQ0ksR0FBRzdHLElBQUk7Z0JBQ1BQLFlBQVlnSDtZQUNoQjtTQUNIO0lBQ0w7QUFDSjtBQUs0c0IsQ0FDNXNCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3RhYmxlL2Rpc3QvaW1wb3J0Lm1qcz82Y2RjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2VjdGlvbiBhcyAkNjU1NTEwNGZmMDg1YmVmNCRyZV9leHBvcnQkU2VjdGlvbiwgdXNlQ29sbGVjdGlvbiBhcyAkMUJmalckdXNlQ29sbGVjdGlvbiwgZ2V0Rmlyc3RJdGVtIGFzICQxQmZqVyRnZXRGaXJzdEl0ZW0sIGdldExhc3RJdGVtIGFzICQxQmZqVyRnZXRMYXN0SXRlbSwgQ29sbGVjdGlvbkJ1aWxkZXIgYXMgJDFCZmpXJENvbGxlY3Rpb25CdWlsZGVyfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCAkMUJmalckcmVhY3QsIHt1c2VTdGF0ZSBhcyAkMUJmalckdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDFCZmpXJHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICQxQmZqVyR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUdyaWRTdGF0ZSBhcyAkMUJmalckdXNlR3JpZFN0YXRlLCBHcmlkQ29sbGVjdGlvbiBhcyAkMUJmalckR3JpZENvbGxlY3Rpb259IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9ncmlkXCI7XG5pbXBvcnQge3RhYmxlTmVzdGVkUm93cyBhcyAkMUJmalckdGFibGVOZXN0ZWRSb3dzfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZmxhZ3NcIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICQxQmZqVyR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUod2lkdGgpIHtcbiAgICByZXR1cm4gd2lkdGggIT0gbnVsbCAmJiAoIWlzTmFOKHdpZHRoKSB8fCBTdHJpbmcod2lkdGgpLm1hdGNoKC9eKFxcZCspKD89JSQpLykgIT09IG51bGwpO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDkwNzhiYWQ0YzM5MzQ2MDQod2lkdGgpIHtcbiAgICBpZiAoIXdpZHRoKSByZXR1cm4gMTtcbiAgICBsZXQgbWF0Y2ggPSB3aWR0aC5tYXRjaCgvXiguKykoPz1mciQpLyk7XG4gICAgLy8gaWYgd2lkdGggaXMgdGhlIGluY29ycmVjdCBmb3JtYXQsIGp1c3QgZGVmYXVsdCBpdCB0byBhIDFmclxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGB3aWR0aDogJHt3aWR0aH0gaXMgbm90IGEgc3VwcG9ydGVkIGZvcm1hdCwgd2lkdGggc2hvdWxkIGJlIGEgbnVtYmVyIChleC4gMTUwKSwgcGVyY2VudGFnZSAoZXguICc1MCUnKSBvciBmciB1bml0IChleC4gJzJmcicpYCwgXCJkZWZhdWx0aW5nIHRvICcxZnInXCIpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMF0pO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYod2lkdGgsIHRhYmxlV2lkdGgpIHtcbiAgICBpZiAodHlwZW9mIHdpZHRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHdpZHRoLm1hdGNoKC9eKFxcZCspKD89JSQpLyk7XG4gICAgICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIk9ubHkgcGVyY2VudGFnZXMgb3IgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGZvciBzdGF0aWMgY29sdW1uIHdpZHRoc1wiKTtcbiAgICAgICAgcmV0dXJuIHRhYmxlV2lkdGggKiAocGFyc2VGbG9hdChtYXRjaFswXSkgLyAxMDApO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMChtYXhXaWR0aCwgdGFibGVXaWR0aCkge1xuICAgIHJldHVybiBtYXhXaWR0aCAhPSBudWxsID8gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYobWF4V2lkdGgsIHRhYmxlV2lkdGgpIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkZjU1NjA1NGNlNDM1ODcwMShtaW5XaWR0aCwgdGFibGVXaWR0aCkge1xuICAgIHJldHVybiBtaW5XaWR0aCAhPSBudWxsID8gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYobWluV2lkdGgsIHRhYmxlV2lkdGgpIDogMDtcbn1cbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxKGF2YWlsYWJsZVdpZHRoLCBjb2x1bW5zLCBjaGFuZ2VkQ29sdW1ucywgZ2V0RGVmYXVsdFdpZHRoLCBnZXREZWZhdWx0TWluV2lkdGgpIHtcbiAgICBsZXQgaGFzTm9uRnJvemVuSXRlbXMgPSBmYWxzZTtcbiAgICBsZXQgZmxleEl0ZW1zID0gY29sdW1ucy5tYXAoKGNvbHVtbiwgaW5kZXgpPT57XG4gICAgICAgIHZhciBfY29sdW1uX3dpZHRoLCBfcmVmLCBfcmVmMTtcbiAgICAgICAgbGV0IHdpZHRoID0gY2hhbmdlZENvbHVtbnMuZ2V0KGNvbHVtbi5rZXkpICE9IG51bGwgPyBjaGFuZ2VkQ29sdW1ucy5nZXQoY29sdW1uLmtleSkgOiAoX3JlZjEgPSAoX3JlZiA9IChfY29sdW1uX3dpZHRoID0gY29sdW1uLndpZHRoKSAhPT0gbnVsbCAmJiBfY29sdW1uX3dpZHRoICE9PSB2b2lkIDAgPyBfY29sdW1uX3dpZHRoIDogY29sdW1uLmRlZmF1bHRXaWR0aCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IGdldERlZmF1bHRXaWR0aCA9PT0gbnVsbCB8fCBnZXREZWZhdWx0V2lkdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldERlZmF1bHRXaWR0aChpbmRleCkpICE9PSBudWxsICYmIF9yZWYxICE9PSB2b2lkIDAgPyBfcmVmMSA6IFwiMWZyXCI7XG4gICAgICAgIGxldCBmcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgbGV0IGJhc2VTaXplID0gMDtcbiAgICAgICAgbGV0IGZsZXggPSAwO1xuICAgICAgICBsZXQgdGFyZ2V0TWFpblNpemUgPSBudWxsO1xuICAgICAgICBpZiAoJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUod2lkdGgpKSB7XG4gICAgICAgICAgICBiYXNlU2l6ZSA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ3YmJhZDI3ODk2ZjdhZTlmKHdpZHRoLCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgICAgICBmcm96ZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxleCA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KHdpZHRoKTtcbiAgICAgICAgICAgIGlmIChmbGV4IDw9IDApIGZyb3plbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jb2x1bW5fbWluV2lkdGgsIF9yZWYyO1xuICAgICAgICBsZXQgbWluID0gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JGY1NTYwNTRjZTQzNTg3MDEoKF9yZWYyID0gKF9jb2x1bW5fbWluV2lkdGggPSBjb2x1bW4ubWluV2lkdGgpICE9PSBudWxsICYmIF9jb2x1bW5fbWluV2lkdGggIT09IHZvaWQgMCA/IF9jb2x1bW5fbWluV2lkdGggOiBnZXREZWZhdWx0TWluV2lkdGggPT09IG51bGwgfHwgZ2V0RGVmYXVsdE1pbldpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXREZWZhdWx0TWluV2lkdGgoaW5kZXgpKSAhPT0gbnVsbCAmJiBfcmVmMiAhPT0gdm9pZCAwID8gX3JlZjIgOiAwLCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgIGxldCBtYXggPSAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMChjb2x1bW4ubWF4V2lkdGgsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgbGV0IGh5cG90aGV0aWNhbE1haW5TaXplID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbihiYXNlU2l6ZSwgbWF4KSk7XG4gICAgICAgIC8vIDkuNy4xXG4gICAgICAgIC8vIFdlIGRvbid0IG1ha2UgdXNlIG9mIGZsZXggYmFzaXMsIGl0J3MgYWx3YXlzIDAsIHNvIHdlIGFyZSBhbHdheXMgaW4gJ2dyb3cnIG1vZGUuXG4gICAgICAgIC8vIDkuNy4yXG4gICAgICAgIGlmIChmcm96ZW4pIHRhcmdldE1haW5TaXplID0gaHlwb3RoZXRpY2FsTWFpblNpemU7XG4gICAgICAgIGVsc2UgaWYgKGJhc2VTaXplID4gaHlwb3RoZXRpY2FsTWFpblNpemUpIHtcbiAgICAgICAgICAgIGZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICB0YXJnZXRNYWluU2l6ZSA9IGh5cG90aGV0aWNhbE1haW5TaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIDkuNy4zXG4gICAgICAgIGlmICghZnJvemVuKSBoYXNOb25Gcm96ZW5JdGVtcyA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm96ZW46IGZyb3plbixcbiAgICAgICAgICAgIGJhc2VTaXplOiBiYXNlU2l6ZSxcbiAgICAgICAgICAgIGh5cG90aGV0aWNhbE1haW5TaXplOiBoeXBvdGhldGljYWxNYWluU2l6ZSxcbiAgICAgICAgICAgIG1pbjogbWluLFxuICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICBmbGV4OiBmbGV4LFxuICAgICAgICAgICAgdGFyZ2V0TWFpblNpemU6IHRhcmdldE1haW5TaXplLFxuICAgICAgICAgICAgdmlvbGF0aW9uOiAwXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgLy8gOS43LjRcbiAgICAvLyA5LjcuNC5hXG4gICAgd2hpbGUoaGFzTm9uRnJvemVuSXRlbXMpe1xuICAgICAgICAvLyA5LjcuNC5iXG4gICAgICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UgYXMgZm9yIGluaXRpYWwgZnJlZSBzcGFjZSxcbiAgICAgKiBhYm92ZSAoOS43LjMpLiBJZiB0aGUgc3VtIG9mIHRoZSB1bmZyb3plbiBmbGV4IGl0ZW1z4oCZIGZsZXggZmFjdG9ycyBpc1xuICAgICAqIGxlc3MgdGhhbiBvbmUsIG11bHRpcGx5IHRoZSBpbml0aWFsIGZyZWUgc3BhY2UgYnkgdGhpcyBzdW0gKG9mIGZsZXggZmFjdG9ycykuXG4gICAgICogSWYgdGhlIG1hZ25pdHVkZSBvZiB0aGlzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWFnbml0dWRlIG9mXG4gICAgICogdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlLCB1c2UgdGhpcyBhcyB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UuXG4gICAgICovIGxldCB1c2VkV2lkdGggPSAwO1xuICAgICAgICBsZXQgZmxleEZhY3RvcnMgPSAwO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGlmIChpdGVtLmZyb3plbikgdXNlZFdpZHRoICs9IGl0ZW0udGFyZ2V0TWFpblNpemU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1c2VkV2lkdGggKz0gaXRlbS5iYXNlU2l6ZTtcbiAgICAgICAgICAgICAgICBmbGV4RmFjdG9ycyArPSBpdGVtLmZsZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVtYWluaW5nRnJlZVNwYWNlID0gYXZhaWxhYmxlV2lkdGggLSB1c2VkV2lkdGg7XG4gICAgICAgIC8vIHdlIG9ubHkgc3VwcG9ydCBpbnRlZ2VyIEZSJ3MsIGFuZCBiZWNhdXNlIG9mIGhhc05vbkZyb3plbkl0ZW1zLCB3ZSBrbm93IHRoYXQgZmxleEZhY3RvcnMgPiAwXG4gICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGZsZXhGYWN0b3JzIDwgMVxuICAgICAgICAvLyA5LjcuNC5jXG4gICAgICAgIC8qKlxuICAgICAqIElmIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZSBpcyB6ZXJvXG4gICAgICogLSBEbyBub3RoaW5nLlxuICAgICAqIEVsc2UgLy8gcmVtZW1iZXIsIHdlJ3JlIGFsd2F5cyBpbiBncm93IG1vZGVcbiAgICAgKiAtIEZpbmQgdGhlIHJhdGlvIG9mIHRoZSBpdGVt4oCZcyBmbGV4IGdyb3cgZmFjdG9yIHRvIHRoZVxuICAgICAqIHN1bSBvZiB0aGUgZmxleCBncm93IGZhY3RvcnMgb2YgYWxsIHVuZnJvemVuIGl0ZW1zIG9uXG4gICAgICogdGhlIGxpbmUuIFNldCB0aGUgaXRlbeKAmXMgdGFyZ2V0IG1haW4gc2l6ZSB0byBpdHMgZmxleFxuICAgICAqIGJhc2Ugc2l6ZSBwbHVzIGEgZnJhY3Rpb24gb2YgdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlXG4gICAgICogcHJvcG9ydGlvbmFsIHRvIHRoZSByYXRpby5cbiAgICAgKi8gaWYgKHJlbWFpbmluZ0ZyZWVTcGFjZSA+IDApIGZsZXhJdGVtcy5mb3JFYWNoKChpdGVtKT0+e1xuICAgICAgICAgICAgaWYgKCFpdGVtLmZyb3plbikge1xuICAgICAgICAgICAgICAgIGxldCByYXRpbyA9IGl0ZW0uZmxleCAvIGZsZXhGYWN0b3JzO1xuICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0TWFpblNpemUgPSBpdGVtLmJhc2VTaXplICsgcmF0aW8gKiByZW1haW5pbmdGcmVlU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyA5LjcuNC5kXG4gICAgICAgIC8qKlxuICAgICAqIEZpeCBtaW4vbWF4IHZpb2xhdGlvbnMuIENsYW1wIGVhY2ggbm9uLWZyb3plbiBpdGVt4oCZc1xuICAgICAqIHRhcmdldCBtYWluIHNpemUgYnkgaXRzIHVzZWQgbWluIGFuZCBtYXggbWFpbiBzaXplc1xuICAgICAqIGFuZCBmbG9vciBpdHMgY29udGVudC1ib3ggc2l6ZSBhdCB6ZXJvLiBJZiB0aGUgaXRlbeKAmXNcbiAgICAgKiB0YXJnZXQgbWFpbiBzaXplIHdhcyBtYWRlIHNtYWxsZXIgYnkgdGhpcywgaXTigJlzIGEgbWF4XG4gICAgICogdmlvbGF0aW9uLiBJZiB0aGUgaXRlbeKAmXMgdGFyZ2V0IG1haW4gc2l6ZSB3YXMgbWFkZVxuICAgICAqIGxhcmdlciBieSB0aGlzLCBpdOKAmXMgYSBtaW4gdmlvbGF0aW9uLlxuICAgICAqLyBsZXQgdG90YWxWaW9sYXRpb24gPSAwO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGl0ZW0udmlvbGF0aW9uID0gMDtcbiAgICAgICAgICAgIGlmICghaXRlbS5mcm96ZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtaW46IG1pbiwgbWF4OiBtYXgsIHRhcmdldE1haW5TaXplOiB0YXJnZXRNYWluU2l6ZSB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpdGVtLnRhcmdldE1haW5TaXplID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbih0YXJnZXRNYWluU2l6ZSwgbWF4KSk7XG4gICAgICAgICAgICAgICAgaXRlbS52aW9sYXRpb24gPSBpdGVtLnRhcmdldE1haW5TaXplIC0gdGFyZ2V0TWFpblNpemU7XG4gICAgICAgICAgICAgICAgdG90YWxWaW9sYXRpb24gKz0gaXRlbS52aW9sYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyA5LjcuNC5lXG4gICAgICAgIC8qKlxuICAgICAqIEZyZWV6ZSBvdmVyLWZsZXhlZCBpdGVtcy4gVGhlIHRvdGFsIHZpb2xhdGlvbiBpcyB0aGVcbiAgICAgKiBzdW0gb2YgdGhlIGFkanVzdG1lbnRzIGZyb20gdGhlIHByZXZpb3VzIHN0ZXBcbiAgICAgKiDiiJEoY2xhbXBlZCBzaXplIC0gdW5jbGFtcGVkIHNpemUpLiBJZiB0aGUgdG90YWwgdmlvbGF0aW9uIGlzOlxuICAgICAqIFplcm9cbiAgICAgKiAtIEZyZWV6ZSBhbGwgaXRlbXMuXG4gICAgICpcbiAgICAgKiBQb3NpdGl2ZVxuICAgICAqIC0gRnJlZXplIGFsbCB0aGUgaXRlbXMgd2l0aCBtaW4gdmlvbGF0aW9ucy5cbiAgICAgKlxuICAgICAqIE5lZ2F0aXZlXG4gICAgICogLSBGcmVlemUgYWxsIHRoZSBpdGVtcyB3aXRoIG1heCB2aW9sYXRpb25zLlxuICAgICAqLyBoYXNOb25Gcm96ZW5JdGVtcyA9IGZhbHNlO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGlmICh0b3RhbFZpb2xhdGlvbiA9PT0gMCB8fCBNYXRoLnNpZ24odG90YWxWaW9sYXRpb24pID09PSBNYXRoLnNpZ24oaXRlbS52aW9sYXRpb24pKSBpdGVtLmZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICghaXRlbS5mcm96ZW4pIGhhc05vbkZyb3plbkl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAkNjgxOGIxYzRmYzY3MDI4ZCR2YXIkY2FzY2FkZVJvdW5kaW5nKGZsZXhJdGVtcyk7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCR2YXIkY2FzY2FkZVJvdW5kaW5nKGZsZXhJdGVtcykge1xuICAgIC8qXG4gIEdpdmVuIGFuIGFycmF5IG9mIGZsb2F0cyB0aGF0IHN1bSB0byBhbiBpbnRlZ2VyLCB0aGlzIHJvdW5kcyB0aGUgZmxvYXRzXG4gIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGludGVnZXJzIHdpdGggdGhlIHNhbWUgc3VtLlxuICAqLyBsZXQgZnBUb3RhbCA9IDA7XG4gICAgbGV0IGludFRvdGFsID0gMDtcbiAgICBsZXQgcm91bmRlZEFycmF5ID0gW107XG4gICAgZmxleEl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBsZXQgZmxvYXQgPSBpdGVtLnRhcmdldE1haW5TaXplO1xuICAgICAgICBsZXQgaW50ZWdlciA9IE1hdGgucm91bmQoZmxvYXQgKyBmcFRvdGFsKSAtIGludFRvdGFsO1xuICAgICAgICBmcFRvdGFsICs9IGZsb2F0O1xuICAgICAgICBpbnRUb3RhbCArPSBpbnRlZ2VyO1xuICAgICAgICByb3VuZGVkQXJyYXkucHVzaChpbnRlZ2VyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcm91bmRlZEFycmF5O1xufVxuXG5cbmNsYXNzICRhOWU3YWU1NDRhNGU0MWRkJGV4cG9ydCQ3ZmY3N2ExNjI5NzBiMzBlIHtcbiAgICAvKiogVGFrZXMgYW4gYXJyYXkgb2YgY29sdW1ucyBhbmQgc3BsaXRzIGl0IGludG8gMiBtYXBzIG9mIGNvbHVtbnMgd2l0aCBjb250cm9sbGVkIGFuZCBjb2x1bW5zIHdpdGggdW5jb250cm9sbGVkIHdpZHRocy4gKi8gc3BsaXRDb2x1bW5zSW50b0NvbnRyb2xsZWRBbmRVbmNvbnRyb2xsZWQoY29sdW1ucykge1xuICAgICAgICByZXR1cm4gY29sdW1ucy5yZWR1Y2UoKGFjYywgY29sKT0+e1xuICAgICAgICAgICAgaWYgKGNvbC5wcm9wcy53aWR0aCAhPSBudWxsKSBhY2NbMF0uc2V0KGNvbC5rZXksIGNvbCk7XG4gICAgICAgICAgICBlbHNlIGFjY1sxXS5zZXQoY29sLmtleSwgY29sKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIG5ldyBNYXAoKSxcbiAgICAgICAgICAgIG5ldyBNYXAoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqIFRha2VzIHVuY29udHJvbGxlZCBhbmQgY29udHJvbGxlZCB3aWR0aHMgYW5kIGpvaW5zIHRoZW0gaW50byBhIHNpbmdsZSBNYXAuICovIHJlY29tYmluZUNvbHVtbnMoY29sdW1ucywgdW5jb250cm9sbGVkV2lkdGhzLCB1bmNvbnRyb2xsZWRDb2x1bW5zLCBjb250cm9sbGVkQ29sdW1ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcChjb2x1bW5zLm1hcCgoY29sKT0+e1xuICAgICAgICAgICAgaWYgKHVuY29udHJvbGxlZENvbHVtbnMuaGFzKGNvbC5rZXkpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGNvbC5rZXksXG4gICAgICAgICAgICAgICAgdW5jb250cm9sbGVkV2lkdGhzLmdldChjb2wua2V5KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBjb2wua2V5LFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZWRDb2x1bW5zLmdldChjb2wua2V5KS5wcm9wcy53aWR0aFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKiogVXNlZCB0byBtYWtlIGFuIGluaXRpYWwgTWFwIG9mIHRoZSB1bmNvbnRyb2xsZWQgd2lkdGhzIGJhc2VkIG9uIGRlZmF1bHQgd2lkdGhzLiAqLyBnZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzKHVuY29udHJvbGxlZENvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoQXJyYXkuZnJvbSh1bmNvbnRyb2xsZWRDb2x1bW5zKS5tYXAoKFtrZXksIGNvbF0pPT57XG4gICAgICAgICAgICB2YXIgX3RoaXNfZ2V0RGVmYXVsdFdpZHRoLCBfdGhpcztcbiAgICAgICAgICAgIHZhciBfY29sX3Byb3BzX2RlZmF1bHRXaWR0aCwgX3JlZjtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIChfcmVmID0gKF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoID0gY29sLnByb3BzLmRlZmF1bHRXaWR0aCkgIT09IG51bGwgJiYgX2NvbF9wcm9wc19kZWZhdWx0V2lkdGggIT09IHZvaWQgMCA/IF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoIDogKF90aGlzX2dldERlZmF1bHRXaWR0aCA9IChfdGhpcyA9IHRoaXMpLmdldERlZmF1bHRXaWR0aCkgPT09IG51bGwgfHwgX3RoaXNfZ2V0RGVmYXVsdFdpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19nZXREZWZhdWx0V2lkdGguY2FsbChfdGhpcywgY29sKSkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IFwiMWZyXCJcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0Q29sdW1uV2lkdGgoa2V5KSB7XG4gICAgICAgIHZhciBfdGhpc19jb2x1bW5XaWR0aHNfZ2V0O1xuICAgICAgICByZXR1cm4gKF90aGlzX2NvbHVtbldpZHRoc19nZXQgPSB0aGlzLmNvbHVtbldpZHRocy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3RoaXNfY29sdW1uV2lkdGhzX2dldCAhPT0gdm9pZCAwID8gX3RoaXNfY29sdW1uV2lkdGhzX2dldCA6IDA7XG4gICAgfVxuICAgIGdldENvbHVtbk1pbldpZHRoKGtleSkge1xuICAgICAgICB2YXIgX3RoaXNfY29sdW1uTWluV2lkdGhzX2dldDtcbiAgICAgICAgcmV0dXJuIChfdGhpc19jb2x1bW5NaW5XaWR0aHNfZ2V0ID0gdGhpcy5jb2x1bW5NaW5XaWR0aHMuZ2V0KGtleSkpICE9PSBudWxsICYmIF90aGlzX2NvbHVtbk1pbldpZHRoc19nZXQgIT09IHZvaWQgMCA/IF90aGlzX2NvbHVtbk1pbldpZHRoc19nZXQgOiAwO1xuICAgIH1cbiAgICBnZXRDb2x1bW5NYXhXaWR0aChrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbHVtbk1heFdpZHRoc19nZXQ7XG4gICAgICAgIHJldHVybiAoX3RoaXNfY29sdW1uTWF4V2lkdGhzX2dldCA9IHRoaXMuY29sdW1uTWF4V2lkdGhzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfdGhpc19jb2x1bW5NYXhXaWR0aHNfZ2V0ICE9PSB2b2lkIDAgPyBfdGhpc19jb2x1bW5NYXhXaWR0aHNfZ2V0IDogMDtcbiAgICB9XG4gICAgcmVzaXplQ29sdW1uV2lkdGgodGFibGVXaWR0aCwgY29sbGVjdGlvbiwgY29udHJvbGxlZFdpZHRocywgdW5jb250cm9sbGVkV2lkdGhzLCBjb2wgPSBudWxsLCB3aWR0aCkge1xuICAgICAgICBsZXQgcHJldkNvbHVtbldpZHRocyA9IHRoaXMuY29sdW1uV2lkdGhzO1xuICAgICAgICAvLyByZXNpemluZyBhIGNvbHVtblxuICAgICAgICBsZXQgcmVzaXplSW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IHJlc2l6aW5nQ2hhbmdlZCA9IG5ldyBNYXAoW1xuICAgICAgICAgICAgLi4uY29udHJvbGxlZFdpZHRocyxcbiAgICAgICAgICAgIC4uLnVuY29udHJvbGxlZFdpZHRoc1xuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHBlcmNlbnRLZXlzID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgZnJLZXlzVG9UaGVSaWdodCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IG1pbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gZnJlZXplIGNvbHVtbnMgdG8gdGhlIGxlZnQgdG8gdGhlaXIgcHJldmlvdXMgcGl4ZWwgdmFsdWVcbiAgICAgICAgY29sbGVjdGlvbi5jb2x1bW5zLmZvckVhY2goKGNvbHVtbiwgaSk9PntcbiAgICAgICAgICAgIHZhciBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoLCBfY29sdW1uX3Byb3BzX3dpZHRoO1xuICAgICAgICAgICAgbGV0IGZyS2V5O1xuICAgICAgICAgICAgbGV0IGZyVmFsdWU7XG4gICAgICAgICAgICBtaW5XaWR0aHMuc2V0KGNvbHVtbi5rZXksIHRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSkpO1xuICAgICAgICAgICAgaWYgKGNvbCAhPT0gY29sdW1uLmtleSAmJiAhY29sdW1uLnByb3BzLndpZHRoICYmICEoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUpKHVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sdW1uLmtleSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5jb250cm9sbGVkIGRvbid0IGhhdmUgcHJvcHMud2lkdGggZm9yIHVzLCBzbyBpbnN0ZWFkIGdldCBmcm9tIG91ciBzdGF0ZVxuICAgICAgICAgICAgICAgIGZyS2V5ID0gY29sdW1uLmtleTtcbiAgICAgICAgICAgICAgICBmclZhbHVlID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KSh1bmNvbnRyb2xsZWRXaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sICE9PSBjb2x1bW4ua2V5ICYmICEoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUpKGNvbHVtbi5wcm9wcy53aWR0aCkgJiYgIXVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sdW1uLmtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb250cm9sbGVkV2lkdGhzIHdpbGwgYmUgdGhlIHNhbWUgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBmcktleSA9IGNvbHVtbi5rZXk7XG4gICAgICAgICAgICAgICAgZnJWYWx1ZSA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkOTA3OGJhZDRjMzkzNDYwNCkoY29sdW1uLnByb3BzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sICE9PSBjb2x1bW4ua2V5ICYmICgoX2NvbHVtbl9wcm9wc193aWR0aCA9IGNvbHVtbi5wcm9wcy53aWR0aCkgPT09IG51bGwgfHwgX2NvbHVtbl9wcm9wc193aWR0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGggPSBfY29sdW1uX3Byb3BzX3dpZHRoLmVuZHNXaXRoKSA9PT0gbnVsbCB8fCBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoLmNhbGwoX2NvbHVtbl9wcm9wc193aWR0aCwgXCIlXCIpKSkgcGVyY2VudEtleXMuc2V0KGNvbHVtbi5rZXksIGNvbHVtbi5wcm9wcy53aWR0aCk7XG4gICAgICAgICAgICAvLyBkb24ndCBmcmVlemUgY29sdW1ucyB0byB0aGUgcmlnaHQgb2YgdGhlIHJlc2l6aW5nIG9uZVxuICAgICAgICAgICAgaWYgKHJlc2l6ZUluZGV4IDwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChmcktleSkgZnJLZXlzVG9UaGVSaWdodC5zZXQoZnJLZXksIGZyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGFscmVhZHkga25vdyB0aGUgbmV3IHNpemUgb2YgdGhlIHJlc2l6aW5nIGNvbHVtblxuICAgICAgICAgICAgaWYgKGNvbHVtbi5rZXkgPT09IGNvbCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICByZXNpemluZ0NoYW5nZWQuc2V0KGNvbHVtbi5rZXksIE1hdGguZmxvb3Iod2lkdGgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmcmVlemUgY29sdW1uIHRvIHByZXZpb3VzIHZhbHVlXG4gICAgICAgICAgICByZXNpemluZ0NoYW5nZWQuc2V0KGNvbHVtbi5rZXksIHByZXZDb2x1bW5XaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHByZWRpY3QgcGl4ZWxzIHNpemVzIGZvciBhbGwgY29sdW1ucyBiYXNlZCBvbiByZXNpemVcbiAgICAgICAgbGV0IGNvbHVtbldpZHRocyA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MSkodGFibGVXaWR0aCwgY29sbGVjdGlvbi5jb2x1bW5zLm1hcCgoY29sKT0+KHtcbiAgICAgICAgICAgICAgICAuLi5jb2wucHJvcHMsXG4gICAgICAgICAgICAgICAga2V5OiBjb2wua2V5XG4gICAgICAgICAgICB9KSksIHJlc2l6aW5nQ2hhbmdlZCwgKGkpPT50aGlzLmdldERlZmF1bHRXaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSkpO1xuICAgICAgICAvLyBzZXQgYWxsIG5ldyBjb2x1bW4gd2lkdGhzIGZvciBvblJlc2l6ZSBldmVudFxuICAgICAgICAvLyBjb2x1bW5zIGdvaW5nIGluIHdpbGwgYmUgdGhlIHNhbWUgb3JkZXIgYXMgdGhlIGNvbHVtbnMgY29taW5nIG91dFxuICAgICAgICBsZXQgbmV3V2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBzZXQgYWxsIGNvbHVtbiB3aWR0aHMgYmFzZWQgb24gY2FsY3VsYXRlQ29sdW1uU2l6ZVxuICAgICAgICBjb2x1bW5XaWR0aHMuZm9yRWFjaCgod2lkdGgsIGluZGV4KT0+e1xuICAgICAgICAgICAgbGV0IGtleSA9IGNvbGxlY3Rpb24uY29sdW1uc1tpbmRleF0ua2V5O1xuICAgICAgICAgICAgbmV3V2lkdGhzLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGFkZCBGUidzIGJhY2sgYXMgdGhleSB3ZXJlIHRvIGNvbHVtbnMgdG8gdGhlIHJpZ2h0XG4gICAgICAgIEFycmF5LmZyb20oZnJLZXlzVG9UaGVSaWdodCkuZm9yRWFjaCgoW2tleV0pPT57XG4gICAgICAgICAgICBuZXdXaWR0aHMuc2V0KGtleSwgYCR7ZnJLZXlzVG9UaGVSaWdodC5nZXQoa2V5KX1mcmApO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcHV0IGJhY2sgaW4gcGVyY2VudHNcbiAgICAgICAgQXJyYXkuZnJvbShwZXJjZW50S2V5cykuZm9yRWFjaCgoW2tleSwgd2lkdGhdKT0+e1xuICAgICAgICAgICAgLy8gcmVzaXppbmcgbG9ja3MgYSBjb2x1bW4gdG8gYSBweCB3aWR0aFxuICAgICAgICAgICAgaWYgKGtleSA9PT0gY29sKSByZXR1cm47XG4gICAgICAgICAgICBuZXdXaWR0aHMuc2V0KGtleSwgd2lkdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1dpZHRocztcbiAgICB9XG4gICAgYnVpbGRDb2x1bW5XaWR0aHModGFibGVXaWR0aCwgY29sbGVjdGlvbiwgd2lkdGhzKSB7XG4gICAgICAgIHRoaXMuY29sdW1uV2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbHVtbk1pbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5NYXhXaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIGluaXRpYWwgbGF5b3V0IG9yIHRhYmxlL3dpbmRvdyByZXNpemluZ1xuICAgICAgICBsZXQgY29sdW1uV2lkdGhzID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxKSh0YWJsZVdpZHRoLCBjb2xsZWN0aW9uLmNvbHVtbnMubWFwKChjb2wpPT4oe1xuICAgICAgICAgICAgICAgIC4uLmNvbC5wcm9wcyxcbiAgICAgICAgICAgICAgICBrZXk6IGNvbC5rZXlcbiAgICAgICAgICAgIH0pKSwgd2lkdGhzLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdFdpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSksIChpKT0+dGhpcy5nZXREZWZhdWx0TWluV2lkdGgoY29sbGVjdGlvbi5jb2x1bW5zW2ldKSk7XG4gICAgICAgIC8vIGNvbHVtbnMgZ29pbmcgaW4gd2lsbCBiZSB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY29sdW1ucyBjb21pbmcgb3V0XG4gICAgICAgIGNvbHVtbldpZHRocy5mb3JFYWNoKCh3aWR0aCwgaW5kZXgpPT57XG4gICAgICAgICAgICBsZXQga2V5ID0gY29sbGVjdGlvbi5jb2x1bW5zW2luZGV4XS5rZXk7XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gY29sbGVjdGlvbi5jb2x1bW5zW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uV2lkdGhzLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgICAgIHZhciBfY29sdW1uX3Byb3BzX21pbldpZHRoO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aHMuc2V0KGtleSwgKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxKSgoX2NvbHVtbl9wcm9wc19taW5XaWR0aCA9IGNvbHVtbi5wcm9wcy5taW5XaWR0aCkgIT09IG51bGwgJiYgX2NvbHVtbl9wcm9wc19taW5XaWR0aCAhPT0gdm9pZCAwID8gX2NvbHVtbl9wcm9wc19taW5XaWR0aCA6IHRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbHVtbiksIHRhYmxlV2lkdGgpKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uTWF4V2lkdGhzLnNldChrZXksICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMCkoY29sdW1uLnByb3BzLm1heFdpZHRoLCB0YWJsZVdpZHRoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5XaWR0aHM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgICAgICB0aGlzLmNvbHVtbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29sdW1uTWF4V2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgX29wdGlvbnNfZ2V0RGVmYXVsdFdpZHRoO1xuICAgICAgICB0aGlzLmdldERlZmF1bHRXaWR0aCA9IChfb3B0aW9uc19nZXREZWZhdWx0V2lkdGggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0RGVmYXVsdFdpZHRoKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19nZXREZWZhdWx0V2lkdGggIT09IHZvaWQgMCA/IF9vcHRpb25zX2dldERlZmF1bHRXaWR0aCA6ICgpPT5cIjFmclwiO1xuICAgICAgICB2YXIgX29wdGlvbnNfZ2V0RGVmYXVsdE1pbldpZHRoO1xuICAgICAgICB0aGlzLmdldERlZmF1bHRNaW5XaWR0aCA9IChfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0RGVmYXVsdE1pbldpZHRoKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGggIT09IHZvaWQgMCA/IF9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aCA6ICgpPT43NTtcbiAgICB9XG59XG5cblxuXG5mdW5jdGlvbiAkMjkyYmM0ZTA5Y2QwZWI2MiRleHBvcnQkY2I4OTVkY2Y4NWRiMTMxOShwcm9wcywgc3RhdGUpIHtcbiAgICBsZXQgeyBnZXREZWZhdWx0V2lkdGg6IGdldERlZmF1bHRXaWR0aCwgZ2V0RGVmYXVsdE1pbldpZHRoOiBnZXREZWZhdWx0TWluV2lkdGgsIHRhYmxlV2lkdGg6IHRhYmxlV2lkdGggPSAwIH0gPSBwcm9wcztcbiAgICBsZXQgW3Jlc2l6aW5nQ29sdW1uLCBzZXRSZXNpemluZ0NvbHVtbl0gPSAoMCwgJDFCZmpXJHVzZVN0YXRlKShudWxsKTtcbiAgICBsZXQgY29sdW1uTGF5b3V0ID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSkoe1xuICAgICAgICAgICAgZ2V0RGVmYXVsdFdpZHRoOiBnZXREZWZhdWx0V2lkdGgsXG4gICAgICAgICAgICBnZXREZWZhdWx0TWluV2lkdGg6IGdldERlZmF1bHRNaW5XaWR0aFxuICAgICAgICB9KSwgW1xuICAgICAgICBnZXREZWZhdWx0V2lkdGgsXG4gICAgICAgIGdldERlZmF1bHRNaW5XaWR0aFxuICAgIF0pO1xuICAgIGxldCBbY29udHJvbGxlZENvbHVtbnMsIHVuY29udHJvbGxlZENvbHVtbnNdID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+Y29sdW1uTGF5b3V0LnNwbGl0Q29sdW1uc0ludG9Db250cm9sbGVkQW5kVW5jb250cm9sbGVkKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyksIFtcbiAgICAgICAgc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLFxuICAgICAgICBjb2x1bW5MYXlvdXRcbiAgICBdKTtcbiAgICAvLyB1bmNvbnRyb2xsZWQgY29sdW1uIHdpZHRoc1xuICAgIGxldCBbdW5jb250cm9sbGVkV2lkdGhzLCBzZXRVbmNvbnRyb2xsZWRXaWR0aHNdID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkoKCk9PmNvbHVtbkxheW91dC5nZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzKHVuY29udHJvbGxlZENvbHVtbnMpKTtcbiAgICAvLyBVcGRhdGUgdW5jb250cm9sbGVkIHdpZHRocyBpZiB0aGUgY29sdW1ucyBjaGFuZ2VkLlxuICAgIGxldCBbbGFzdENvbHVtbnMsIHNldExhc3RDb2x1bW5zXSA9ICgwLCAkMUJmalckdXNlU3RhdGUpKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyk7XG4gICAgaWYgKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyAhPT0gbGFzdENvbHVtbnMpIHtcbiAgICAgICAgaWYgKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucy5sZW5ndGggIT09IGxhc3RDb2x1bW5zLmxlbmd0aCB8fCBzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMuc29tZSgoYywgaSk9PmMua2V5ICE9PSBsYXN0Q29sdW1uc1tpXS5rZXkpKSB7XG4gICAgICAgICAgICBsZXQgbmV3VW5jb250cm9sbGVkV2lkdGhzID0gY29sdW1uTGF5b3V0LmdldEluaXRpYWxVbmNvbnRyb2xsZWRXaWR0aHModW5jb250cm9sbGVkQ29sdW1ucyk7XG4gICAgICAgICAgICBzZXRVbmNvbnRyb2xsZWRXaWR0aHMobmV3VW5jb250cm9sbGVkV2lkdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRMYXN0Q29sdW1ucyhzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMpO1xuICAgIH1cbiAgICAvLyBjb21iaW5lIGNvbHVtbnMgYmFjayBpbnRvIG9uZSBtYXAgdGhhdCBtYWludGFpbnMgc2FtZSBvcmRlciBhcyB0aGUgY29sdW1uc1xuICAgIGxldCBjb2xXaWR0aHMgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5jb2x1bW5MYXlvdXQucmVjb21iaW5lQ29sdW1ucyhzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMsIHVuY29udHJvbGxlZFdpZHRocywgdW5jb250cm9sbGVkQ29sdW1ucywgY29udHJvbGxlZENvbHVtbnMpLCBbXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyxcbiAgICAgICAgdW5jb250cm9sbGVkV2lkdGhzLFxuICAgICAgICB1bmNvbnRyb2xsZWRDb2x1bW5zLFxuICAgICAgICBjb250cm9sbGVkQ29sdW1ucyxcbiAgICAgICAgY29sdW1uTGF5b3V0XG4gICAgXSk7XG4gICAgbGV0IHN0YXJ0UmVzaXplID0gKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKGtleSk9PntcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW4oa2V5KTtcbiAgICB9LCBbXG4gICAgICAgIHNldFJlc2l6aW5nQ29sdW1uXG4gICAgXSk7XG4gICAgbGV0IHVwZGF0ZVJlc2l6ZWRDb2x1bW5zID0gKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKGtleSwgd2lkdGgpPT57XG4gICAgICAgIGxldCBuZXdDb250cm9sbGVkID0gbmV3IE1hcChBcnJheS5mcm9tKGNvbnRyb2xsZWRDb2x1bW5zKS5tYXAoKFtrZXksIGVudHJ5XSk9PltcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgZW50cnkucHJvcHMud2lkdGhcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgbGV0IG5ld1NpemVzID0gY29sdW1uTGF5b3V0LnJlc2l6ZUNvbHVtbldpZHRoKHRhYmxlV2lkdGgsIHN0YXRlLmNvbGxlY3Rpb24sIG5ld0NvbnRyb2xsZWQsIHVuY29udHJvbGxlZFdpZHRocywga2V5LCB3aWR0aCk7XG4gICAgICAgIGxldCBtYXAgPSBuZXcgTWFwKEFycmF5LmZyb20odW5jb250cm9sbGVkQ29sdW1ucykubWFwKChba2V5XSk9PltcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbmV3U2l6ZXMuZ2V0KGtleSlcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgbWFwLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgc2V0VW5jb250cm9sbGVkV2lkdGhzKG1hcCk7XG4gICAgICAgIHJldHVybiBuZXdTaXplcztcbiAgICB9LCBbXG4gICAgICAgIGNvbnRyb2xsZWRDb2x1bW5zLFxuICAgICAgICB1bmNvbnRyb2xsZWRDb2x1bW5zLFxuICAgICAgICBzZXRVbmNvbnRyb2xsZWRXaWR0aHMsXG4gICAgICAgIHRhYmxlV2lkdGgsXG4gICAgICAgIGNvbHVtbkxheW91dCxcbiAgICAgICAgc3RhdGUuY29sbGVjdGlvbixcbiAgICAgICAgdW5jb250cm9sbGVkV2lkdGhzXG4gICAgXSk7XG4gICAgbGV0IGVuZFJlc2l6ZSA9ICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldFJlc2l6aW5nQ29sdW1uKG51bGwpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW5cbiAgICBdKTtcbiAgICAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5jb2x1bW5MYXlvdXQuYnVpbGRDb2x1bW5XaWR0aHModGFibGVXaWR0aCwgc3RhdGUuY29sbGVjdGlvbiwgY29sV2lkdGhzKSwgW1xuICAgICAgICB0YWJsZVdpZHRoLFxuICAgICAgICBzdGF0ZS5jb2xsZWN0aW9uLFxuICAgICAgICBjb2xXaWR0aHMsXG4gICAgICAgIGNvbHVtbkxheW91dFxuICAgIF0pO1xuICAgIHJldHVybiAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgcmVzaXppbmdDb2x1bW46IHJlc2l6aW5nQ29sdW1uLFxuICAgICAgICAgICAgdXBkYXRlUmVzaXplZENvbHVtbnM6IHVwZGF0ZVJlc2l6ZWRDb2x1bW5zLFxuICAgICAgICAgICAgc3RhcnRSZXNpemU6IHN0YXJ0UmVzaXplLFxuICAgICAgICAgICAgZW5kUmVzaXplOiBlbmRSZXNpemUsXG4gICAgICAgICAgICBnZXRDb2x1bW5XaWR0aDogKGtleSk9PmNvbHVtbkxheW91dC5nZXRDb2x1bW5XaWR0aChrZXkpLFxuICAgICAgICAgICAgZ2V0Q29sdW1uTWluV2lkdGg6IChrZXkpPT5jb2x1bW5MYXlvdXQuZ2V0Q29sdW1uTWluV2lkdGgoa2V5KSxcbiAgICAgICAgICAgIGdldENvbHVtbk1heFdpZHRoOiAoa2V5KT0+Y29sdW1uTGF5b3V0LmdldENvbHVtbk1heFdpZHRoKGtleSksXG4gICAgICAgICAgICB0YWJsZVN0YXRlOiBzdGF0ZVxuICAgICAgICB9KSwgW1xuICAgICAgICBjb2x1bW5MYXlvdXQsXG4gICAgICAgIHJlc2l6aW5nQ29sdW1uLFxuICAgICAgICB1cGRhdGVSZXNpemVkQ29sdW1ucyxcbiAgICAgICAgc3RhcnRSZXNpemUsXG4gICAgICAgIGVuZFJlc2l6ZSxcbiAgICAgICAgc3RhdGVcbiAgICBdKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY29uc3QgJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWSA9IFwicm93LWhlYWRlci1jb2x1bW4tXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmxldCAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcgPSBcInJvdy1oZWFkZXItY29sdW1uLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG53aGlsZSgkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZID09PSAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcpJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHID0gXCJyb3ctaGVhZGVyLWNvbHVtbi1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuZnVuY3Rpb24gJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDdjMTI3ZGI4NTBkNGU4MWUoa2V5TWFwLCBjb2x1bW5Ob2Rlcykge1xuICAgIGlmIChjb2x1bW5Ob2Rlcy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgIGxldCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGNvbHVtbiBvZiBjb2x1bW5Ob2Rlcyl7XG4gICAgICAgIGxldCBwYXJlbnRLZXkgPSBjb2x1bW4ucGFyZW50S2V5O1xuICAgICAgICBsZXQgY29sID0gW1xuICAgICAgICAgICAgY29sdW1uXG4gICAgICAgIF07XG4gICAgICAgIHdoaWxlKHBhcmVudEtleSl7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0ga2V5TWFwLmdldChwYXJlbnRLZXkpO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpIGJyZWFrO1xuICAgICAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBzZWVuIHRoaXMgcGFyZW50LCB0aGFuIGl0IGlzIHNoYXJlZFxuICAgICAgICAgICAgLy8gd2l0aCBhIHByZXZpb3VzIGNvbHVtbi4gSWYgdGhlIGN1cnJlbnQgY29sdW1uIGlzIHRhbGxlclxuICAgICAgICAgICAgLy8gdGhhbiB0aGUgcHJldmlvdXMgY29sdW1uLCB0aGFuIHdlIG5lZWQgdG8gc2hpZnQgdGhlIHBhcmVudFxuICAgICAgICAgICAgLy8gaW4gdGhlIHByZXZpb3VzIGNvbHVtbiBzbyBpdCdzIGxldmVsIHdpdGggdGhlIGN1cnJlbnQgY29sdW1uLlxuICAgICAgICAgICAgaWYgKHNlZW4uaGFzKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY29sc3BhbisrO1xuICAgICAgICAgICAgICAgIGxldCB7IGNvbHVtbjogY29sdW1uLCBpbmRleDogaW5kZXggfSA9IHNlZW4uZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gY29sLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gaW5kZXg7IGkgPCBjb2wubGVuZ3RoOyBpKyspY29sdW1uLnNwbGljZShpLCAwLCBudWxsKTtcbiAgICAgICAgICAgICAgICAvLyBBZGp1c3Qgc2hpZnRlZCBpbmRpY2VzXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gY29sLmxlbmd0aDsgaSA8IGNvbHVtbi5sZW5ndGg7IGkrKykvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbltpXSAmJiBzZWVuLmhhcyhjb2x1bW5baV0pKSBzZWVuLmdldChjb2x1bW5baV0pLmluZGV4ID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNvbHNwYW4gPSAxO1xuICAgICAgICAgICAgICAgIGNvbC5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgc2Vlbi5zZXQocGFyZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogY29sLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudEtleSA9IHBhcmVudC5wYXJlbnRLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29sdW1ucy5wdXNoKGNvbCk7XG4gICAgICAgIGNvbHVtbi5pbmRleCA9IGNvbHVtbnMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgbGV0IG1heExlbmd0aCA9IE1hdGgubWF4KC4uLmNvbHVtbnMubWFwKChjKT0+Yy5sZW5ndGgpKTtcbiAgICBsZXQgaGVhZGVyUm93cyA9IEFycmF5KG1heExlbmd0aCkuZmlsbCgwKS5tYXAoKCk9PltdKTtcbiAgICAvLyBDb252ZXJ0IGNvbHVtbnMgaW50byByb3dzLlxuICAgIGxldCBjb2xJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbHVtbnMpe1xuICAgICAgICBsZXQgaSA9IG1heExlbmd0aCAtIDE7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgY29sdW1uKXtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsbCB0aGUgc3BhY2UgdXAgdW50aWwgdGhlIGN1cnJlbnQgY29sdW1uIHdpdGggYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGxldCByb3cgPSBoZWFkZXJSb3dzW2ldO1xuICAgICAgICAgICAgICAgIGxldCByb3dMZW5ndGggPSByb3cucmVkdWNlKChwLCBjKT0+cCArIGMuY29sc3BhbiwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0xlbmd0aCA8IGNvbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJwbGFjZWhvbGRlci1cIiArIGl0ZW0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sc3BhbjogY29sSW5kZXggLSByb3dMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93W3Jvdy5sZW5ndGggLSAxXS5uZXh0S2V5ID0gcGxhY2Vob2xkZXIua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIucHJldktleSA9IHJvd1tyb3cubGVuZ3RoIC0gMV0ua2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tyb3cubGVuZ3RoIC0gMV0ubmV4dEtleSA9IGl0ZW0ua2V5O1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnByZXZLZXkgPSByb3dbcm93Lmxlbmd0aCAtIDFdLmtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS5sZXZlbCA9IGk7XG4gICAgICAgICAgICAgICAgaXRlbS5jb2xJbmRleCA9IGNvbEluZGV4O1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbEluZGV4Kys7XG4gICAgfVxuICAgIC8vIEFkZCBwbGFjZWhvbGRlcnMgYXQgdGhlIGVuZCBvZiBlYWNoIHJvdyB0aGF0IGlzIHNob3J0ZXIgdGhhbiB0aGUgbWF4aW11bVxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCByb3cgb2YgaGVhZGVyUm93cyl7XG4gICAgICAgIGxldCByb3dMZW5ndGggPSByb3cucmVkdWNlKChwLCBjKT0+cCArIGMuY29sc3BhbiwgMCk7XG4gICAgICAgIGlmIChyb3dMZW5ndGggPCBjb2x1bW5Ob2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICAgICAga2V5OiBcInBsYWNlaG9sZGVyLVwiICsgcm93W3Jvdy5sZW5ndGggLSAxXS5rZXksXG4gICAgICAgICAgICAgICAgY29sc3BhbjogY29sdW1uTm9kZXMubGVuZ3RoIC0gcm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluZGV4OiByb3dMZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGksXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXZLZXk6IHJvd1tyb3cubGVuZ3RoIC0gMV0ua2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcm93LnB1c2gocGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlclJvd3MubWFwKChjaGlsZE5vZGVzLCBpbmRleCk9PntcbiAgICAgICAgbGV0IHJvdyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaGVhZGVycm93XCIsXG4gICAgICAgICAgICBrZXk6IFwiaGVhZGVycm93LVwiICsgaW5kZXgsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiB0cnVlLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlcyxcbiAgICAgICAgICAgIHRleHRWYWx1ZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcm93O1xuICAgIH0pO1xufVxuY2xhc3MgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTAgZXh0ZW5kcyAoMCwgJDFCZmpXJEdyaWRDb2xsZWN0aW9uKSB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5ib2R5LmNoaWxkTm9kZXM7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmtleXMoKTtcbiAgICB9XG4gICAgZ2V0S2V5QmVmb3JlKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUucHJldktleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEtleUFmdGVyKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dEtleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEZpcnN0S2V5KCkge1xuICAgICAgICB2YXIgX2dldEZpcnN0SXRlbTtcbiAgICAgICAgcmV0dXJuIChfZ2V0Rmlyc3RJdGVtID0gKDAsICQxQmZqVyRnZXRGaXJzdEl0ZW0pKHRoaXMuYm9keS5jaGlsZE5vZGVzKSkgPT09IG51bGwgfHwgX2dldEZpcnN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldEZpcnN0SXRlbS5rZXk7XG4gICAgfVxuICAgIGdldExhc3RLZXkoKSB7XG4gICAgICAgIHZhciBfZ2V0TGFzdEl0ZW07XG4gICAgICAgIHJldHVybiAoX2dldExhc3RJdGVtID0gKDAsICQxQmZqVyRnZXRMYXN0SXRlbSkodGhpcy5ib2R5LmNoaWxkTm9kZXMpKSA9PT0gbnVsbCB8fCBfZ2V0TGFzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRMYXN0SXRlbS5rZXk7XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICB9XG4gICAgYXQoaWR4KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmdldEtleXMoKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleXNbaWR4XSk7XG4gICAgfVxuICAgIGdldFRleHRWYWx1ZShrZXkpIHtcbiAgICAgICAgbGV0IHJvdyA9IHRoaXMuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIXJvdykgcmV0dXJuIFwiXCI7XG4gICAgICAgIC8vIElmIHRoZSByb3cgaGFzIGEgdGV4dFZhbHVlLCB1c2UgdGhhdC5cbiAgICAgICAgaWYgKHJvdy50ZXh0VmFsdWUpIHJldHVybiByb3cudGV4dFZhbHVlO1xuICAgICAgICAvLyBPdGhlcndpc2UgY29tYmluZSB0aGUgdGV4dCBvZiBlYWNoIG9mIHRoZSByb3cgaGVhZGVyIGNvbHVtbnMuXG4gICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW5LZXlzID0gdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzO1xuICAgICAgICBpZiAocm93SGVhZGVyQ29sdW1uS2V5cykge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNlbGwgb2Ygcm93LmNoaWxkTm9kZXMpe1xuICAgICAgICAgICAgICAgIGxldCBjb2x1bW4gPSB0aGlzLmNvbHVtbnNbY2VsbC5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHJvd0hlYWRlckNvbHVtbktleXMuaGFzKGNvbHVtbi5rZXkpICYmIGNlbGwudGV4dFZhbHVlKSB0ZXh0LnB1c2goY2VsbC50ZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gcm93SGVhZGVyQ29sdW1uS2V5cy5zaXplKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXh0LmpvaW4oXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihub2RlcywgcHJldiwgb3B0cyl7XG4gICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW5LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgbGV0IGNvbHVtbnMgPSBbXTtcbiAgICAgICAgLy8gQWRkIGNlbGwgZm9yIHNlbGVjdGlvbiBjaGVja2JveGVzIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcykge1xuICAgICAgICAgICAgbGV0IHJvd0hlYWRlckNvbHVtbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIGtleTogJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAgaW5kZXg6IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd0RyYWdCdXR0b25zKSA/IDEgOiAwLFxuICAgICAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0aW9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb2x1bW5zLnVuc2hpZnQocm93SGVhZGVyQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgY2VsbCBmb3IgZHJhZyBidXR0b25zIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93RHJhZ0J1dHRvbnMpIHtcbiAgICAgICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICBrZXk6ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVlfRFJBRyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNEcmFnQnV0dG9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb2x1bW5zLnVuc2hpZnQocm93SGVhZGVyQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm93cyA9IFtdO1xuICAgICAgICBsZXQgY29sdW1uS2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIHN3aXRjaChub2RlLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29sdW1uXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbktleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaGFzQ2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucHJvcHMuaXNSb3dIZWFkZXIpIHJvd0hlYWRlckNvbHVtbktleXMuYWRkKG5vZGUua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiaXRlbVwiOlxuICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZG8gbm90IGdvIGludG8gY2hpbGROb2Rlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKXZpc2l0KGNoaWxkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl2aXNpdChub2RlKTtcbiAgICAgICAgbGV0IGhlYWRlclJvd3MgPSAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkN2MxMjdkYjg1MGQ0ZTgxZShjb2x1bW5LZXlNYXAsIGNvbHVtbnMpO1xuICAgICAgICBoZWFkZXJSb3dzLmZvckVhY2goKHJvdywgaSk9PnJvd3Muc3BsaWNlKGksIDAsIHJvdykpO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBjb2x1bW5Db3VudDogY29sdW1ucy5sZW5ndGgsXG4gICAgICAgICAgICBpdGVtczogcm93cyxcbiAgICAgICAgICAgIHZpc2l0Tm9kZTogKG5vZGUpPT57XG4gICAgICAgICAgICAgICAgbm9kZS5jb2x1bW4gPSBjb2x1bW5zW25vZGUuaW5kZXhdO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgICAgIHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cyA9IHJvd0hlYWRlckNvbHVtbktleXM7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMuaGVhZGVyUm93cyA9IGhlYWRlclJvd3M7XG4gICAgICAgIHRoaXMuX3NpemUgPSBbXG4gICAgICAgICAgICAuLi5ib2R5LmNoaWxkTm9kZXNcbiAgICAgICAgXS5sZW5ndGg7XG4gICAgICAgIC8vIERlZmF1bHQgcm93IGhlYWRlciBjb2x1bW4gdG8gdGhlIGZpcnN0IG9uZS5cbiAgICAgICAgaWYgKHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cy5zaXplID09PSAwKSB0aGlzLnJvd0hlYWRlckNvbHVtbktleXMuYWRkKHRoaXMuY29sdW1ucy5maW5kKChjb2x1bW4pPT57XG4gICAgICAgICAgICB2YXIgX2NvbHVtbl9wcm9wcywgX2NvbHVtbl9wcm9wczE7XG4gICAgICAgICAgICByZXR1cm4gISgoX2NvbHVtbl9wcm9wcyA9IGNvbHVtbi5wcm9wcykgPT09IG51bGwgfHwgX2NvbHVtbl9wcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbHVtbl9wcm9wcy5pc0RyYWdCdXR0b25DZWxsKSAmJiAhKChfY29sdW1uX3Byb3BzMSA9IGNvbHVtbi5wcm9wcykgPT09IG51bGwgfHwgX2NvbHVtbl9wcm9wczEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2x1bW5fcHJvcHMxLmlzU2VsZWN0aW9uQ2VsbCk7XG4gICAgICAgIH0pLmtleSk7XG4gICAgfVxufVxuXG5cblxuY29uc3QgJDRhMGRkMDM2ZDQ5MmNlZTQkdmFyJE9QUE9TSVRFX1NPUlRfRElSRUNUSU9OID0ge1xuICAgIGFzY2VuZGluZzogXCJkZXNjZW5kaW5nXCIsXG4gICAgZGVzY2VuZGluZzogXCJhc2NlbmRpbmdcIlxufTtcbmZ1bmN0aW9uICQ0YTBkZDAzNmQ0OTJjZWU0JGV4cG9ydCQ5MDdiY2M2YzQ4MzI1ZmQ2KHByb3BzKSB7XG4gICAgbGV0IFtpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkLCBzZXRLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZF0gPSAoMCwgJDFCZmpXJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IHsgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSA9IFwibm9uZVwiLCBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsIHNob3dEcmFnQnV0dG9uczogc2hvd0RyYWdCdXR0b25zIH0gPSBwcm9wcztcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgJiYgc2VsZWN0aW9uTW9kZSAhPT0gXCJub25lXCIsXG4gICAgICAgICAgICBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucyxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsXG4gICAgICAgICAgICBjb2x1bW5zOiBbXVxuICAgICAgICB9KSwgW1xuICAgICAgICBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsXG4gICAgICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgICAgIHNob3dEcmFnQnV0dG9uc1xuICAgIF0pO1xuICAgIGxldCBjb2xsZWN0aW9uID0gKDAsICQxQmZqVyR1c2VDb2xsZWN0aW9uKShwcm9wcywgKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKG5vZGVzKT0+bmV3ICgwLCAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkNTk2ZTFiMmUyY2Y5MzY5MCkobm9kZXMsIG51bGwsIGNvbnRleHQpLCBbXG4gICAgICAgIGNvbnRleHRcbiAgICBdKSwgY29udGV4dCk7XG4gICAgbGV0IHsgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIgfSA9ICgwLCAkMUJmalckdXNlR3JpZFN0YXRlKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEJlaGF2aW9yOiBwcm9wcy5kaXNhYmxlZEJlaGF2aW9yIHx8IFwic2VsZWN0aW9uXCJcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlcixcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHByb3BzLnNob3dTZWxlY3Rpb25DaGVja2JveGVzIHx8IGZhbHNlLFxuICAgICAgICBzb3J0RGVzY3JpcHRvcjogcHJvcHMuc29ydERlc2NyaXB0b3IsXG4gICAgICAgIGlzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQ6IGNvbGxlY3Rpb24uc2l6ZSA9PT0gMCB8fCBpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkLFxuICAgICAgICBzZXRLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZDogc2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQsXG4gICAgICAgIHNvcnQgKGNvbHVtbktleSwgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX3Byb3BzX3NvcnREZXNjcmlwdG9yO1xuICAgICAgICAgICAgcHJvcHMub25Tb3J0Q2hhbmdlKHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbktleSxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbiAhPT0gbnVsbCAmJiBkaXJlY3Rpb24gIT09IHZvaWQgMCA/IGRpcmVjdGlvbiA6ICgoX3Byb3BzX3NvcnREZXNjcmlwdG9yID0gcHJvcHMuc29ydERlc2NyaXB0b3IpID09PSBudWxsIHx8IF9wcm9wc19zb3J0RGVzY3JpcHRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Byb3BzX3NvcnREZXNjcmlwdG9yLmNvbHVtbikgPT09IGNvbHVtbktleSA/ICQ0YTBkZDAzNmQ0OTJjZWU0JHZhciRPUFBPU0lURV9TT1JUX0RJUkVDVElPTltwcm9wcy5zb3J0RGVzY3JpcHRvci5kaXJlY3Rpb25dIDogXCJhc2NlbmRpbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlcihwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJDMxMmFlM2I1NmE5NGE4NmUkdmFyJFRhYmxlSGVhZGVyLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBjb2x1bW5zOiBjb2x1bW5zIH0gPSBwcm9wcztcbiAgICAvLyBDbGVhciBjb2x1bW5zIHNvIHRoZXkgYXJlbid0IGRvdWJsZSBhZGRlZCBpbiBzdHJpY3QgbW9kZS5cbiAgICBjb250ZXh0LmNvbHVtbnMgPSBbXTtcbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFjb2x1bW5zKSB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wcy5jaGlsZHJlbiB3YXMgYSBmdW5jdGlvbiBidXQgcHJvcHMuY29sdW1ucyBpcyBtaXNzaW5nXCIpO1xuICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29sdW1ucyl5aWVsZCB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgdmFsdWU6IGNvbHVtbixcbiAgICAgICAgICAgIHJlbmRlcmVyOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjb2x1bW5zID0gW107XG4gICAgICAgICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjb2x1bW4pPT57XG4gICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogY29sdW1uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkKiBjb2x1bW5zO1xuICAgIH1cbn07XG4vKipcbiAqIEEgVGFibGVIZWFkZXIgaXMgYSBjb250YWluZXIgZm9yIHRoZSBDb2x1bW4gZWxlbWVudHMgaW4gYSBUYWJsZS4gQ29sdW1ucyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkXG4gKiBhcyBjaGlsZHJlbiwgb3IgZ2VuZXJhdGVkIGR5bmFtaWNhbGx5IHVzaW5nIGEgZnVuY3Rpb24gYmFzZWQgb24gdGhlIGRhdGEgcGFzc2VkIHRvIHRoZSBgY29sdW1uc2AgcHJvcC5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQzMTJhZTNiNTZhOTRhODZlJGV4cG9ydCRmODUwODk1YjI4N2VmMjhlID0gJDMxMmFlM2I1NmE5NGE4NmUkdmFyJFRhYmxlSGVhZGVyO1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQ0YWU1MzE0YmY1MGRiMWEzJHZhciRUYWJsZUJvZHkocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQ0YWU1MzE0YmY1MGRiMWEzJHZhciRUYWJsZUJvZHkuZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIGl0ZW1zOiBpdGVtcyB9ID0gcHJvcHM7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcImJvZHlcIixcbiAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAqY2hpbGROb2RlcyAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zKSB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wcy5jaGlsZHJlbiB3YXMgYSBmdW5jdGlvbiBidXQgcHJvcHMuaXRlbXMgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlcjogY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoaXRlbSk9PntcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIGl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqIEEgVGFibGVCb2R5IGlzIGEgY29udGFpbmVyIGZvciB0aGUgUm93IGVsZW1lbnRzIG9mIGEgVGFibGUuIFJvd3MgY2FuIGJlIHN0YXRpY2FsbHkgZGVmaW5lZFxuICogYXMgY2hpbGRyZW4sIG9yIGdlbmVyYXRlZCBkeW5hbWljYWxseSB1c2luZyBhIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgYGl0ZW1zYCBwcm9wLlxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJDRhZTUzMTRiZjUwZGIxYTMkZXhwb3J0JDc2Y2NkMjEwYjkwMjk5MTcgPSAkNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5O1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW4ocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW4uZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQgeyB0aXRsZTogdGl0bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiwgY2hpbGRDb2x1bW5zOiBjaGlsZENvbHVtbnMgfSA9IHByb3BzO1xuICAgIGxldCByZW5kZXJlZCA9IHRpdGxlIHx8IGNoaWxkcmVuO1xuICAgIGxldCB0ZXh0VmFsdWUgPSBwcm9wcy50ZXh0VmFsdWUgfHwgKHR5cGVvZiByZW5kZXJlZCA9PT0gXCJzdHJpbmdcIiA/IHJlbmRlcmVkIDogXCJcIikgfHwgcHJvcHNbXCJhcmlhLWxhYmVsXCJdO1xuICAgIGxldCBmdWxsTm9kZXMgPSB5aWVsZCB7XG4gICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6ICEhY2hpbGRDb2x1bW5zIHx8IHRpdGxlICYmICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA+IDAsXG4gICAgICAgIHJlbmRlcmVkOiByZW5kZXJlZCxcbiAgICAgICAgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkQ29sdW1ucykgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRDb2x1bW5zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaGlsZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQ29sdW1ucyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCk9PntcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBjaGlsZENvbHVtbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZEludmFsaWRhdGUgKG5ld0NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLCBidXQgaXQgd29ya3MuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZW4gdGhlcmUncyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoaXMgbm9kZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAvLyBCdXQsIHdlIG5lZWQgdG8ga2VlcCB0aGUgbGlzdCBvZiBjb2x1bW5zIGluIHRoZSBuZXcgY29udGV4dCB1cCB0byBkYXRlLlxuICAgICAgICAgICAgdXBkYXRlQ29udGV4dChuZXdDb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHVwZGF0ZUNvbnRleHQgPSAoY29udGV4dCk9PntcbiAgICAgICAgLy8gcmVnaXN0ZXIgbGVhZiBjb2x1bW5zIG9uIHRoZSBjb250ZXh0IHNvIHRoYXQgPFJvdz4gY2FuIGFjY2VzcyB0aGVtXG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgZnVsbE5vZGVzKWlmICghbm9kZS5oYXNDaGlsZE5vZGVzKSBjb250ZXh0LmNvbHVtbnMucHVzaChub2RlKTtcbiAgICB9O1xuICAgIHVwZGF0ZUNvbnRleHQoY29udGV4dCk7XG59O1xuLyoqXG4gKiBBIENvbHVtbiByZXByZXNlbnRzIGEgZmllbGQgb2YgZWFjaCBpdGVtIHdpdGhpbiBhIFRhYmxlLiBDb2x1bW5zIG1heSBhbHNvIGNvbnRhaW4gbmVzdGVkXG4gKiBDb2x1bW4gZWxlbWVudHMgdG8gcmVwcmVzZW50IGNvbHVtbiBncm91cHMuIE5lc3RlZCBjb2x1bW5zIGNhbiBiZSBzdGF0aWNhbGx5IGRlZmluZWQgYXNcbiAqIGNoaWxkcmVuLCBvciBkeW5hbWljYWxseSBnZW5lcmF0ZWQgdXNpbmcgYSBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgYGNoaWxkQ29sdW1uc2AgcHJvcC5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQxY2QyNDQ1NTdjMmY5N2Q1JGV4cG9ydCQ4MTZiNWQ4MTEyOTVlNmJjID0gJDFjZDI0NDU1N2MyZjk3ZDUkdmFyJENvbHVtbjtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93KHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93LmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCB0ZXh0VmFsdWU6IHRleHRWYWx1ZSwgVU5TVEFCTEVfY2hpbGRJdGVtczogVU5TVEFCTEVfY2hpbGRJdGVtcyB9ID0gcHJvcHM7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyBjZWxscyBmaXJzdFxuICAgICAgICAgICAgaWYgKGNvbnRleHQuc2hvd0RyYWdCdXR0b25zKSB5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAga2V5OiBcImhlYWRlci1kcmFnXCIsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNEcmFnQnV0dG9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY29udGV4dC5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcyAmJiBjb250ZXh0LnNlbGVjdGlvbk1vZGUgIT09IFwibm9uZVwiKSB5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAga2V5OiBcImhlYWRlclwiLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0aW9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29udGV4dC5jb2x1bW5zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkcmVuKGNvbHVtbi5rZXkpLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGNvbHVtbi5rZXkgLy8gdGhpcyBpcyBjb21iaW5lZCB3aXRoIHRoZSByb3cga2V5IGJ5IENvbGxlY3Rpb25CdWlsZGVyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoVU5TVEFCTEVfY2hpbGRJdGVtcykgZm9yIChsZXQgY2hpbGQgb2YgVU5TVEFCTEVfY2hpbGRJdGVtcykvLyBOb3RlOiBpbiBvcmRlciB0byByZXVzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9mIFRhYmxlQm9keSBmb3Igb3VyIGNoaWxkIHJvd3MsIHdlIGp1c3QgbmVlZCB0byB5aWVsZCBhIHR5cGUgYW5kIGEgdmFsdWUgaGVyZS4gQ29sbGVjdGlvbkJ1aWxkZXIgd2lsbCB0aGVuIGxvb2sgdXBcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFyZW50IHJlbmRlcmVyIGFuZCB1c2UgdGhhdCB0byBidWlsZCB0aGUgZnVsbCBub2RlIG9mIHRoaXMgY2hpbGQgcm93LCB1c2luZyB0aGUgdmFsdWUgcHJvdmlkZWQgaGVyZSB0byBnZW5lcmF0ZSB0aGUgY2VsbHNcbiAgICAgICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2hpbGRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRSb3dzID0gW107XG4gICAgICAgICAgICAgICAgKDAsICQxQmZqVyRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKG5vZGUpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICQ3MGQ3MGViMTZlYTQ4NDI4JHZhciRSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxscy5sZW5ndGggPCBjb250ZXh0LmNvbHVtbnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJBbGwgb2YgYSBSb3cncyBjaGlsZCBDZWxscyBtdXN0IGJlIHBvc2l0aW9uZWQgYmVmb3JlIGFueSBjaGlsZCBSb3dzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkUm93cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGNlbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjZWxscy5sZW5ndGggIT09IGNvbnRleHQuY29sdW1ucy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihgQ2VsbCBjb3VudCBtdXN0IG1hdGNoIGNvbHVtbiBjb3VudC4gRm91bmQgJHtjZWxscy5sZW5ndGh9IGNlbGxzIGFuZCAke2NvbnRleHQuY29sdW1ucy5sZW5ndGh9IGNvbHVtbnMuYCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIGNlbGxzO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBjaGlsZFJvd3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZEludmFsaWRhdGUgKG5ld0NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgYWxsIHJvd3MgaWYgdGhlIGNvbHVtbnMgY2hhbmdlZC5cbiAgICAgICAgICAgIHJldHVybiBuZXdDb250ZXh0LmNvbHVtbnMubGVuZ3RoICE9PSBjb250ZXh0LmNvbHVtbnMubGVuZ3RoIHx8IG5ld0NvbnRleHQuY29sdW1ucy5zb21lKChjLCBpKT0+Yy5rZXkgIT09IGNvbnRleHQuY29sdW1uc1tpXS5rZXkpIHx8IG5ld0NvbnRleHQuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgIT09IGNvbnRleHQuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgfHwgbmV3Q29udGV4dC5zaG93RHJhZ0J1dHRvbnMgIT09IGNvbnRleHQuc2hvd0RyYWdCdXR0b25zIHx8IG5ld0NvbnRleHQuc2VsZWN0aW9uTW9kZSAhPT0gY29udGV4dC5zZWxlY3Rpb25Nb2RlO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqIEEgUm93IHJlcHJlc2VudHMgYSBzaW5nbGUgaXRlbSBpbiBhIFRhYmxlIGFuZCBjb250YWlucyBDZWxsIGVsZW1lbnRzIGZvciBlYWNoIGNvbHVtbi5cbiAqIENlbGxzIGNhbiBiZSBzdGF0aWNhbGx5IGRlZmluZWQgYXMgY2hpbGRyZW4sIG9yIGdlbmVyYXRlZCBkeW5hbWljYWxseSB1c2luZyBhIGZ1bmN0aW9uXG4gKiBiYXNlZCBvbiB0aGUgY29sdW1ucyBkZWZpbmVkIGluIHRoZSBUYWJsZUhlYWRlci5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQ3MGQ3MGViMTZlYTQ4NDI4JGV4cG9ydCRiNTliZGJlZjljZTcwZGUyID0gJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdztcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDk0MWQxZDlhNmEyODk4MmEkdmFyJENlbGwocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQ5NDFkMWQ5YTZhMjg5ODJhJHZhciRDZWxsLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICBsZXQgdGV4dFZhbHVlID0gcHJvcHMudGV4dFZhbHVlIHx8ICh0eXBlb2YgY2hpbGRyZW4gPT09IFwic3RyaW5nXCIgPyBjaGlsZHJlbiA6IFwiXCIpIHx8IHByb3BzW1wiYXJpYS1sYWJlbFwiXSB8fCBcIlwiO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuLFxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2VcbiAgICB9O1xufTtcbi8qKlxuICogQSBDZWxsIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mIGEgc2luZ2xlIENvbHVtbiB3aXRoaW4gYSBUYWJsZSBSb3cuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkOTQxZDFkOWE2YTI4OTgyYSRleHBvcnQkZjZmMGMzZmU0ZWMzMDZlYSA9ICQ5NDFkMWQ5YTZhMjg5ODJhJHZhciRDZWxsO1xuXG5cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5cblxuXG5mdW5jdGlvbiAkZWU2NWEwMDU3ZmQ5OTUzMSRleHBvcnQkMzRkZmE4YTE2MjIxODVhNChwcm9wcykge1xuICAgIGxldCB7IHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPSBcIm5vbmVcIiwgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzLCBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucywgVU5TVEFCTEVfZXhwYW5kZWRLZXlzOiBwcm9wRXhwYW5kZWRLZXlzLCBVTlNUQUJMRV9kZWZhdWx0RXhwYW5kZWRLZXlzOiBwcm9wRGVmYXVsdEV4cGFuZGVkS2V5cywgVU5TVEFCTEVfb25FeHBhbmRlZENoYW5nZTogVU5TVEFCTEVfb25FeHBhbmRlZENoYW5nZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICBpZiAoISgwLCAkMUJmalckdGFibGVOZXN0ZWRSb3dzKSgpKSB0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlIGZsYWcgZm9yIHRhYmxlIG5lc3RlZCByb3dzIG11c3QgYmUgZW5hYmxlZCB0byB1c2UgdXNlVHJlZUdyaWRTdGF0ZS5cIik7XG4gICAgbGV0IFtleHBhbmRlZEtleXMsIHNldEV4cGFuZGVkS2V5c10gPSAoMCwgJDFCZmpXJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcEV4cGFuZGVkS2V5cyA/ICRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQocHJvcEV4cGFuZGVkS2V5cykgOiB1bmRlZmluZWQsIHByb3BEZWZhdWx0RXhwYW5kZWRLZXlzID8gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGNvbnZlcnRFeHBhbmRlZChwcm9wRGVmYXVsdEV4cGFuZGVkS2V5cykgOiBuZXcgU2V0KCksIFVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2UpO1xuICAgIGxldCBjb250ZXh0ID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyAmJiBzZWxlY3Rpb25Nb2RlICE9PSBcIm5vbmVcIixcbiAgICAgICAgICAgIHNob3dEcmFnQnV0dG9uczogc2hvd0RyYWdCdXR0b25zLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGNvbHVtbnM6IFtdXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcbiAgICAgICAgc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgc2hvd0RyYWdCdXR0b25zXG4gICAgXSk7XG4gICAgbGV0IGJ1aWxkZXIgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5uZXcgKDAsICQxQmZqVyRDb2xsZWN0aW9uQnVpbGRlcikoKSwgW10pO1xuICAgIGxldCBub2RlcyA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PmJ1aWxkZXIuYnVpbGQoe1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH0sIGNvbnRleHQpLCBbXG4gICAgICAgIGJ1aWxkZXIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBjb250ZXh0XG4gICAgXSk7XG4gICAgbGV0IHRyZWVHcmlkQ29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PntcbiAgICAgICAgcmV0dXJuICRlZTY1YTAwNTdmZDk5NTMxJHZhciRnZW5lcmF0ZVRyZWVHcmlkQ29sbGVjdGlvbihub2Rlcywge1xuICAgICAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzLFxuICAgICAgICAgICAgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsXG4gICAgICAgICAgICBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5c1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIG5vZGVzLFxuICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcbiAgICAgICAgc2hvd0RyYWdCdXR0b25zLFxuICAgICAgICBleHBhbmRlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgb25Ub2dnbGUgPSAoa2V5KT0+e1xuICAgICAgICBzZXRFeHBhbmRlZEtleXMoJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJHRvZ2dsZUtleShleHBhbmRlZEtleXMsIGtleSwgdHJlZUdyaWRDb2xsZWN0aW9uKSk7XG4gICAgfTtcbiAgICBsZXQgY29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PntcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTApKHRyZWVHcmlkQ29sbGVjdGlvbi50YWJsZU5vZGVzLCBudWxsLCBjb250ZXh0KTtcbiAgICB9LCBbXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHRyZWVHcmlkQ29sbGVjdGlvbi50YWJsZU5vZGVzXG4gICAgXSk7XG4gICAgbGV0IHRhYmxlU3RhdGUgPSAoMCwgJDRhMGRkMDM2ZDQ5MmNlZTQkZXhwb3J0JDkwN2JjYzZjNDgzMjVmZDYpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb25cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi50YWJsZVN0YXRlLFxuICAgICAgICBrZXlNYXA6IHRyZWVHcmlkQ29sbGVjdGlvbi5rZXlNYXAsXG4gICAgICAgIHVzZXJDb2x1bW5Db3VudDogdHJlZUdyaWRDb2xsZWN0aW9uLnVzZXJDb2x1bW5Db3VudCxcbiAgICAgICAgZXhwYW5kZWRLZXlzOiBleHBhbmRlZEtleXMsXG4gICAgICAgIHRvZ2dsZUtleTogb25Ub2dnbGVcbiAgICB9O1xufVxuZnVuY3Rpb24gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJHRvZ2dsZUtleShjdXJyZW50RXhwYW5kZWRLZXlzLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICBsZXQgdXBkYXRlZEV4cGFuZGVkS2V5cztcbiAgICBpZiAoY3VycmVudEV4cGFuZGVkS2V5cyA9PT0gXCJhbGxcIikge1xuICAgICAgICB1cGRhdGVkRXhwYW5kZWRLZXlzID0gbmV3IFNldChjb2xsZWN0aW9uLmZsYXR0ZW5lZFJvd3MuZmlsdGVyKChyb3cpPT5yb3cucHJvcHMuVU5TVEFCTEVfY2hpbGRJdGVtcyB8fCByb3cucHJvcHMuY2hpbGRyZW4ubGVuZ3RoID4gY29sbGVjdGlvbi51c2VyQ29sdW1uQ291bnQpLm1hcCgocm93KT0+cm93LmtleSkpO1xuICAgICAgICB1cGRhdGVkRXhwYW5kZWRLZXlzLmRlbGV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRFeHBhbmRlZEtleXMgPSBuZXcgU2V0KGN1cnJlbnRFeHBhbmRlZEtleXMpO1xuICAgICAgICBpZiAodXBkYXRlZEV4cGFuZGVkS2V5cy5oYXMoa2V5KSkgdXBkYXRlZEV4cGFuZGVkS2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAgZWxzZSB1cGRhdGVkRXhwYW5kZWRLZXlzLmFkZChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZEV4cGFuZGVkS2V5cztcbn1cbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQoZXhwYW5kZWQpIHtcbiAgICBpZiAoIWV4cGFuZGVkKSByZXR1cm4gbmV3IFNldCgpO1xuICAgIHJldHVybiBleHBhbmRlZCA9PT0gXCJhbGxcIiA/IFwiYWxsXCIgOiBuZXcgU2V0KGV4cGFuZGVkKTtcbn1cbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJHZhciRnZW5lcmF0ZVRyZWVHcmlkQ29sbGVjdGlvbihub2Rlcywgb3B0cykge1xuICAgIGxldCB7IGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzID0gbmV3IFNldCgpIH0gPSBvcHRzO1xuICAgIGxldCBib2R5O1xuICAgIGxldCBmbGF0dGVuZWRSb3dzID0gW107XG4gICAgbGV0IGNvbHVtbkNvdW50ID0gMDtcbiAgICBsZXQgdXNlckNvbHVtbkNvdW50ID0gMDtcbiAgICBsZXQgb3JpZ2luYWxDb2x1bW5zID0gW107XG4gICAgbGV0IGtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dTZWxlY3Rpb25DaGVja2JveGVzKSBjb2x1bW5Db3VudCsrO1xuICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd0RyYWdCdXR0b25zKSBjb2x1bW5Db3VudCsrO1xuICAgIGxldCB0b3BMZXZlbFJvd3MgPSBbXTtcbiAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgIGJvZHkgPSBub2RlO1xuICAgICAgICAgICAgICAgIGtleU1hcC5zZXQoYm9keS5rZXksIGJvZHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbHVtblwiOlxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5oYXNDaGlsZE5vZGVzKSB1c2VyQ29sdW1uQ291bnQrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpdGVtXCI6XG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxSb3dzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcyl2aXNpdChjaGlsZCk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJjb2x1bW5cIikgb3JpZ2luYWxDb2x1bW5zLnB1c2gobm9kZSk7XG4gICAgICAgIHZpc2l0KG5vZGUpO1xuICAgIH1cbiAgICBjb2x1bW5Db3VudCArPSB1c2VyQ29sdW1uQ291bnQ7XG4gICAgLy8gVXBkYXRlIGVhY2ggZ3JpZCBub2RlIGluIHRoZSB0cmVlZ3JpZCB0YWJsZSB3aXRoIHZhbHVlcyBzcGVjaWZpYyB0byBhIHRyZWVncmlkIHN0cnVjdHVyZS4gQWxzbyBzdG9yZSBhIHNldCBvZiBmbGF0dGVuZWQgcm93IG5vZGVzIGZvciBUYWJsZUNvbGxlY3Rpb24gdG8gY29uc3VtZVxuICAgIGxldCBnbG9iYWxSb3dDb3VudCA9IDA7XG4gICAgbGV0IHZpc2l0Tm9kZSA9IChub2RlLCBpKT0+e1xuICAgICAgICAvLyBDbG9uZSByb3cgbm9kZSBhbmQgaXRzIGNoaWxkcmVuIHNvIG1vZGlmaWNhdGlvbnMgdG8gdGhlIG5vZGUgZm9yIHRyZWVncmlkIHNwZWNpZmljIHZhbHVlcyBhcmVuJ3QgYXBwbGllZCBvbiB0aGUgbm9kZXMgcHJvdmlkZWRcbiAgICAgICAgLy8gdG8gVGFibGVDb2xsZWN0aW9uLiBJbmRleCwgbGV2ZWwsIGFuZCBwYXJlbnQga2V5cyBhcmUgYWxsIGNoYW5nZWQgdG8gcmVmbGVjdCBhIGZsYXR0ZW5lZCByb3cgc3RydWN0dXJlIHJhdGhlciB0aGFuIHRoZSB0cmVlZ3JpZCBzdHJ1Y3R1cmVcbiAgICAgICAgLy8gdmFsdWVzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCB2aWEgQ29sbGVjdGlvbkJ1aWxkZXJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJpdGVtXCIpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpaWYgKGNoaWxkLnR5cGUgPT09IFwiY2VsbFwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGxDbG9uZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChjZWxsQ2xvbmUuaW5kZXggKyAxID09PSBjb2x1bW5Db3VudCkgY2VsbENsb25lLm5leHRLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNlbGxDbG9uZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNsb25lID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICBwYXJlbnRLZXk6IGJvZHkua2V5LFxuICAgICAgICAgICAgICAgIGxldmVsOiAxLFxuICAgICAgICAgICAgICAgIGluZGV4OiBnbG9iYWxSb3dDb3VudCsrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZmxhdHRlbmVkUm93cy5wdXNoKGNsb25lKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgLy8gQXNzaWduIGluZGV4T2ZUeXBlIHRvIGNlbGxzIGFuZCByb3dzIGZvciBhcmlhLXBvc2luc2V0XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IFwicGxhY2Vob2xkZXJcIiAmJiBub2RlLnR5cGUgIT09IFwiY29sdW1uXCIpIG5ld1Byb3BzW1wiaW5kZXhPZlR5cGVcIl0gPSBpO1xuICAgICAgICAvLyBVc2UgT2JqZWN0LmFzc2lnbiBpbnN0ZWFkIG9mIHNwcmVhZCB0byBwcmVzZXJ2ZSBvYmplY3QgcmVmZXJlbmNlIGZvciBrZXlNYXAuIEFsc28gZW5zdXJlcyByZXRyaWV2aW5nIG5vZGVzXG4gICAgICAgIC8vIHZpYSAuY2hpbGROb2RlcyByZXR1cm5zIHRoZSBzYW1lIG9iamVjdCBhcyB0aGUgb25lIGZvdW5kIHZpYSBrZXlNYXAgbG9vayB1cFxuICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUsIG5ld1Byb3BzKTtcbiAgICAgICAga2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgIGxldCBsYXN0Tm9kZTtcbiAgICAgICAgbGV0IHJvd0luZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKWlmICghKGNoaWxkLnR5cGUgPT09IFwiaXRlbVwiICYmIGV4cGFuZGVkS2V5cyAhPT0gXCJhbGxcIiAmJiAhZXhwYW5kZWRLZXlzLmhhcyhub2RlLmtleSkpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50S2V5ID09IG51bGwpIC8vIGlmIGNoaWxkIGlzIGEgY2VsbC9leHBhbmRlZCByb3cvY29sdW1uIGFuZCB0aGUgcGFyZW50IGtleSBpc24ndCBhbHJlYWR5IGVzdGFibGlzaGVkIGJ5IHRoZSBjb2xsZWN0aW9uLCBtYXRjaCBjaGlsZCBub2RlIHRvIHBhcmVudCByb3dcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudEtleSA9IG5vZGUua2V5O1xuICAgICAgICAgICAgaWYgKGxhc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgbGFzdE5vZGUubmV4dEtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcmV2S2V5ID0gbGFzdE5vZGUua2V5O1xuICAgICAgICAgICAgfSBlbHNlIGNoaWxkLnByZXZLZXkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiaXRlbVwiKSB2aXNpdE5vZGUoY2hpbGQsIHJvd0luZGV4KyspO1xuICAgICAgICAgICAgZWxzZSAvLyBXZSBlbmZvcmNlIHRoYXQgdGhlIGNlbGxzIGNvbWUgYmVmb3JlIHJvd3Mgc28gY2FuIGp1c3QgcmV1c2UgY2VsbCBpbmRleFxuICAgICAgICAgICAgdmlzaXROb2RlKGNoaWxkLCBjaGlsZC5pbmRleCk7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Tm9kZSkgbGFzdE5vZGUubmV4dEtleSA9IG51bGw7XG4gICAgfTtcbiAgICBsZXQgbGFzdDtcbiAgICB0b3BMZXZlbFJvd3MuZm9yRWFjaCgobm9kZSwgaSk9PntcbiAgICAgICAgdmlzaXROb2RlKG5vZGUsIGkpO1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0gbm9kZS5rZXk7XG4gICAgICAgICAgICBub2RlLnByZXZLZXkgPSBsYXN0LmtleTtcbiAgICAgICAgfSBlbHNlIG5vZGUucHJldktleSA9IG51bGw7XG4gICAgICAgIGxhc3QgPSBub2RlO1xuICAgIH0pO1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHRLZXkgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleU1hcDoga2V5TWFwLFxuICAgICAgICB1c2VyQ29sdW1uQ291bnQ6IHVzZXJDb2x1bW5Db3VudCxcbiAgICAgICAgZmxhdHRlbmVkUm93czogZmxhdHRlbmVkUm93cyxcbiAgICAgICAgdGFibGVOb2RlczogW1xuICAgICAgICAgICAgLi4ub3JpZ2luYWxDb2x1bW5zLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLmJvZHksXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogZmxhdHRlbmVkUm93c1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskMjkyYmM0ZTA5Y2QwZWI2MiRleHBvcnQkY2I4OTVkY2Y4NWRiMTMxOSBhcyB1c2VUYWJsZUNvbHVtblJlc2l6ZVN0YXRlLCAkNGEwZGQwMzZkNDkyY2VlNCRleHBvcnQkOTA3YmNjNmM0ODMyNWZkNiBhcyB1c2VUYWJsZVN0YXRlLCAkMzEyYWUzYjU2YTk0YTg2ZSRleHBvcnQkZjg1MDg5NWIyODdlZjI4ZSBhcyBUYWJsZUhlYWRlciwgJDRhZTUzMTRiZjUwZGIxYTMkZXhwb3J0JDc2Y2NkMjEwYjkwMjk5MTcgYXMgVGFibGVCb2R5LCAkMWNkMjQ0NTU3YzJmOTdkNSRleHBvcnQkODE2YjVkODExMjk1ZTZiYyBhcyBDb2x1bW4sICQ3MGQ3MGViMTZlYTQ4NDI4JGV4cG9ydCRiNTliZGJlZjljZTcwZGUyIGFzIFJvdywgJDk0MWQxZDlhNmEyODk4MmEkZXhwb3J0JGY2ZjBjM2ZlNGVjMzA2ZWEgYXMgQ2VsbCwgJDY1NTUxMDRmZjA4NWJlZjQkcmVfZXhwb3J0JFNlY3Rpb24gYXMgU2VjdGlvbiwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTAgYXMgVGFibGVDb2xsZWN0aW9uLCAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkN2MxMjdkYjg1MGQ0ZTgxZSBhcyBidWlsZEhlYWRlclJvd3MsICRhOWU3YWU1NDRhNGU0MWRkJGV4cG9ydCQ3ZmY3N2ExNjI5NzBiMzBlIGFzIFRhYmxlQ29sdW1uTGF5b3V0LCAkZWU2NWEwMDU3ZmQ5OTUzMSRleHBvcnQkMzRkZmE4YTE2MjIxODVhNCBhcyBVTlNUQUJMRV91c2VUcmVlR3JpZFN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJTZWN0aW9uIiwiJDY1NTUxMDRmZjA4NWJlZjQkcmVfZXhwb3J0JFNlY3Rpb24iLCJ1c2VDb2xsZWN0aW9uIiwiJDFCZmpXJHVzZUNvbGxlY3Rpb24iLCJnZXRGaXJzdEl0ZW0iLCIkMUJmalckZ2V0Rmlyc3RJdGVtIiwiZ2V0TGFzdEl0ZW0iLCIkMUJmalckZ2V0TGFzdEl0ZW0iLCJDb2xsZWN0aW9uQnVpbGRlciIsIiQxQmZqVyRDb2xsZWN0aW9uQnVpbGRlciIsIiQxQmZqVyRyZWFjdCIsInVzZVN0YXRlIiwiJDFCZmpXJHVzZVN0YXRlIiwidXNlTWVtbyIsIiQxQmZqVyR1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCIkMUJmalckdXNlQ2FsbGJhY2siLCJ1c2VHcmlkU3RhdGUiLCIkMUJmalckdXNlR3JpZFN0YXRlIiwiR3JpZENvbGxlY3Rpb24iLCIkMUJmalckR3JpZENvbGxlY3Rpb24iLCJ0YWJsZU5lc3RlZFJvd3MiLCIkMUJmalckdGFibGVOZXN0ZWRSb3dzIiwidXNlQ29udHJvbGxlZFN0YXRlIiwiJDFCZmpXJHVzZUNvbnRyb2xsZWRTdGF0ZSIsIiQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQxOTk0YTA3N2I5OGVlMGQ1Iiwid2lkdGgiLCJpc05hTiIsIlN0cmluZyIsIm1hdGNoIiwiJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDkwNzhiYWQ0YzM5MzQ2MDQiLCJjb25zb2xlIiwid2FybiIsInBhcnNlRmxvYXQiLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkN2JiYWQyNzg5NmY3YWU5ZiIsInRhYmxlV2lkdGgiLCJFcnJvciIsIiQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1OTE4NWM2MmE3NTQ0YWEwIiwibWF4V2lkdGgiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JGY1NTYwNTRjZTQzNTg3MDEiLCJtaW5XaWR0aCIsIiQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxIiwiYXZhaWxhYmxlV2lkdGgiLCJjb2x1bW5zIiwiY2hhbmdlZENvbHVtbnMiLCJnZXREZWZhdWx0V2lkdGgiLCJnZXREZWZhdWx0TWluV2lkdGgiLCJoYXNOb25Gcm96ZW5JdGVtcyIsImZsZXhJdGVtcyIsIm1hcCIsImNvbHVtbiIsImluZGV4IiwiX2NvbHVtbl93aWR0aCIsIl9yZWYiLCJfcmVmMSIsImdldCIsImtleSIsImRlZmF1bHRXaWR0aCIsImZyb3plbiIsImJhc2VTaXplIiwiZmxleCIsInRhcmdldE1haW5TaXplIiwiX2NvbHVtbl9taW5XaWR0aCIsIl9yZWYyIiwibWluIiwibWF4IiwiaHlwb3RoZXRpY2FsTWFpblNpemUiLCJNYXRoIiwidmlvbGF0aW9uIiwidXNlZFdpZHRoIiwiZmxleEZhY3RvcnMiLCJmb3JFYWNoIiwiaXRlbSIsInJlbWFpbmluZ0ZyZWVTcGFjZSIsInJhdGlvIiwidG90YWxWaW9sYXRpb24iLCJzaWduIiwiJDY4MThiMWM0ZmM2NzAyOGQkdmFyJGNhc2NhZGVSb3VuZGluZyIsImZwVG90YWwiLCJpbnRUb3RhbCIsInJvdW5kZWRBcnJheSIsImZsb2F0IiwiaW50ZWdlciIsInJvdW5kIiwicHVzaCIsIiRhOWU3YWU1NDRhNGU0MWRkJGV4cG9ydCQ3ZmY3N2ExNjI5NzBiMzBlIiwic3BsaXRDb2x1bW5zSW50b0NvbnRyb2xsZWRBbmRVbmNvbnRyb2xsZWQiLCJyZWR1Y2UiLCJhY2MiLCJjb2wiLCJwcm9wcyIsInNldCIsIk1hcCIsInJlY29tYmluZUNvbHVtbnMiLCJ1bmNvbnRyb2xsZWRXaWR0aHMiLCJ1bmNvbnRyb2xsZWRDb2x1bW5zIiwiY29udHJvbGxlZENvbHVtbnMiLCJoYXMiLCJnZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzIiwiQXJyYXkiLCJmcm9tIiwiX3RoaXNfZ2V0RGVmYXVsdFdpZHRoIiwiX3RoaXMiLCJfY29sX3Byb3BzX2RlZmF1bHRXaWR0aCIsImNhbGwiLCJnZXRDb2x1bW5XaWR0aCIsIl90aGlzX2NvbHVtbldpZHRoc19nZXQiLCJjb2x1bW5XaWR0aHMiLCJnZXRDb2x1bW5NaW5XaWR0aCIsIl90aGlzX2NvbHVtbk1pbldpZHRoc19nZXQiLCJjb2x1bW5NaW5XaWR0aHMiLCJnZXRDb2x1bW5NYXhXaWR0aCIsIl90aGlzX2NvbHVtbk1heFdpZHRoc19nZXQiLCJjb2x1bW5NYXhXaWR0aHMiLCJyZXNpemVDb2x1bW5XaWR0aCIsImNvbGxlY3Rpb24iLCJjb250cm9sbGVkV2lkdGhzIiwicHJldkNvbHVtbldpZHRocyIsInJlc2l6ZUluZGV4IiwiSW5maW5pdHkiLCJyZXNpemluZ0NoYW5nZWQiLCJwZXJjZW50S2V5cyIsImZyS2V5c1RvVGhlUmlnaHQiLCJtaW5XaWR0aHMiLCJpIiwiX2NvbHVtbl9wcm9wc193aWR0aF9lbmRzV2l0aCIsIl9jb2x1bW5fcHJvcHNfd2lkdGgiLCJmcktleSIsImZyVmFsdWUiLCJlbmRzV2l0aCIsImZsb29yIiwibmV3V2lkdGhzIiwiYnVpbGRDb2x1bW5XaWR0aHMiLCJ3aWR0aHMiLCJfY29sdW1uX3Byb3BzX21pbldpZHRoIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX29wdGlvbnNfZ2V0RGVmYXVsdFdpZHRoIiwiX29wdGlvbnNfZ2V0RGVmYXVsdE1pbldpZHRoIiwiJDI5MmJjNGUwOWNkMGViNjIkZXhwb3J0JGNiODk1ZGNmODVkYjEzMTkiLCJzdGF0ZSIsInJlc2l6aW5nQ29sdW1uIiwic2V0UmVzaXppbmdDb2x1bW4iLCJjb2x1bW5MYXlvdXQiLCJzZXRVbmNvbnRyb2xsZWRXaWR0aHMiLCJsYXN0Q29sdW1ucyIsInNldExhc3RDb2x1bW5zIiwibGVuZ3RoIiwic29tZSIsImMiLCJuZXdVbmNvbnRyb2xsZWRXaWR0aHMiLCJjb2xXaWR0aHMiLCJzdGFydFJlc2l6ZSIsInVwZGF0ZVJlc2l6ZWRDb2x1bW5zIiwibmV3Q29udHJvbGxlZCIsImVudHJ5IiwibmV3U2l6ZXMiLCJlbmRSZXNpemUiLCJ0YWJsZVN0YXRlIiwiJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWSIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCIkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUciLCIkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkN2MxMjdkYjg1MGQ0ZTgxZSIsImtleU1hcCIsImNvbHVtbk5vZGVzIiwic2VlbiIsInBhcmVudEtleSIsInBhcmVudCIsImNvbHNwYW4iLCJzcGxpY2UiLCJtYXhMZW5ndGgiLCJoZWFkZXJSb3dzIiwiZmlsbCIsImNvbEluZGV4Iiwicm93Iiwicm93TGVuZ3RoIiwicCIsInBsYWNlaG9sZGVyIiwidHlwZSIsInZhbHVlIiwicmVuZGVyZWQiLCJsZXZlbCIsImhhc0NoaWxkTm9kZXMiLCJjaGlsZE5vZGVzIiwidGV4dFZhbHVlIiwibmV4dEtleSIsInByZXZLZXkiLCIkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkNTk2ZTFiMmUyY2Y5MzY5MCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiYm9keSIsInNpemUiLCJfc2l6ZSIsImdldEtleXMiLCJrZXlzIiwiZ2V0S2V5QmVmb3JlIiwibm9kZSIsImdldEtleUFmdGVyIiwiZ2V0Rmlyc3RLZXkiLCJfZ2V0Rmlyc3RJdGVtIiwiZ2V0TGFzdEtleSIsIl9nZXRMYXN0SXRlbSIsImdldEl0ZW0iLCJhdCIsImlkeCIsImdldFRleHRWYWx1ZSIsInJvd0hlYWRlckNvbHVtbktleXMiLCJ0ZXh0IiwiY2VsbCIsImpvaW4iLCJub2RlcyIsInByZXYiLCJvcHRzIiwiU2V0Iiwic2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMiLCJyb3dIZWFkZXJDb2x1bW4iLCJzaG93RHJhZ0J1dHRvbnMiLCJpc1NlbGVjdGlvbkNlbGwiLCJ1bnNoaWZ0IiwiaXNEcmFnQnV0dG9uQ2VsbCIsInJvd3MiLCJjb2x1bW5LZXlNYXAiLCJ2aXNpdCIsImlzUm93SGVhZGVyIiwiYWRkIiwiY2hpbGQiLCJjb2x1bW5Db3VudCIsIml0ZW1zIiwidmlzaXROb2RlIiwiZmluZCIsIl9jb2x1bW5fcHJvcHMiLCJfY29sdW1uX3Byb3BzMSIsIiQ0YTBkZDAzNmQ0OTJjZWU0JHZhciRPUFBPU0lURV9TT1JUX0RJUkVDVElPTiIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCIkNGEwZGQwMzZkNDkyY2VlNCRleHBvcnQkOTA3YmNjNmM0ODMyNWZkNiIsImlzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQiLCJzZXRLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCIsInNlbGVjdGlvbk1vZGUiLCJjb250ZXh0IiwiY2hpbGRyZW4iLCJkaXNhYmxlZEtleXMiLCJzZWxlY3Rpb25NYW5hZ2VyIiwiZGlzYWJsZWRCZWhhdmlvciIsInNvcnREZXNjcmlwdG9yIiwic29ydCIsImNvbHVtbktleSIsImRpcmVjdGlvbiIsIl9wcm9wc19zb3J0RGVzY3JpcHRvciIsIm9uU29ydENoYW5nZSIsIiQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlciIsImdldENvbGxlY3Rpb25Ob2RlIiwicmVuZGVyZXIiLCJDaGlsZHJlbiIsImVsZW1lbnQiLCIkMzEyYWUzYjU2YTk0YTg2ZSRleHBvcnQkZjg1MDg5NWIyODdlZjI4ZSIsIiQ0YWU1MzE0YmY1MGRiMWEzJHZhciRUYWJsZUJvZHkiLCIkNGFlNTMxNGJmNTBkYjFhMyRleHBvcnQkNzZjY2QyMTBiOTAyOTkxNyIsIiQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW4iLCJ0aXRsZSIsImNoaWxkQ29sdW1ucyIsImZ1bGxOb2RlcyIsImNvdW50Iiwic2hvdWxkSW52YWxpZGF0ZSIsIm5ld0NvbnRleHQiLCJ1cGRhdGVDb250ZXh0IiwiJDFjZDI0NDU1N2MyZjk3ZDUkZXhwb3J0JDgxNmI1ZDgxMTI5NWU2YmMiLCIkNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93IiwiVU5TVEFCTEVfY2hpbGRJdGVtcyIsImNlbGxzIiwiY2hpbGRSb3dzIiwiJDcwZDcwZWIxNmVhNDg0MjgkZXhwb3J0JGI1OWJkYmVmOWNlNzBkZTIiLCIkOTQxZDFkOWE2YTI4OTgyYSR2YXIkQ2VsbCIsIiQ5NDFkMWQ5YTZhMjg5ODJhJGV4cG9ydCRmNmYwYzNmZTRlYzMwNmVhIiwiJGVlNjVhMDA1N2ZkOTk1MzEkZXhwb3J0JDM0ZGZhOGExNjIyMTg1YTQiLCJVTlNUQUJMRV9leHBhbmRlZEtleXMiLCJwcm9wRXhwYW5kZWRLZXlzIiwiVU5TVEFCTEVfZGVmYXVsdEV4cGFuZGVkS2V5cyIsInByb3BEZWZhdWx0RXhwYW5kZWRLZXlzIiwiVU5TVEFCTEVfb25FeHBhbmRlZENoYW5nZSIsImV4cGFuZGVkS2V5cyIsInNldEV4cGFuZGVkS2V5cyIsIiRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQiLCJ1bmRlZmluZWQiLCJidWlsZGVyIiwiYnVpbGQiLCJ0cmVlR3JpZENvbGxlY3Rpb24iLCIkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkZ2VuZXJhdGVUcmVlR3JpZENvbGxlY3Rpb24iLCJvblRvZ2dsZSIsIiRlZTY1YTAwNTdmZDk5NTMxJHZhciR0b2dnbGVLZXkiLCJ0YWJsZU5vZGVzIiwidXNlckNvbHVtbkNvdW50IiwidG9nZ2xlS2V5IiwiY3VycmVudEV4cGFuZGVkS2V5cyIsInVwZGF0ZWRFeHBhbmRlZEtleXMiLCJmbGF0dGVuZWRSb3dzIiwiZmlsdGVyIiwiZGVsZXRlIiwiZXhwYW5kZWQiLCJvcmlnaW5hbENvbHVtbnMiLCJ0b3BMZXZlbFJvd3MiLCJnbG9iYWxSb3dDb3VudCIsImNlbGxDbG9uZSIsImNsb25lIiwibmV3UHJvcHMiLCJPYmplY3QiLCJhc3NpZ24iLCJsYXN0Tm9kZSIsInJvd0luZGV4IiwibGFzdCIsInVzZVRhYmxlQ29sdW1uUmVzaXplU3RhdGUiLCJ1c2VUYWJsZVN0YXRlIiwiVGFibGVIZWFkZXIiLCJUYWJsZUJvZHkiLCJDb2x1bW4iLCJSb3ciLCJDZWxsIiwiVGFibGVDb2xsZWN0aW9uIiwiYnVpbGRIZWFkZXJSb3dzIiwiVGFibGVDb2x1bW5MYXlvdXQiLCJVTlNUQUJMRV91c2VUcmVlR3JpZFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/table/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tabs/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTabListState: () => (/* binding */ $76f919a04c5a7d14$export$4ba071daf4e486)\n/* harmony export */ });\n/* harmony import */ var _react_stately_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/list */ \"(ssr)/./node_modules/@react-stately/list/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $76f919a04c5a7d14$export$4ba071daf4e486(props) {\n    var _props_defaultSelectedKey;\n    let state = (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.useSingleSelectListState)({\n        ...props,\n        suppressTextValueWarning: true,\n        defaultSelectedKey: (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : $76f919a04c5a7d14$var$findDefaultSelectedKey(props.collection, props.disabledKeys ? new Set(props.disabledKeys) : new Set())\n    });\n    let { selectionManager: selectionManager, collection: collection, selectedKey: currentSelectedKey } = state;\n    let lastSelectedKey = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentSelectedKey);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Ensure a tab is always selected (in case no selected key was specified or if selected item was deleted from collection)\n        let selectedKey = currentSelectedKey;\n        if (selectionManager.isEmpty || !collection.getItem(selectedKey)) {\n            selectedKey = $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, state.disabledKeys);\n            if (selectedKey != null) selectionManager.setSelectedKeys([\n                selectedKey\n            ]);\n        }\n        // If the tablist doesn't have focus and the selected key changes or if there isn't a focused key yet, change focused key to the selected key if it exists.\n        if (selectedKey != null && selectionManager.focusedKey == null || !selectionManager.isFocused && selectedKey !== lastSelectedKey.current) selectionManager.setFocusedKey(selectedKey);\n        lastSelectedKey.current = selectedKey;\n    });\n    return {\n        ...state,\n        isDisabled: props.isDisabled || false\n    };\n}\nfunction $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, disabledKeys) {\n    let selectedKey = null;\n    if (collection) {\n        selectedKey = collection.getFirstKey();\n        // loop over tabs until we find one that isn't disabled and select that\n        while(disabledKeys.has(selectedKey) && selectedKey !== collection.getLastKey())selectedKey = collection.getKeyAfter(selectedKey);\n        // if this check is true, then every item is disabled, it makes more sense to default to the first key than the last\n        if (disabledKeys.has(selectedKey) && selectedKey === collection.getLastKey()) selectedKey = collection.getFirstKey();\n    }\n    return selectedKey;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFicy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdHO0FBQ25CO0FBRTdFOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBRUQsU0FBU00sd0NBQXdDQyxLQUFLO0lBQ2xELElBQUlDO0lBQ0osSUFBSUMsUUFBUSxDQUFDLEdBQUdSLHlFQUE4QixFQUFHO1FBQzdDLEdBQUdNLEtBQUs7UUFDUkcsMEJBQTBCO1FBQzFCQyxvQkFBb0IsQ0FBQ0gsNEJBQTRCRCxNQUFNSSxrQkFBa0IsTUFBTSxRQUFRSCw4QkFBOEIsS0FBSyxJQUFJQSw0QkFBNEJJLDZDQUE2Q0wsTUFBTU0sVUFBVSxFQUFFTixNQUFNTyxZQUFZLEdBQUcsSUFBSUMsSUFBSVIsTUFBTU8sWUFBWSxJQUFJLElBQUlDO0lBQ3BSO0lBQ0EsSUFBSSxFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFSCxZQUFZQSxVQUFVLEVBQUVJLGFBQWFDLGtCQUFrQixFQUFFLEdBQUdUO0lBQ3RHLElBQUlVLGtCQUFrQixDQUFDLEdBQUdoQix5Q0FBWSxFQUFHZTtJQUN4QyxJQUFHYiw0Q0FBZSxFQUFHO1FBQ2xCLDBIQUEwSDtRQUMxSCxJQUFJWSxjQUFjQztRQUNsQixJQUFJRixpQkFBaUJJLE9BQU8sSUFBSSxDQUFDUCxXQUFXUSxPQUFPLENBQUNKLGNBQWM7WUFDOURBLGNBQWNMLDZDQUE2Q0MsWUFBWUosTUFBTUssWUFBWTtZQUN6RixJQUFJRyxlQUFlLE1BQ25CRCxpQkFBaUJNLGVBQWUsQ0FBQztnQkFDN0JMO2FBQ0g7UUFDTDtRQUNBLDJKQUEySjtRQUMzSixJQUFJQSxlQUFlLFFBQVFELGlCQUFpQk8sVUFBVSxJQUFJLFFBQVEsQ0FBQ1AsaUJBQWlCUSxTQUFTLElBQUlQLGdCQUFnQkUsZ0JBQWdCTSxPQUFPLEVBQUVULGlCQUFpQlUsYUFBYSxDQUFDVDtRQUN6S0UsZ0JBQWdCTSxPQUFPLEdBQUdSO0lBQzlCO0lBQ0EsT0FBTztRQUNILEdBQUdSLEtBQUs7UUFDUmtCLFlBQVlwQixNQUFNb0IsVUFBVSxJQUFJO0lBQ3BDO0FBQ0o7QUFDQSxTQUFTZiw2Q0FBNkNDLFVBQVUsRUFBRUMsWUFBWTtJQUMxRSxJQUFJRyxjQUFjO0lBQ2xCLElBQUlKLFlBQVk7UUFDWkksY0FBY0osV0FBV2UsV0FBVztRQUNwQyx1RUFBdUU7UUFDdkUsTUFBTWQsYUFBYWUsR0FBRyxDQUFDWixnQkFBZ0JBLGdCQUFnQkosV0FBV2lCLFVBQVUsR0FBR2IsY0FBY0osV0FBV2tCLFdBQVcsQ0FBQ2Q7UUFDcEgsb0hBQW9IO1FBQ3BILElBQUlILGFBQWFlLEdBQUcsQ0FBQ1osZ0JBQWdCQSxnQkFBZ0JKLFdBQVdpQixVQUFVLElBQUliLGNBQWNKLFdBQVdlLFdBQVc7SUFDdEg7SUFDQSxPQUFPWDtBQUNYO0FBS29FLENBQ3BFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3RhYnMvZGlzdC9pbXBvcnQubWpzPzljOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUgYXMgJGlqSEtaJHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2xpc3RcIjtcbmltcG9ydCB7dXNlUmVmIGFzICRpakhLWiR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkaWpIS1okdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJDc2ZjkxOWEwNGM1YTdkMTQkZXhwb3J0JDRiYTA3MWRhZjRlNDg2KHByb3BzKSB7XG4gICAgdmFyIF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXk7XG4gICAgbGV0IHN0YXRlID0gKDAsICRpakhLWiR1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHN1cHByZXNzVGV4dFZhbHVlV2FybmluZzogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkS2V5OiAoX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA9IHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleSkgIT09IG51bGwgJiYgX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSAhPT0gdm9pZCAwID8gX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA6ICQ3NmY5MTlhMDRjNWE3ZDE0JHZhciRmaW5kRGVmYXVsdFNlbGVjdGVkS2V5KHByb3BzLmNvbGxlY3Rpb24sIHByb3BzLmRpc2FibGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGlzYWJsZWRLZXlzKSA6IG5ldyBTZXQoKSlcbiAgICB9KTtcbiAgICBsZXQgeyBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyLCBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLCBzZWxlY3RlZEtleTogY3VycmVudFNlbGVjdGVkS2V5IH0gPSBzdGF0ZTtcbiAgICBsZXQgbGFzdFNlbGVjdGVkS2V5ID0gKDAsICRpakhLWiR1c2VSZWYpKGN1cnJlbnRTZWxlY3RlZEtleSk7XG4gICAgKDAsICRpakhLWiR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIC8vIEVuc3VyZSBhIHRhYiBpcyBhbHdheXMgc2VsZWN0ZWQgKGluIGNhc2Ugbm8gc2VsZWN0ZWQga2V5IHdhcyBzcGVjaWZpZWQgb3IgaWYgc2VsZWN0ZWQgaXRlbSB3YXMgZGVsZXRlZCBmcm9tIGNvbGxlY3Rpb24pXG4gICAgICAgIGxldCBzZWxlY3RlZEtleSA9IGN1cnJlbnRTZWxlY3RlZEtleTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbk1hbmFnZXIuaXNFbXB0eSB8fCAhY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRLZXkgPSAkNzZmOTE5YTA0YzVhN2QxNCR2YXIkZmluZERlZmF1bHRTZWxlY3RlZEtleShjb2xsZWN0aW9uLCBzdGF0ZS5kaXNhYmxlZEtleXMpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkS2V5ICE9IG51bGwpIC8vIGRpcmVjdGx5IHNldCBzZWxlY3Rpb24gYmVjYXVzZSByZXBsYWNlL3RvZ2dsZSBzZWxlY3Rpb24gd29uJ3QgY29uc2lkZXIgZGlzYWJsZWQga2V5c1xuICAgICAgICAgICAgc2VsZWN0aW9uTWFuYWdlci5zZXRTZWxlY3RlZEtleXMoW1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdGFibGlzdCBkb2Vzbid0IGhhdmUgZm9jdXMgYW5kIHRoZSBzZWxlY3RlZCBrZXkgY2hhbmdlcyBvciBpZiB0aGVyZSBpc24ndCBhIGZvY3VzZWQga2V5IHlldCwgY2hhbmdlIGZvY3VzZWQga2V5IHRvIHRoZSBzZWxlY3RlZCBrZXkgaWYgaXQgZXhpc3RzLlxuICAgICAgICBpZiAoc2VsZWN0ZWRLZXkgIT0gbnVsbCAmJiBzZWxlY3Rpb25NYW5hZ2VyLmZvY3VzZWRLZXkgPT0gbnVsbCB8fCAhc2VsZWN0aW9uTWFuYWdlci5pc0ZvY3VzZWQgJiYgc2VsZWN0ZWRLZXkgIT09IGxhc3RTZWxlY3RlZEtleS5jdXJyZW50KSBzZWxlY3Rpb25NYW5hZ2VyLnNldEZvY3VzZWRLZXkoc2VsZWN0ZWRLZXkpO1xuICAgICAgICBsYXN0U2VsZWN0ZWRLZXkuY3VycmVudCA9IHNlbGVjdGVkS2V5O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpc0Rpc2FibGVkOiBwcm9wcy5pc0Rpc2FibGVkIHx8IGZhbHNlXG4gICAgfTtcbn1cbmZ1bmN0aW9uICQ3NmY5MTlhMDRjNWE3ZDE0JHZhciRmaW5kRGVmYXVsdFNlbGVjdGVkS2V5KGNvbGxlY3Rpb24sIGRpc2FibGVkS2V5cykge1xuICAgIGxldCBzZWxlY3RlZEtleSA9IG51bGw7XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0ZWRLZXkgPSBjb2xsZWN0aW9uLmdldEZpcnN0S2V5KCk7XG4gICAgICAgIC8vIGxvb3Agb3ZlciB0YWJzIHVudGlsIHdlIGZpbmQgb25lIHRoYXQgaXNuJ3QgZGlzYWJsZWQgYW5kIHNlbGVjdCB0aGF0XG4gICAgICAgIHdoaWxlKGRpc2FibGVkS2V5cy5oYXMoc2VsZWN0ZWRLZXkpICYmIHNlbGVjdGVkS2V5ICE9PSBjb2xsZWN0aW9uLmdldExhc3RLZXkoKSlzZWxlY3RlZEtleSA9IGNvbGxlY3Rpb24uZ2V0S2V5QWZ0ZXIoc2VsZWN0ZWRLZXkpO1xuICAgICAgICAvLyBpZiB0aGlzIGNoZWNrIGlzIHRydWUsIHRoZW4gZXZlcnkgaXRlbSBpcyBkaXNhYmxlZCwgaXQgbWFrZXMgbW9yZSBzZW5zZSB0byBkZWZhdWx0IHRvIHRoZSBmaXJzdCBrZXkgdGhhbiB0aGUgbGFzdFxuICAgICAgICBpZiAoZGlzYWJsZWRLZXlzLmhhcyhzZWxlY3RlZEtleSkgJiYgc2VsZWN0ZWRLZXkgPT09IGNvbGxlY3Rpb24uZ2V0TGFzdEtleSgpKSBzZWxlY3RlZEtleSA9IGNvbGxlY3Rpb24uZ2V0Rmlyc3RLZXkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkS2V5O1xufVxuXG5cblxuXG5leHBvcnQgeyQ3NmY5MTlhMDRjNWE3ZDE0JGV4cG9ydCQ0YmEwNzFkYWY0ZTQ4NiBhcyB1c2VUYWJMaXN0U3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSIsIiRpakhLWiR1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUiLCJ1c2VSZWYiLCIkaWpIS1okdXNlUmVmIiwidXNlRWZmZWN0IiwiJGlqSEtaJHVzZUVmZmVjdCIsIiQ3NmY5MTlhMDRjNWE3ZDE0JGV4cG9ydCQ0YmEwNzFkYWY0ZTQ4NiIsInByb3BzIiwiX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSIsInN0YXRlIiwic3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nIiwiZGVmYXVsdFNlbGVjdGVkS2V5IiwiJDc2ZjkxOWEwNGM1YTdkMTQkdmFyJGZpbmREZWZhdWx0U2VsZWN0ZWRLZXkiLCJjb2xsZWN0aW9uIiwiZGlzYWJsZWRLZXlzIiwiU2V0Iiwic2VsZWN0aW9uTWFuYWdlciIsInNlbGVjdGVkS2V5IiwiY3VycmVudFNlbGVjdGVkS2V5IiwibGFzdFNlbGVjdGVkS2V5IiwiaXNFbXB0eSIsImdldEl0ZW0iLCJzZXRTZWxlY3RlZEtleXMiLCJmb2N1c2VkS2V5IiwiaXNGb2N1c2VkIiwiY3VycmVudCIsInNldEZvY3VzZWRLZXkiLCJpc0Rpc2FibGVkIiwiZ2V0Rmlyc3RLZXkiLCJoYXMiLCJnZXRMYXN0S2V5IiwiZ2V0S2V5QWZ0ZXIiLCJ1c2VUYWJMaXN0U3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/toggle/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useToggleState: () => (/* binding */ $3017fa7ffdddec74$export$8042c6c013fd5226)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $3017fa7ffdddec74$export$8042c6c013fd5226(props = {}) {\n    let { isReadOnly: isReadOnly } = props;\n    // have to provide an empty function so useControlledState doesn't throw a fit\n    // can't use useControlledState's prop calling because we need the event object from the change\n    let [isSelected, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__.useControlledState)(props.isSelected, props.defaultSelected || false, props.onChange);\n    function updateSelected(value) {\n        if (!isReadOnly) setSelected(value);\n    }\n    function toggleState() {\n        if (!isReadOnly) setSelected(!isSelected);\n    }\n    return {\n        isSelected: isSelected,\n        setSelected: updateSelected,\n        toggle: toggleState\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9nZ2xlL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRjtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNELFNBQVNFLDBDQUEwQ0MsUUFBUSxDQUFDLENBQUM7SUFDekQsSUFBSSxFQUFFQyxZQUFZQSxVQUFVLEVBQUUsR0FBR0Q7SUFDakMsOEVBQThFO0lBQzlFLCtGQUErRjtJQUMvRixJQUFJLENBQUNFLFlBQVlDLFlBQVksR0FBRyxDQUFDLEdBQUdMLG9FQUF3QixFQUFHRSxNQUFNRSxVQUFVLEVBQUVGLE1BQU1JLGVBQWUsSUFBSSxPQUFPSixNQUFNSyxRQUFRO0lBQy9ILFNBQVNDLGVBQWVDLEtBQUs7UUFDekIsSUFBSSxDQUFDTixZQUFZRSxZQUFZSTtJQUNqQztJQUNBLFNBQVNDO1FBQ0wsSUFBSSxDQUFDUCxZQUFZRSxZQUFZLENBQUNEO0lBQ2xDO0lBQ0EsT0FBTztRQUNIQSxZQUFZQTtRQUNaQyxhQUFhRztRQUNiRyxRQUFRRDtJQUNaO0FBQ0o7QUFLcUUsQ0FDckUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9nZ2xlL2Rpc3QvaW1wb3J0Lm1qcz9mODU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICRiT2thZSR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDMwMTdmYTdmZmRkZGVjNzQkZXhwb3J0JDgwNDJjNmMwMTNmZDUyMjYocHJvcHMgPSB7fSkge1xuICAgIGxldCB7IGlzUmVhZE9ubHk6IGlzUmVhZE9ubHkgfSA9IHByb3BzO1xuICAgIC8vIGhhdmUgdG8gcHJvdmlkZSBhbiBlbXB0eSBmdW5jdGlvbiBzbyB1c2VDb250cm9sbGVkU3RhdGUgZG9lc24ndCB0aHJvdyBhIGZpdFxuICAgIC8vIGNhbid0IHVzZSB1c2VDb250cm9sbGVkU3RhdGUncyBwcm9wIGNhbGxpbmcgYmVjYXVzZSB3ZSBuZWVkIHRoZSBldmVudCBvYmplY3QgZnJvbSB0aGUgY2hhbmdlXG4gICAgbGV0IFtpc1NlbGVjdGVkLCBzZXRTZWxlY3RlZF0gPSAoMCwgJGJPa2FlJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMuaXNTZWxlY3RlZCwgcHJvcHMuZGVmYXVsdFNlbGVjdGVkIHx8IGZhbHNlLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1JlYWRPbmx5KSBzZXRTZWxlY3RlZCh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvZ2dsZVN0YXRlKCkge1xuICAgICAgICBpZiAoIWlzUmVhZE9ubHkpIHNldFNlbGVjdGVkKCFpc1NlbGVjdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNTZWxlY3RlZDogaXNTZWxlY3RlZCxcbiAgICAgICAgc2V0U2VsZWN0ZWQ6IHVwZGF0ZVNlbGVjdGVkLFxuICAgICAgICB0b2dnbGU6IHRvZ2dsZVN0YXRlXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskMzAxN2ZhN2ZmZGRkZWM3NCRleHBvcnQkODA0MmM2YzAxM2ZkNTIyNiBhcyB1c2VUb2dnbGVTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlQ29udHJvbGxlZFN0YXRlIiwiJGJPa2FlJHVzZUNvbnRyb2xsZWRTdGF0ZSIsIiQzMDE3ZmE3ZmZkZGRlYzc0JGV4cG9ydCQ4MDQyYzZjMDEzZmQ1MjI2IiwicHJvcHMiLCJpc1JlYWRPbmx5IiwiaXNTZWxlY3RlZCIsInNldFNlbGVjdGVkIiwiZGVmYXVsdFNlbGVjdGVkIiwib25DaGFuZ2UiLCJ1cGRhdGVTZWxlY3RlZCIsInZhbHVlIiwidG9nZ2xlU3RhdGUiLCJ0b2dnbGUiLCJ1c2VUb2dnbGVTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@react-stately/tooltip/dist/import.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTooltipTriggerState: () => (/* binding */ $8796f90736e175cb$export$4d40659c25ecb50b)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $8796f90736e175cb$var$TOOLTIP_DELAY = 1500; // this seems to be a 1.5 second delay, check with design\nconst $8796f90736e175cb$var$TOOLTIP_COOLDOWN = 500;\nlet $8796f90736e175cb$var$tooltips = {};\nlet $8796f90736e175cb$var$tooltipId = 0;\nlet $8796f90736e175cb$var$globalWarmedUp = false;\nlet $8796f90736e175cb$var$globalWarmUpTimeout = null;\nlet $8796f90736e175cb$var$globalCooldownTimeout = null;\nfunction $8796f90736e175cb$export$4d40659c25ecb50b(props = {}) {\n    let { delay: delay = $8796f90736e175cb$var$TOOLTIP_DELAY, closeDelay: closeDelay = $8796f90736e175cb$var$TOOLTIP_COOLDOWN } = props;\n    let { isOpen: isOpen, open: open, close: close } = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`${++$8796f90736e175cb$var$tooltipId}`, []);\n    let closeTimeout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let ensureTooltipEntry = ()=>{\n        $8796f90736e175cb$var$tooltips[id] = hideTooltip;\n    };\n    let closeOpenTooltips = ()=>{\n        for(let hideTooltipId in $8796f90736e175cb$var$tooltips)if (hideTooltipId !== id) {\n            $8796f90736e175cb$var$tooltips[hideTooltipId](true);\n            delete $8796f90736e175cb$var$tooltips[hideTooltipId];\n        }\n    };\n    let showTooltip = ()=>{\n        clearTimeout(closeTimeout.current);\n        closeTimeout.current = null;\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        $8796f90736e175cb$var$globalWarmedUp = true;\n        open();\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalCooldownTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = null;\n        }\n    };\n    let hideTooltip = (immediate)=>{\n        if (immediate || closeDelay <= 0) {\n            clearTimeout(closeTimeout.current);\n            closeTimeout.current = null;\n            close();\n        } else if (!closeTimeout.current) closeTimeout.current = setTimeout(()=>{\n            closeTimeout.current = null;\n            close();\n        }, closeDelay);\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalWarmedUp) {\n            if ($8796f90736e175cb$var$globalCooldownTimeout) clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = setTimeout(()=>{\n                delete $8796f90736e175cb$var$tooltips[id];\n                $8796f90736e175cb$var$globalCooldownTimeout = null;\n                $8796f90736e175cb$var$globalWarmedUp = false;\n            }, Math.max($8796f90736e175cb$var$TOOLTIP_COOLDOWN, closeDelay));\n        }\n    };\n    let warmupTooltip = ()=>{\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        if (!isOpen && !$8796f90736e175cb$var$globalWarmUpTimeout && !$8796f90736e175cb$var$globalWarmedUp) $8796f90736e175cb$var$globalWarmUpTimeout = setTimeout(()=>{\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n            $8796f90736e175cb$var$globalWarmedUp = true;\n            showTooltip();\n        }, delay);\n        else if (!isOpen) showTooltip();\n    };\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            clearTimeout(closeTimeout.current);\n            let tooltip = $8796f90736e175cb$var$tooltips[id];\n            if (tooltip) delete $8796f90736e175cb$var$tooltips[id];\n        };\n    }, [\n        id\n    ]);\n    return {\n        isOpen: isOpen,\n        open: (immediate)=>{\n            if (!immediate && delay > 0 && !closeTimeout.current) warmupTooltip();\n            else showTooltip();\n        },\n        close: hideTooltip\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9vbHRpcC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdHO0FBQ1I7QUFFaEc7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FFRCxNQUFNUSxzQ0FBc0MsTUFBTSx5REFBeUQ7QUFDM0csTUFBTUMseUNBQXlDO0FBQy9DLElBQUlDLGlDQUFpQyxDQUFDO0FBQ3RDLElBQUlDLGtDQUFrQztBQUN0QyxJQUFJQyx1Q0FBdUM7QUFDM0MsSUFBSUMsNENBQTRDO0FBQ2hELElBQUlDLDhDQUE4QztBQUNsRCxTQUFTQywwQ0FBMENDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pELElBQUksRUFBRUMsT0FBT0EsUUFBUVQsbUNBQW1DLEVBQUVVLFlBQVlBLGFBQWFULHNDQUFzQyxFQUFFLEdBQUdPO0lBQzlILElBQUksRUFBRUcsUUFBUUEsTUFBTSxFQUFFQyxNQUFNQSxJQUFJLEVBQUVDLE9BQU9BLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBR2QsMkVBQTRCLEVBQUdTO0lBQ3RGLElBQUlNLEtBQUssQ0FBQyxHQUFHckIsMENBQWEsRUFBRyxJQUFJLENBQUMsRUFBRSxFQUFFVSxnQ0FBZ0MsQ0FBQyxFQUFFLEVBQUU7SUFDM0UsSUFBSVksZUFBZSxDQUFDLEdBQUdwQix5Q0FBWTtJQUNuQyxJQUFJcUIscUJBQXFCO1FBQ3JCZCw4QkFBOEIsQ0FBQ1ksR0FBRyxHQUFHRztJQUN6QztJQUNBLElBQUlDLG9CQUFvQjtRQUNwQixJQUFJLElBQUlDLGlCQUFpQmpCLCtCQUErQixJQUFJaUIsa0JBQWtCTCxJQUFJO1lBQzlFWiw4QkFBOEIsQ0FBQ2lCLGNBQWMsQ0FBQztZQUM5QyxPQUFPakIsOEJBQThCLENBQUNpQixjQUFjO1FBQ3hEO0lBQ0o7SUFDQSxJQUFJQyxjQUFjO1FBQ2RDLGFBQWFOLGFBQWFPLE9BQU87UUFDakNQLGFBQWFPLE9BQU8sR0FBRztRQUN2Qko7UUFDQUY7UUFDQVosdUNBQXVDO1FBQ3ZDUTtRQUNBLElBQUlQLDJDQUEyQztZQUMzQ2dCLGFBQWFoQjtZQUNiQSw0Q0FBNEM7UUFDaEQ7UUFDQSxJQUFJQyw2Q0FBNkM7WUFDN0NlLGFBQWFmO1lBQ2JBLDhDQUE4QztRQUNsRDtJQUNKO0lBQ0EsSUFBSVcsY0FBYyxDQUFDTTtRQUNmLElBQUlBLGFBQWFiLGNBQWMsR0FBRztZQUM5QlcsYUFBYU4sYUFBYU8sT0FBTztZQUNqQ1AsYUFBYU8sT0FBTyxHQUFHO1lBQ3ZCVDtRQUNKLE9BQU8sSUFBSSxDQUFDRSxhQUFhTyxPQUFPLEVBQUVQLGFBQWFPLE9BQU8sR0FBR0UsV0FBVztZQUNoRVQsYUFBYU8sT0FBTyxHQUFHO1lBQ3ZCVDtRQUNKLEdBQUdIO1FBQ0gsSUFBSUwsMkNBQTJDO1lBQzNDZ0IsYUFBYWhCO1lBQ2JBLDRDQUE0QztRQUNoRDtRQUNBLElBQUlELHNDQUFzQztZQUN0QyxJQUFJRSw2Q0FBNkNlLGFBQWFmO1lBQzlEQSw4Q0FBOENrQixXQUFXO2dCQUNyRCxPQUFPdEIsOEJBQThCLENBQUNZLEdBQUc7Z0JBQ3pDUiw4Q0FBOEM7Z0JBQzlDRix1Q0FBdUM7WUFDM0MsR0FBR3FCLEtBQUtDLEdBQUcsQ0FBQ3pCLHdDQUF3Q1M7UUFDeEQ7SUFDSjtJQUNBLElBQUlpQixnQkFBZ0I7UUFDaEJUO1FBQ0FGO1FBQ0EsSUFBSSxDQUFDTCxVQUFVLENBQUNOLDZDQUE2QyxDQUFDRCxzQ0FBc0NDLDRDQUE0Q21CLFdBQVc7WUFDdkpuQiw0Q0FBNEM7WUFDNUNELHVDQUF1QztZQUN2Q2dCO1FBQ0osR0FBR1g7YUFDRSxJQUFJLENBQUNFLFFBQVFTO0lBQ3RCO0lBQ0EsNENBQTRDO0lBQzNDLElBQUd2Qiw0Q0FBZSxFQUFHO1FBQ2xCLE9BQU87WUFDSHdCLGFBQWFOLGFBQWFPLE9BQU87WUFDakMsSUFBSU0sVUFBVTFCLDhCQUE4QixDQUFDWSxHQUFHO1lBQ2hELElBQUljLFNBQVMsT0FBTzFCLDhCQUE4QixDQUFDWSxHQUFHO1FBQzFEO0lBQ0osR0FBRztRQUNDQTtLQUNIO0lBQ0QsT0FBTztRQUNISCxRQUFRQTtRQUNSQyxNQUFNLENBQUNXO1lBQ0gsSUFBSSxDQUFDQSxhQUFhZCxRQUFRLEtBQUssQ0FBQ00sYUFBYU8sT0FBTyxFQUFFSztpQkFDakRQO1FBQ1Q7UUFDQVAsT0FBT0k7SUFDWDtBQUNKO0FBSzZFLENBQzdFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3Rvb2x0aXAvZGlzdC9pbXBvcnQubWpzPzE1OGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VNZW1vIGFzICQxT2hEcSR1c2VNZW1vLCB1c2VSZWYgYXMgJDFPaERxJHVzZVJlZiwgdXNlRWZmZWN0IGFzICQxT2hEcSR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VPdmVybGF5VHJpZ2dlclN0YXRlIGFzICQxT2hEcSR1c2VPdmVybGF5VHJpZ2dlclN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY29uc3QgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfREVMQVkgPSAxNTAwOyAvLyB0aGlzIHNlZW1zIHRvIGJlIGEgMS41IHNlY29uZCBkZWxheSwgY2hlY2sgd2l0aCBkZXNpZ25cbmNvbnN0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRUT09MVElQX0NPT0xET1dOID0gNTAwO1xubGV0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwcyA9IHt9O1xubGV0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwSWQgPSAwO1xubGV0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCA9IGZhbHNlO1xubGV0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ID0gbnVsbDtcbmxldCAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0ID0gbnVsbDtcbmZ1bmN0aW9uICQ4Nzk2ZjkwNzM2ZTE3NWNiJGV4cG9ydCQ0ZDQwNjU5YzI1ZWNiNTBiKHByb3BzID0ge30pIHtcbiAgICBsZXQgeyBkZWxheTogZGVsYXkgPSAkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9ERUxBWSwgY2xvc2VEZWxheTogY2xvc2VEZWxheSA9ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRUT09MVElQX0NPT0xET1dOIH0gPSBwcm9wcztcbiAgICBsZXQgeyBpc09wZW46IGlzT3Blbiwgb3Blbjogb3BlbiwgY2xvc2U6IGNsb3NlIH0gPSAoMCwgJDFPaERxJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUpKHByb3BzKTtcbiAgICBsZXQgaWQgPSAoMCwgJDFPaERxJHVzZU1lbW8pKCgpPT5gJHsrKyQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwSWR9YCwgW10pO1xuICAgIGxldCBjbG9zZVRpbWVvdXQgPSAoMCwgJDFPaERxJHVzZVJlZikoKTtcbiAgICBsZXQgZW5zdXJlVG9vbHRpcEVudHJ5ID0gKCk9PntcbiAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzW2lkXSA9IGhpZGVUb29sdGlwO1xuICAgIH07XG4gICAgbGV0IGNsb3NlT3BlblRvb2x0aXBzID0gKCk9PntcbiAgICAgICAgZm9yKGxldCBoaWRlVG9vbHRpcElkIGluICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwcylpZiAoaGlkZVRvb2x0aXBJZCAhPT0gaWQpIHtcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1toaWRlVG9vbHRpcElkXSh0cnVlKTtcbiAgICAgICAgICAgIGRlbGV0ZSAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHNbaGlkZVRvb2x0aXBJZF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBzaG93VG9vbHRpcCA9ICgpPT57XG4gICAgICAgIGNsZWFyVGltZW91dChjbG9zZVRpbWVvdXQuY3VycmVudCk7XG4gICAgICAgIGNsb3NlVGltZW91dC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY2xvc2VPcGVuVG9vbHRpcHMoKTtcbiAgICAgICAgZW5zdXJlVG9vbHRpcEVudHJ5KCk7XG4gICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCA9IHRydWU7XG4gICAgICAgIG9wZW4oKTtcbiAgICAgICAgaWYgKCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQpO1xuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCk7XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IGhpZGVUb29sdGlwID0gKGltbWVkaWF0ZSk9PntcbiAgICAgICAgaWYgKGltbWVkaWF0ZSB8fCBjbG9zZURlbGF5IDw9IDApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjbG9zZVRpbWVvdXQuY3VycmVudCk7XG4gICAgICAgICAgICBjbG9zZVRpbWVvdXQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjbG9zZVRpbWVvdXQuY3VycmVudCkgY2xvc2VUaW1lb3V0LmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICBjbG9zZVRpbWVvdXQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9LCBjbG9zZURlbGF5KTtcbiAgICAgICAgaWYgKCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQpO1xuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXApIHtcbiAgICAgICAgICAgIGlmICgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0KSBjbGVhclRpbWVvdXQoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCk7XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0ID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIGRlbGV0ZSAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHNbaWRdO1xuICAgICAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgTWF0aC5tYXgoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfQ09PTERPV04sIGNsb3NlRGVsYXkpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHdhcm11cFRvb2x0aXAgPSAoKT0+e1xuICAgICAgICBjbG9zZU9wZW5Ub29sdGlwcygpO1xuICAgICAgICBlbnN1cmVUb29sdGlwRW50cnkoKTtcbiAgICAgICAgaWYgKCFpc09wZW4gJiYgISQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ICYmICEkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXApICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwID0gdHJ1ZTtcbiAgICAgICAgICAgIHNob3dUb29sdGlwKCk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgZWxzZSBpZiAoIWlzT3Blbikgc2hvd1Rvb2x0aXAoKTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgKDAsICQxT2hEcSR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dC5jdXJyZW50KTtcbiAgICAgICAgICAgIGxldCB0b29sdGlwID0gJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzW2lkXTtcbiAgICAgICAgICAgIGlmICh0b29sdGlwKSBkZWxldGUgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzW2lkXTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGlkXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNPcGVuOiBpc09wZW4sXG4gICAgICAgIG9wZW46IChpbW1lZGlhdGUpPT57XG4gICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSAmJiBkZWxheSA+IDAgJiYgIWNsb3NlVGltZW91dC5jdXJyZW50KSB3YXJtdXBUb29sdGlwKCk7XG4gICAgICAgICAgICBlbHNlIHNob3dUb29sdGlwKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBoaWRlVG9vbHRpcFxuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JDg3OTZmOTA3MzZlMTc1Y2IkZXhwb3J0JDRkNDA2NTljMjVlY2I1MGIgYXMgdXNlVG9vbHRpcFRyaWdnZXJTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlTWVtbyIsIiQxT2hEcSR1c2VNZW1vIiwidXNlUmVmIiwiJDFPaERxJHVzZVJlZiIsInVzZUVmZmVjdCIsIiQxT2hEcSR1c2VFZmZlY3QiLCJ1c2VPdmVybGF5VHJpZ2dlclN0YXRlIiwiJDFPaERxJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUiLCIkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9ERUxBWSIsIiQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRUT09MVElQX0NPT0xET1dOIiwiJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzIiwiJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBJZCIsIiQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCIsIiQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0IiwiJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCIsIiQ4Nzk2ZjkwNzM2ZTE3NWNiJGV4cG9ydCQ0ZDQwNjU5YzI1ZWNiNTBiIiwicHJvcHMiLCJkZWxheSIsImNsb3NlRGVsYXkiLCJpc09wZW4iLCJvcGVuIiwiY2xvc2UiLCJpZCIsImNsb3NlVGltZW91dCIsImVuc3VyZVRvb2x0aXBFbnRyeSIsImhpZGVUb29sdGlwIiwiY2xvc2VPcGVuVG9vbHRpcHMiLCJoaWRlVG9vbHRpcElkIiwic2hvd1Rvb2x0aXAiLCJjbGVhclRpbWVvdXQiLCJjdXJyZW50IiwiaW1tZWRpYXRlIiwic2V0VGltZW91dCIsIk1hdGgiLCJtYXgiLCJ3YXJtdXBUb29sdGlwIiwidG9vbHRpcCIsInVzZVRvb2x0aXBUcmlnZ2VyU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tree/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tree/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeCollection: () => (/* binding */ $05ca4cd7c4a5a999$export$863faf230ee2118a),\n/* harmony export */   useTreeState: () => (/* binding */ $875d6693e12af071$export$728d6ba534403756)\n/* harmony export */ });\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $05ca4cd7c4a5a999$export$863faf230ee2118a {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    constructor(nodes, { expandedKeys: expandedKeys } = {}){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        expandedKeys = expandedKeys || new Set();\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && (node.type === \"section\" || expandedKeys.has(node.key))) for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\nfunction $875d6693e12af071$export$728d6ba534403756(props) {\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.expandedKeys ? new Set(props.expandedKeys) : undefined, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(), props.onExpandedChange);\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let tree = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $05ca4cd7c4a5a999$export$863faf230ee2118a)(nodes, {\n            expandedKeys: expandedKeys\n        }), [\n        expandedKeys\n    ]), null);\n    // Reset focused key if that item is deleted from the collection.\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        tree,\n        selectionState.focusedKey\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($875d6693e12af071$var$toggleKey(expandedKeys, key));\n    };\n    return {\n        collection: tree,\n        expandedKeys: expandedKeys,\n        disabledKeys: disabledKeys,\n        toggleKey: onToggle,\n        setExpandedKeys: setExpandedKeys,\n        selectionManager: new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.SelectionManager)(tree, selectionState)\n    };\n}\nfunction $875d6693e12af071$var$toggleKey(set, key) {\n    let res = new Set(set);\n    if (res.has(key)) res.delete(key);\n    else res.add(key);\n    return res;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdHJlZS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9KO0FBQ2xDO0FBQ2pDO0FBQ0k7QUFFckY7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FDRDs7Ozs7Ozs7OztDQVVDLEdBQUcsTUFBTWM7SUFDTixDQUFDLENBQUNDLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO1FBQ2pCLE9BQU8sSUFBSSxDQUFDQyxRQUFRO0lBQ3hCO0lBQ0EsSUFBSUMsT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDQyxNQUFNLENBQUNELElBQUk7SUFDM0I7SUFDQUUsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDRCxNQUFNLENBQUNFLElBQUk7SUFDM0I7SUFDQUMsYUFBYUMsR0FBRyxFQUFFO1FBQ2QsSUFBSUMsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtRQUMzQixPQUFPQyxPQUFPQSxLQUFLRSxPQUFPLEdBQUc7SUFDakM7SUFDQUMsWUFBWUosR0FBRyxFQUFFO1FBQ2IsSUFBSUMsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtRQUMzQixPQUFPQyxPQUFPQSxLQUFLSSxPQUFPLEdBQUc7SUFDakM7SUFDQUMsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDQyxRQUFRO0lBQ3hCO0lBQ0FDLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUN2QjtJQUNBQyxRQUFRVixHQUFHLEVBQUU7UUFDVCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDTSxHQUFHLENBQUNGO0lBQzNCO0lBQ0FXLEdBQUdDLEdBQUcsRUFBRTtRQUNKLE1BQU1kLE9BQU87ZUFDTixJQUFJLENBQUNELE9BQU87U0FDbEI7UUFDRCxPQUFPLElBQUksQ0FBQ2EsT0FBTyxDQUFDWixJQUFJLENBQUNjLElBQUk7SUFDakM7SUFDQUMsWUFBWUMsS0FBSyxFQUFFLEVBQUVD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TUFBTSxJQUFJekIsSUFBSUU7SUFDbEIsSUFBSXVCLElBQUlwQixHQUFHLENBQUN0QixNQUFNMEMsSUFBSUMsTUFBTSxDQUFDM0M7U0FDeEIwQyxJQUFJRSxHQUFHLENBQUM1QztJQUNiLE9BQU8wQztBQUNYO0FBTWdJLENBQ2hJLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3RyZWUvZGlzdC9pbXBvcnQubWpzP2IwOWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIGFzICQxT29UaiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlLCBTZWxlY3Rpb25NYW5hZ2VyIGFzICQxT29UaiRTZWxlY3Rpb25NYW5hZ2VyfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uXCI7XG5pbXBvcnQge3VzZU1lbW8gYXMgJDFPb1RqJHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICQxT29UaiR1c2VDYWxsYmFjaywgdXNlRWZmZWN0IGFzICQxT29UaiR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VDb2xsZWN0aW9uIGFzICQxT29UaiR1c2VDb2xsZWN0aW9ufSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICQxT29UaiR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICQwNWNhNGNkN2M0YTVhOTk5JGV4cG9ydCQ4NjNmYWYyMzBlZTIxMThhIHtcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLml0ZXJhYmxlO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLnNpemU7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5rZXlzKCk7XG4gICAgfVxuICAgIGdldEtleUJlZm9yZShrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLnByZXZLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRLZXlBZnRlcihrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRGaXJzdEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RLZXk7XG4gICAgfVxuICAgIGdldExhc3RLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RLZXk7XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICB9XG4gICAgYXQoaWR4KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmdldEtleXMoKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleXNbaWR4XSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5vZGVzLCB7IGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzIH0gPSB7fSl7XG4gICAgICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gbm9kZXM7XG4gICAgICAgIGV4cGFuZGVkS2V5cyA9IGV4cGFuZGVkS2V5cyB8fCBuZXcgU2V0KCk7XG4gICAgICAgIGxldCB2aXNpdCA9IChub2RlKT0+e1xuICAgICAgICAgICAgdGhpcy5rZXlNYXAuc2V0KG5vZGUua2V5LCBub2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMgJiYgKG5vZGUudHlwZSA9PT0gXCJzZWN0aW9uXCIgfHwgZXhwYW5kZWRLZXlzLmhhcyhub2RlLmtleSkpKSBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpdmlzaXQoY2hpbGQpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXZpc2l0KG5vZGUpO1xuICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgbm9kZV0gb2YgdGhpcy5rZXlNYXApe1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2S2V5ID0gbGFzdC5rZXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJpdGVtXCIpIG5vZGUuaW5kZXggPSBpbmRleCsrO1xuICAgICAgICAgICAgbGFzdCA9IG5vZGU7XG4gICAgICAgICAgICAvLyBTZXQgbmV4dEtleSBhcyB1bmRlZmluZWQgc2luY2UgdGhpcyBtaWdodCBiZSB0aGUgbGFzdCBub2RlXG4gICAgICAgICAgICAvLyBJZiBpdCBpc24ndCB0aGUgbGFzdCBub2RlLCBsYXN0Lm5leHRLZXkgd2lsbCBwcm9wZXJseSBzZXQgYXQgc3RhcnQgb2YgbmV3IGxvb3BcbiAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RLZXkgPSBsYXN0ID09PSBudWxsIHx8IGxhc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3Qua2V5O1xuICAgIH1cbn1cblxuXG5cblxuXG5mdW5jdGlvbiAkODc1ZDY2OTNlMTJhZjA3MSRleHBvcnQkNzI4ZDZiYTUzNDQwMzc1Nihwcm9wcykge1xuICAgIGxldCBbZXhwYW5kZWRLZXlzLCBzZXRFeHBhbmRlZEtleXNdID0gKDAsICQxT29UaiR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLmV4cGFuZGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZXhwYW5kZWRLZXlzKSA6IHVuZGVmaW5lZCwgcHJvcHMuZGVmYXVsdEV4cGFuZGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGVmYXVsdEV4cGFuZGVkS2V5cykgOiBuZXcgU2V0KCksIHByb3BzLm9uRXhwYW5kZWRDaGFuZ2UpO1xuICAgIGxldCBzZWxlY3Rpb25TdGF0ZSA9ICgwLCAkMU9vVGokdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSkocHJvcHMpO1xuICAgIGxldCBkaXNhYmxlZEtleXMgPSAoMCwgJDFPb1RqJHVzZU1lbW8pKCgpPT5wcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCksIFtcbiAgICAgICAgcHJvcHMuZGlzYWJsZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IHRyZWUgPSAoMCwgJDFPb1RqJHVzZUNvbGxlY3Rpb24pKHByb3BzLCAoMCwgJDFPb1RqJHVzZUNhbGxiYWNrKSgobm9kZXMpPT5uZXcgKDAsICQwNWNhNGNkN2M0YTVhOTk5JGV4cG9ydCQ4NjNmYWYyMzBlZTIxMThhKShub2Rlcywge1xuICAgICAgICAgICAgZXhwYW5kZWRLZXlzOiBleHBhbmRlZEtleXNcbiAgICAgICAgfSksIFtcbiAgICAgICAgZXhwYW5kZWRLZXlzXG4gICAgXSksIG51bGwpO1xuICAgIC8vIFJlc2V0IGZvY3VzZWQga2V5IGlmIHRoYXQgaXRlbSBpcyBkZWxldGVkIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgKDAsICQxT29UaiR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5ICE9IG51bGwgJiYgIXRyZWUuZ2V0SXRlbShzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5KSkgc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleShudWxsKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICB0cmVlLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5XG4gICAgXSk7XG4gICAgbGV0IG9uVG9nZ2xlID0gKGtleSk9PntcbiAgICAgICAgc2V0RXhwYW5kZWRLZXlzKCQ4NzVkNjY5M2UxMmFmMDcxJHZhciR0b2dnbGVLZXkoZXhwYW5kZWRLZXlzLCBrZXkpKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbGxlY3Rpb246IHRyZWUsXG4gICAgICAgIGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzLFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcbiAgICAgICAgdG9nZ2xlS2V5OiBvblRvZ2dsZSxcbiAgICAgICAgc2V0RXhwYW5kZWRLZXlzOiBzZXRFeHBhbmRlZEtleXMsXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXI6IG5ldyAoMCwgJDFPb1RqJFNlbGVjdGlvbk1hbmFnZXIpKHRyZWUsIHNlbGVjdGlvblN0YXRlKVxuICAgIH07XG59XG5mdW5jdGlvbiAkODc1ZDY2OTNlMTJhZjA3MSR2YXIkdG9nZ2xlS2V5KHNldCwga2V5KSB7XG4gICAgbGV0IHJlcyA9IG5ldyBTZXQoc2V0KTtcbiAgICBpZiAocmVzLmhhcyhrZXkpKSByZXMuZGVsZXRlKGtleSk7XG4gICAgZWxzZSByZXMuYWRkKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5cblxuXG5leHBvcnQgeyQ4NzVkNjY5M2UxMmFmMDcxJGV4cG9ydCQ3MjhkNmJhNTM0NDAzNzU2IGFzIHVzZVRyZWVTdGF0ZSwgJDA1Y2E0Y2Q3YzRhNWE5OTkkZXhwb3J0JDg2M2ZhZjIzMGVlMjExOGEgYXMgVHJlZUNvbGxlY3Rpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCIkMU9vVGokdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSIsIlNlbGVjdGlvbk1hbmFnZXIiLCIkMU9vVGokU2VsZWN0aW9uTWFuYWdlciIsInVzZU1lbW8iLCIkMU9vVGokdXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiJDFPb1RqJHVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwiJDFPb1RqJHVzZUVmZmVjdCIsInVzZUNvbGxlY3Rpb24iLCIkMU9vVGokdXNlQ29sbGVjdGlvbiIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiQxT29UaiR1c2VDb250cm9sbGVkU3RhdGUiLCIkMDVjYTRjZDdjNGE1YTk5OSRleHBvcnQkODYzZmFmMjMwZWUyMTE4YSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXRlcmFibGUiLCJzaXplIiwia2V5TWFwIiwiZ2V0S2V5cyIsImtleXMiLCJnZXRLZXlCZWZvcmUiLCJrZXkiLCJub2RlIiwiZ2V0IiwicHJldktleSIsImdldEtleUFmdGVyIiwibmV4dEtleSIsImdldEZpcnN0S2V5IiwiZmlyc3RLZXkiLCJnZXRMYXN0S2V5IiwibGFzdEtleSIsImdldEl0ZW0iLCJhdCIsImlkeCIsImNvbnN0cnVjdG9yIiwibm9kZXMiLCJleHBhbmRlZEtleXMiLCJNYXAiLCJTZXQiLCJ2aXNpdCIsInNldCIsImNoaWxkTm9kZXMiLCJ0eXBlIiwiaGFzIiwiY2hpbGQiLCJsYXN0IiwiaW5kZXgiLCJ1bmRlZmluZWQiLCIkODc1ZDY2OTNlMTJhZjA3MSRleHBvcnQkNzI4ZDZiYTUzNDQwMzc1NiIsInByb3BzIiwic2V0RXhwYW5kZWRLZXlzIiwiZGVmYXVsdEV4cGFuZGVkS2V5cyIsIm9uRXhwYW5kZWRDaGFuZ2UiLCJzZWxlY3Rpb25TdGF0ZSIsImRpc2FibGVkS2V5cyIsInRyZWUiLCJmb2N1c2VkS2V5Iiwic2V0Rm9jdXNlZEtleSIsIm9uVG9nZ2xlIiwiJDg3NWQ2NjkzZTEyYWYwNzEkdmFyJHRvZ2dsZUtleSIsImNvbGxlY3Rpb24iLCJ0b2dnbGVLZXkiLCJzZWxlY3Rpb25NYW5hZ2VyIiwicmVzIiwiZGVsZXRlIiwiYWRkIiwidXNlVHJlZVN0YXRlIiwiVHJlZUNvbGxlY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tree/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/utils/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/utils/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ $9446cca9a3875146$export$7d15b64cf5a3a4c4),\n/* harmony export */   snapValueToStep: () => (/* binding */ $9446cca9a3875146$export$cb6e0bb50bc19463),\n/* harmony export */   toFixedNumber: () => (/* binding */ $9446cca9a3875146$export$b6268554fba451f),\n/* harmony export */   useControlledState: () => (/* binding */ $458b0a5536c1a7cf$export$40bfa8c7b0832715)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $458b0a5536c1a7cf$export$40bfa8c7b0832715(value, defaultValue, onChange) {\n    let [stateValue, setStateValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(value || defaultValue);\n    let isControlledRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value !== undefined);\n    let isControlled = value !== undefined;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let wasControlled = isControlledRef.current;\n        if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? \"controlled\" : \"uncontrolled\"} to ${isControlled ? \"controlled\" : \"uncontrolled\"}.`);\n        isControlledRef.current = isControlled;\n    }, [\n        isControlled\n    ]);\n    let currentValue = isControlled ? value : stateValue;\n    let setValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value, ...args)=>{\n        let onChangeCaller = (value, ...onChangeArgs)=>{\n            if (onChange) {\n                if (!Object.is(currentValue, value)) onChange(value, ...onChangeArgs);\n            }\n            if (!isControlled) // calling setState multiple times with the same value only emits onChange once.\n            // We do not use a ref for this because we specifically _do_ want the value to\n            // reset every render, and assigning to a ref in render breaks aborted suspended renders.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            currentValue = value;\n        };\n        if (typeof value === \"function\") {\n            console.warn(\"We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320\");\n            // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n            // when someone using useControlledState calls setControlledState(myFunc)\n            // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n            // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n            // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n            let updateFunction = (oldValue, ...functionArgs)=>{\n                let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);\n                onChangeCaller(interceptedValue, ...args);\n                if (!isControlled) return interceptedValue;\n                return oldValue;\n            };\n            setStateValue(updateFunction);\n        } else {\n            if (!isControlled) setStateValue(value);\n            onChangeCaller(value, ...args);\n        }\n    }, [\n        isControlled,\n        currentValue,\n        onChange\n    ]);\n    return [\n        currentValue,\n        setValue\n    ];\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */ function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {\n    let newValue = Math.min(Math.max(value, min), max);\n    return newValue;\n}\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n    min = Number(min);\n    max = Number(max);\n    let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n    if (!isNaN(min)) {\n        if (snappedValue < min) snappedValue = min;\n        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;\n    // correct floating point behavior by rounding to step precision\n    let string = step.toString();\n    let index = string.indexOf(\".\");\n    let precision = index >= 0 ? string.length - index : 0;\n    if (precision > 0) {\n        let pow = Math.pow(10, precision);\n        snappedValue = Math.round(snappedValue * pow) / pow;\n    }\n    return snappedValue;\n}\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits, base = 10) {\n    const pow = Math.pow(base, digits);\n    return Math.round(value * pow) / pow;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdXRpbHMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZJO0FBRTdJOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsU0FBU1EsMENBQTBDQyxLQUFLLEVBQUVDLFlBQVksRUFBRUMsUUFBUTtJQUM1RSxJQUFJLENBQUNDLFlBQVlDLGNBQWMsR0FBRyxDQUFDLEdBQUdaLDJDQUFjLEVBQUdRLFNBQVNDO0lBQ2hFLElBQUlJLGtCQUFrQixDQUFDLEdBQUdYLHlDQUFZLEVBQUdNLFVBQVVNO0lBQ25ELElBQUlDLGVBQWVQLFVBQVVNO0lBQzVCLElBQUdWLDRDQUFlLEVBQUc7UUFDbEIsSUFBSVksZ0JBQWdCSCxnQkFBZ0JJLE9BQU87UUFDM0MsSUFBSUQsa0JBQWtCRCxjQUFjRyxRQUFRQyxJQUFJLENBQUMsQ0FBQywrQkFBK0IsRUFBRUgsZ0JBQWdCLGVBQWUsZUFBZSxJQUFJLEVBQUVELGVBQWUsZUFBZSxlQUFlLENBQUMsQ0FBQztRQUN0TEYsZ0JBQWdCSSxPQUFPLEdBQUdGO0lBQzlCLEdBQUc7UUFDQ0E7S0FDSDtJQUNELElBQUlLLGVBQWVMLGVBQWVQLFFBQVFHO0lBQzFDLElBQUlVLFdBQVcsQ0FBQyxHQUFHZiw4Q0FBaUIsRUFBRyxDQUFDRSxPQUFPLEdBQUdjO1FBQzlDLElBQUlDLGlCQUFpQixDQUFDZixPQUFPLEdBQUdnQjtZQUM1QixJQUFJZCxVQUFVO2dCQUNWLElBQUksQ0FBQ2UsT0FBT0MsRUFBRSxDQUFDTixjQUFjWixRQUFRRSxTQUFTRixVQUFVZ0I7WUFDNUQ7WUFDQSxJQUFJLENBQUNULGNBQ0wsZ0ZBQWdGO1lBQ2hGLDhFQUE4RTtZQUM5RSx5RkFBeUY7WUFDekYsdURBQXVEO1lBQ3ZESyxlQUFlWjtRQUNuQjtRQUNBLElBQUksT0FBT0EsVUFBVSxZQUFZO1lBQzdCVSxRQUFRQyxJQUFJLENBQUM7WUFDYixvR0FBb0c7WUFDcEcseUVBQXlFO1lBQ3pFLGtJQUFrSTtZQUNsSSxpS0FBaUs7WUFDaksseUlBQXlJO1lBQ3pJLElBQUlRLGlCQUFpQixDQUFDQyxVQUFVLEdBQUdDO2dCQUMvQixJQUFJQyxtQkFBbUJ0QixNQUFNTyxlQUFlSyxlQUFlUSxhQUFhQztnQkFDeEVOLGVBQWVPLHFCQUFxQlI7Z0JBQ3BDLElBQUksQ0FBQ1AsY0FBYyxPQUFPZTtnQkFDMUIsT0FBT0Y7WUFDWDtZQUNBaEIsY0FBY2U7UUFDbEIsT0FBTztZQUNILElBQUksQ0FBQ1osY0FBY0gsY0FBY0o7WUFDakNlLGVBQWVmLFVBQVVjO1FBQzdCO0lBQ0osR0FBRztRQUNDUDtRQUNBSztRQUNBVjtLQUNIO0lBQ0QsT0FBTztRQUNIVTtRQUNBQztLQUNIO0FBQ0w7QUFHQTs7Ozs7Ozs7OztDQVVDLEdBQUc7O0NBRUgsR0FBRyxTQUFTVSwwQ0FBMEN2QixLQUFLLEVBQUV3QixNQUFNLENBQUNDLFFBQVEsRUFBRUMsTUFBTUQsUUFBUTtJQUN6RixJQUFJRSxXQUFXQyxLQUFLSixHQUFHLENBQUNJLEtBQUtGLEdBQUcsQ0FBQzFCLE9BQU93QixNQUFNRTtJQUM5QyxPQUFPQztBQUNYO0FBQ0EsU0FBU0UsMENBQTBDN0IsS0FBSyxFQUFFd0IsR0FBRyxFQUFFRSxHQUFHLEVBQUVJLElBQUk7SUFDcEVOLE1BQU1PLE9BQU9QO0lBQ2JFLE1BQU1LLE9BQU9MO0lBQ2IsSUFBSU0sWUFBWSxDQUFDaEMsUUFBU2lDLENBQUFBLE1BQU1ULE9BQU8sSUFBSUEsR0FBRSxDQUFDLElBQUtNO0lBQ25ELElBQUlJLGVBQWVOLEtBQUtPLEdBQUcsQ0FBQ0gsYUFBYSxLQUFLRixPQUFPOUIsUUFBUTRCLEtBQUtRLElBQUksQ0FBQ0osYUFBY0YsQ0FBQUEsT0FBT0YsS0FBS08sR0FBRyxDQUFDSCxVQUFTLElBQUtoQyxRQUFRZ0M7SUFDM0gsSUFBSSxDQUFDQyxNQUFNVCxNQUFNO1FBQ2IsSUFBSVUsZUFBZVYsS0FBS1UsZUFBZVY7YUFDbEMsSUFBSSxDQUFDUyxNQUFNUCxRQUFRUSxlQUFlUixLQUFLUSxlQUFlVixNQUFNSSxLQUFLUyxLQUFLLENBQUMsQ0FBQ1gsTUFBTUYsR0FBRSxJQUFLTSxRQUFRQTtJQUN0RyxPQUFPLElBQUksQ0FBQ0csTUFBTVAsUUFBUVEsZUFBZVIsS0FBS1EsZUFBZU4sS0FBS1MsS0FBSyxDQUFDWCxNQUFNSSxRQUFRQTtJQUN0RixnRUFBZ0U7SUFDaEUsSUFBSVEsU0FBU1IsS0FBS1MsUUFBUTtJQUMxQixJQUFJQyxRQUFRRixPQUFPRyxPQUFPLENBQUM7SUFDM0IsSUFBSUMsWUFBWUYsU0FBUyxJQUFJRixPQUFPSyxNQUFNLEdBQUdILFFBQVE7SUFDckQsSUFBSUUsWUFBWSxHQUFHO1FBQ2YsSUFBSUUsTUFBTWhCLEtBQUtnQixHQUFHLENBQUMsSUFBSUY7UUFDdkJSLGVBQWVOLEtBQUtpQixLQUFLLENBQUNYLGVBQWVVLE9BQU9BO0lBQ3BEO0lBQ0EsT0FBT1Y7QUFDWDtBQUNBLFNBQVNZLHlDQUF5QzlDLEtBQUssRUFBRStDLE1BQU0sRUFBRUMsT0FBTyxFQUFFO0lBQ3RFLE1BQU1KLE1BQU1oQixLQUFLZ0IsR0FBRyxDQUFDSSxNQUFNRDtJQUMzQixPQUFPbkIsS0FBS2lCLEtBQUssQ0FBQzdDLFFBQVE0QyxPQUFPQTtBQUNyQztBQUtzUCxDQUN0UCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWR1c2EtbmV4dC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS91dGlscy9kaXN0L2ltcG9ydC5tanM/ZTNmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZVN0YXRlIGFzICQ2aW11aCR1c2VTdGF0ZSwgdXNlUmVmIGFzICQ2aW11aCR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkNmltdWgkdXNlRWZmZWN0LCB1c2VDYWxsYmFjayBhcyAkNmltdWgkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDQ1OGIwYTU1MzZjMWE3Y2YkZXhwb3J0JDQwYmZhOGM3YjA4MzI3MTUodmFsdWUsIGRlZmF1bHRWYWx1ZSwgb25DaGFuZ2UpIHtcbiAgICBsZXQgW3N0YXRlVmFsdWUsIHNldFN0YXRlVmFsdWVdID0gKDAsICQ2aW11aCR1c2VTdGF0ZSkodmFsdWUgfHwgZGVmYXVsdFZhbHVlKTtcbiAgICBsZXQgaXNDb250cm9sbGVkUmVmID0gKDAsICQ2aW11aCR1c2VSZWYpKHZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgIGxldCBpc0NvbnRyb2xsZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICgwLCAkNmltdWgkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgd2FzQ29udHJvbGxlZCA9IGlzQ29udHJvbGxlZFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAod2FzQ29udHJvbGxlZCAhPT0gaXNDb250cm9sbGVkKSBjb25zb2xlLndhcm4oYFdBUk46IEEgY29tcG9uZW50IGNoYW5nZWQgZnJvbSAke3dhc0NvbnRyb2xsZWQgPyBcImNvbnRyb2xsZWRcIiA6IFwidW5jb250cm9sbGVkXCJ9IHRvICR7aXNDb250cm9sbGVkID8gXCJjb250cm9sbGVkXCIgOiBcInVuY29udHJvbGxlZFwifS5gKTtcbiAgICAgICAgaXNDb250cm9sbGVkUmVmLmN1cnJlbnQgPSBpc0NvbnRyb2xsZWQ7XG4gICAgfSwgW1xuICAgICAgICBpc0NvbnRyb2xsZWRcbiAgICBdKTtcbiAgICBsZXQgY3VycmVudFZhbHVlID0gaXNDb250cm9sbGVkID8gdmFsdWUgOiBzdGF0ZVZhbHVlO1xuICAgIGxldCBzZXRWYWx1ZSA9ICgwLCAkNmltdWgkdXNlQ2FsbGJhY2spKCh2YWx1ZSwgLi4uYXJncyk9PntcbiAgICAgICAgbGV0IG9uQ2hhbmdlQ2FsbGVyID0gKHZhbHVlLCAuLi5vbkNoYW5nZUFyZ3MpPT57XG4gICAgICAgICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5pcyhjdXJyZW50VmFsdWUsIHZhbHVlKSkgb25DaGFuZ2UodmFsdWUsIC4uLm9uQ2hhbmdlQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxlZCkgLy8gSWYgdW5jb250cm9sbGVkLCBtdXRhdGUgdGhlIGN1cnJlbnRWYWx1ZSBsb2NhbCB2YXJpYWJsZSBzbyB0aGF0XG4gICAgICAgICAgICAvLyBjYWxsaW5nIHNldFN0YXRlIG11bHRpcGxlIHRpbWVzIHdpdGggdGhlIHNhbWUgdmFsdWUgb25seSBlbWl0cyBvbkNoYW5nZSBvbmNlLlxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHVzZSBhIHJlZiBmb3IgdGhpcyBiZWNhdXNlIHdlIHNwZWNpZmljYWxseSBfZG9fIHdhbnQgdGhlIHZhbHVlIHRvXG4gICAgICAgICAgICAvLyByZXNldCBldmVyeSByZW5kZXIsIGFuZCBhc3NpZ25pbmcgdG8gYSByZWYgaW4gcmVuZGVyIGJyZWFrcyBhYm9ydGVkIHN1c3BlbmRlZCByZW5kZXJzLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV2UgY2FuIG5vdCBzdXBwb3J0IGEgZnVuY3Rpb24gY2FsbGJhY2suIFNlZSBHaXRodWIgSXNzdWVzIGZvciBkZXRhaWxzIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9pc3N1ZXMvMjMyMFwiKTtcbiAgICAgICAgICAgIC8vIHRoaXMgc3VwcG9ydHMgZnVuY3Rpb25hbCB1cGRhdGVzIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ob29rcy1yZWZlcmVuY2UuaHRtbCNmdW5jdGlvbmFsLXVwZGF0ZXNcbiAgICAgICAgICAgIC8vIHdoZW4gc29tZW9uZSB1c2luZyB1c2VDb250cm9sbGVkU3RhdGUgY2FsbHMgc2V0Q29udHJvbGxlZFN0YXRlKG15RnVuYylcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBjYWxsIG91ciB1c2VTdGF0ZSBzZXRTdGF0ZSB3aXRoIGEgZnVuY3Rpb24gYXMgd2VsbCB3aGljaCBpbnZva2VzIG15RnVuYyBhbmQgY2FsbHMgb25DaGFuZ2Ugd2l0aCB0aGUgdmFsdWUgZnJvbSBteUZ1bmNcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGluIGFuIHVuY29udHJvbGxlZCBzdGF0ZSwgdGhlbiB3ZSBhbHNvIHJldHVybiB0aGUgdmFsdWUgb2YgbXlGdW5jIHdoaWNoIHRvIHNldFN0YXRlIGxvb2tzIGFzIHRob3VnaCBpdCB3YXMganVzdCBjYWxsZWQgd2l0aCBteUZ1bmMgZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UganVzdCByZXR1cm4gdGhlIGNvbnRyb2xsZWQgdmFsdWUsIHdoaWNoIHdvbid0IGNhdXNlIGEgcmVyZW5kZXIgYmVjYXVzZSBSZWFjdCBrbm93cyB0byBiYWlsIG91dCB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgICAgICAgbGV0IHVwZGF0ZUZ1bmN0aW9uID0gKG9sZFZhbHVlLCAuLi5mdW5jdGlvbkFyZ3MpPT57XG4gICAgICAgICAgICAgICAgbGV0IGludGVyY2VwdGVkVmFsdWUgPSB2YWx1ZShpc0NvbnRyb2xsZWQgPyBjdXJyZW50VmFsdWUgOiBvbGRWYWx1ZSwgLi4uZnVuY3Rpb25BcmdzKTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZUNhbGxlcihpbnRlcmNlcHRlZFZhbHVlLCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxlZCkgcmV0dXJuIGludGVyY2VwdGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldFN0YXRlVmFsdWUodXBkYXRlRnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWQpIHNldFN0YXRlVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgb25DaGFuZ2VDYWxsZXIodmFsdWUsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc0NvbnRyb2xsZWQsXG4gICAgICAgIGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgb25DaGFuZ2VcbiAgICBdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjdXJyZW50VmFsdWUsXG4gICAgICAgIHNldFZhbHVlXG4gICAgXTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLyoqXG4gKiBUYWtlcyBhIHZhbHVlIGFuZCBmb3JjZXMgaXQgdG8gdGhlIGNsb3Nlc3QgbWluL21heCBpZiBpdCdzIG91dHNpZGUuIEFsc28gZm9yY2VzIGl0IHRvIHRoZSBjbG9zZXN0IHZhbGlkIHN0ZXAuXG4gKi8gZnVuY3Rpb24gJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JDdkMTViNjRjZjVhM2E0YzQodmFsdWUsIG1pbiA9IC1JbmZpbml0eSwgbWF4ID0gSW5maW5pdHkpIHtcbiAgICBsZXQgbmV3VmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbiAgICByZXR1cm4gbmV3VmFsdWU7XG59XG5mdW5jdGlvbiAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkY2I2ZTBiYjUwYmMxOTQ2Myh2YWx1ZSwgbWluLCBtYXgsIHN0ZXApIHtcbiAgICBtaW4gPSBOdW1iZXIobWluKTtcbiAgICBtYXggPSBOdW1iZXIobWF4KTtcbiAgICBsZXQgcmVtYWluZGVyID0gKHZhbHVlIC0gKGlzTmFOKG1pbikgPyAwIDogbWluKSkgJSBzdGVwO1xuICAgIGxldCBzbmFwcGVkVmFsdWUgPSBNYXRoLmFicyhyZW1haW5kZXIpICogMiA+PSBzdGVwID8gdmFsdWUgKyBNYXRoLnNpZ24ocmVtYWluZGVyKSAqIChzdGVwIC0gTWF0aC5hYnMocmVtYWluZGVyKSkgOiB2YWx1ZSAtIHJlbWFpbmRlcjtcbiAgICBpZiAoIWlzTmFOKG1pbikpIHtcbiAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZSA8IG1pbikgc25hcHBlZFZhbHVlID0gbWluO1xuICAgICAgICBlbHNlIGlmICghaXNOYU4obWF4KSAmJiBzbmFwcGVkVmFsdWUgPiBtYXgpIHNuYXBwZWRWYWx1ZSA9IG1pbiArIE1hdGguZmxvb3IoKG1heCAtIG1pbikgLyBzdGVwKSAqIHN0ZXA7XG4gICAgfSBlbHNlIGlmICghaXNOYU4obWF4KSAmJiBzbmFwcGVkVmFsdWUgPiBtYXgpIHNuYXBwZWRWYWx1ZSA9IE1hdGguZmxvb3IobWF4IC8gc3RlcCkgKiBzdGVwO1xuICAgIC8vIGNvcnJlY3QgZmxvYXRpbmcgcG9pbnQgYmVoYXZpb3IgYnkgcm91bmRpbmcgdG8gc3RlcCBwcmVjaXNpb25cbiAgICBsZXQgc3RyaW5nID0gc3RlcC50b1N0cmluZygpO1xuICAgIGxldCBpbmRleCA9IHN0cmluZy5pbmRleE9mKFwiLlwiKTtcbiAgICBsZXQgcHJlY2lzaW9uID0gaW5kZXggPj0gMCA/IHN0cmluZy5sZW5ndGggLSBpbmRleCA6IDA7XG4gICAgaWYgKHByZWNpc2lvbiA+IDApIHtcbiAgICAgICAgbGV0IHBvdyA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgICAgICBzbmFwcGVkVmFsdWUgPSBNYXRoLnJvdW5kKHNuYXBwZWRWYWx1ZSAqIHBvdykgLyBwb3c7XG4gICAgfVxuICAgIHJldHVybiBzbmFwcGVkVmFsdWU7XG59XG5mdW5jdGlvbiAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkYjYyNjg1NTRmYmE0NTFmKHZhbHVlLCBkaWdpdHMsIGJhc2UgPSAxMCkge1xuICAgIGNvbnN0IHBvdyA9IE1hdGgucG93KGJhc2UsIGRpZ2l0cyk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwb3cpIC8gcG93O1xufVxuXG5cblxuXG5leHBvcnQgeyQ0NThiMGE1NTM2YzFhN2NmJGV4cG9ydCQ0MGJmYThjN2IwODMyNzE1IGFzIHVzZUNvbnRyb2xsZWRTdGF0ZSwgJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JDdkMTViNjRjZjVhM2E0YzQgYXMgY2xhbXAsICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRjYjZlMGJiNTBiYzE5NDYzIGFzIHNuYXBWYWx1ZVRvU3RlcCwgJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGI2MjY4NTU0ZmJhNDUxZiBhcyB0b0ZpeGVkTnVtYmVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsIiQ2aW11aCR1c2VTdGF0ZSIsInVzZVJlZiIsIiQ2aW11aCR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkNmltdWgkdXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCIkNmltdWgkdXNlQ2FsbGJhY2siLCIkNDU4YjBhNTUzNmMxYTdjZiRleHBvcnQkNDBiZmE4YzdiMDgzMjcxNSIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwib25DaGFuZ2UiLCJzdGF0ZVZhbHVlIiwic2V0U3RhdGVWYWx1ZSIsImlzQ29udHJvbGxlZFJlZiIsInVuZGVmaW5lZCIsImlzQ29udHJvbGxlZCIsIndhc0NvbnRyb2xsZWQiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJjdXJyZW50VmFsdWUiLCJzZXRWYWx1ZSIsImFyZ3MiLCJvbkNoYW5nZUNhbGxlciIsIm9uQ2hhbmdlQXJncyIsIk9iamVjdCIsImlzIiwidXBkYXRlRnVuY3Rpb24iLCJvbGRWYWx1ZSIsImZ1bmN0aW9uQXJncyIsImludGVyY2VwdGVkVmFsdWUiLCIkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkN2QxNWI2NGNmNWEzYTRjNCIsIm1pbiIsIkluZmluaXR5IiwibWF4IiwibmV3VmFsdWUiLCJNYXRoIiwiJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGNiNmUwYmI1MGJjMTk0NjMiLCJzdGVwIiwiTnVtYmVyIiwicmVtYWluZGVyIiwiaXNOYU4iLCJzbmFwcGVkVmFsdWUiLCJhYnMiLCJzaWduIiwiZmxvb3IiLCJzdHJpbmciLCJ0b1N0cmluZyIsImluZGV4IiwiaW5kZXhPZiIsInByZWNpc2lvbiIsImxlbmd0aCIsInBvdyIsInJvdW5kIiwiJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGI2MjY4NTU0ZmJhNDUxZiIsImRpZ2l0cyIsImJhc2UiLCJ1c2VDb250cm9sbGVkU3RhdGUiLCJjbGFtcCIsInNuYXBWYWx1ZVRvU3RlcCIsInRvRml4ZWROdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/virtualizer/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Layout: () => (/* binding */ $c74cda7d31af1253$export$c84671f46d6a1ca),\n/* harmony export */   LayoutInfo: () => (/* binding */ $d7fd61009c21d0bb$export$7e0eeb9da702a085),\n/* harmony export */   Point: () => (/* binding */ $3041db3296945e6e$export$baf26146a414f24a),\n/* harmony export */   Rect: () => (/* binding */ $60423f92c7f9ad87$export$c79fc6492f3af13d),\n/* harmony export */   ReusableView: () => (/* binding */ $ad1d98aa8f0c31b4$export$1a5223887c560441),\n/* harmony export */   Size: () => (/* binding */ $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec),\n/* harmony export */   useVirtualizerState: () => (/* binding */ $fc0b13b484ac1194$export$1505db82fe357e65)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-stately/virtualizer/node_modules/@react-aria/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $c74cda7d31af1253$export$c84671f46d6a1ca {\n    /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */ shouldInvalidate(newRect, oldRect) {\n        // By default, invalidate when the size changes\n        return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n    }\n    /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */ validate(invalidationContext) {}\n    /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */ // getDragTarget(point: Point): DragTarget | null {\n    //   let target = this.virtualizer.keyAtPoint(point);\n    //   if (!target) {\n    //     return null;\n    //   }\n    //   return {\n    //     type: 'item',\n    //     key: target\n    //   };\n    // }\n    /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */ // getDropTarget(point: Point): DropTarget | null {\n    //   return null;\n    // }\n    /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */ getInitialLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n    /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */ getFinalLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $d7fd61009c21d0bb$export$7e0eeb9da702a085 {\n    /**\n   * Returns a copy of the LayoutInfo.\n   */ copy() {\n        let res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n        res.estimatedSize = this.estimatedSize;\n        res.opacity = this.opacity;\n        res.transform = this.transform;\n        res.parentKey = this.parentKey;\n        res.isSticky = this.isSticky;\n        res.zIndex = this.zIndex;\n        res.allowOverflow = this.allowOverflow;\n        return res;\n    }\n    /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */ constructor(type, key, rect){\n        this.type = type;\n        this.key = key;\n        this.parentKey = null;\n        this.rect = rect;\n        this.estimatedSize = false;\n        this.isSticky = false;\n        this.opacity = 1;\n        this.transform = null;\n        this.zIndex = 0;\n        this.allowOverflow = false;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $3041db3296945e6e$export$baf26146a414f24a {\n    /**\n   * Returns a copy of this point.\n   */ copy() {\n        return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n   * Checks if two points are equal.\n   */ equals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    /**\n   * Returns true if this point is the origin.\n   */ isOrigin() {\n        return this.x === 0 && this.y === 0;\n    }\n    constructor(x = 0, y = 0){\n        this.x = x;\n        this.y = y;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $60423f92c7f9ad87$export$c79fc6492f3af13d {\n    /**\n   * The maximum x-coordinate in the rectangle.\n   */ get maxX() {\n        return this.x + this.width;\n    }\n    /**\n   * The maximum y-coordinate in the rectangle.\n   */ get maxY() {\n        return this.y + this.height;\n    }\n    /**\n   * The area of the rectangle.\n   */ get area() {\n        return this.width * this.height;\n    }\n    /**\n   * The top left corner of the rectangle.\n   */ get topLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);\n    }\n    /**\n   * The top right corner of the rectangle.\n   */ get topRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);\n    }\n    /**\n   * The bottom left corner of the rectangle.\n   */ get bottomLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);\n    }\n    /**\n   * The bottom right corner of the rectangle.\n   */ get bottomRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);\n    }\n    /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */ intersects(rect) {\n        return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n    }\n    /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */ containsRect(rect) {\n        return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n    }\n    /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */ containsPoint(point) {\n        return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n    }\n    /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */ getCornerInRect(rect) {\n        for (let key of [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]){\n            if (rect.containsPoint(this[key])) return key;\n        }\n        return null;\n    }\n    equals(rect) {\n        return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n    pointEquals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    sizeEquals(size) {\n        return this.width === size.width && this.height === size.height;\n    }\n    /**\n   * Returns the union of this Rect and another.\n   */ union(other) {\n        let x = Math.min(this.x, other.x);\n        let y = Math.min(this.y, other.y);\n        let width = Math.max(this.maxX, other.maxX) - x;\n        let height = Math.max(this.maxY, other.maxY) - y;\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, width, height);\n    }\n    /**\n   * Returns the intersection of this Rect with another.\n   * If the rectangles do not intersect, an all zero Rect is returned.\n   */ intersection(other) {\n        if (!this.intersects(other)) return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);\n        let x = Math.max(this.x, other.x);\n        let y = Math.max(this.y, other.y);\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);\n    }\n    /**\n   * Returns a copy of this rectangle.\n   */ copy() {\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n    }\n    constructor(x = 0, y = 0, width = 0, height = 0){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {\n    /**\n   * Returns a copy of this size.\n   */ copy() {\n        return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n    }\n    /**\n   * Returns whether this size is equal to another one.\n   */ equals(other) {\n        return this.width === other.width && this.height === other.height;\n    }\n    /**\n   * The total area of the Size.\n   */ get area() {\n        return this.width * this.height;\n    }\n    constructor(width = 0, height = 0){\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $ad1d98aa8f0c31b4$var$KEY = 0;\nclass $ad1d98aa8f0c31b4$export$1a5223887c560441 {\n    /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */ prepareForReuse() {\n        this.content = null;\n        this.rendered = null;\n        this.layoutInfo = null;\n    }\n    constructor(virtualizer){\n        this.virtualizer = virtualizer;\n        this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // use high res timer if available\nlet $3eb131dcf37ad5f8$var$perf =  false ? 0 : null;\n// @ts-ignore\nlet $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nlet $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function() {\n    return Date.now ? Date.now() : new Date().getTime();\n};\nlet $3eb131dcf37ad5f8$var$fixTs;\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n    let canceled = false;\n    let raf_id;\n    let promise = new Promise((resolve)=>{\n        let start = $3eb131dcf37ad5f8$var$getTime();\n        let diffX = end.x - begin.x;\n        let diffY = end.y - begin.y;\n        raf_id = requestAnimationFrame(function run(t) {\n            // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n            // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n            if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;\n            if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime();\n            // check if we're done\n            let delta = t - start;\n            if (delta > duration) {\n                fn(end);\n                resolve();\n            } else {\n                // call frame callback after computing eased time and get the next frame\n                let proceed = fn(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n                if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n            }\n        });\n    });\n    promise.cancel = function() {\n        canceled = true;\n        cancelAnimationFrame(raf_id);\n    };\n    return promise;\n}\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n    return t;\n}\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n    return Math.sin(t * Math.PI / 2);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n    let res = new Set();\n    for (let key of a.keys())if (!b.has(key)) res.add(key);\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n    let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n    let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n    let toUpdate = new Set;\n    for (let key of a.keys())if (b.has(key)) toUpdate.add(key);\n    return {\n        toRemove: toRemove,\n        toAdd: toAdd,\n        toUpdate: toUpdate\n    };\n}\nfunction* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {\n    for (let iterator of iterators)yield* iterator;\n}\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n    let res = {};\n    for(let key in object)res[object[key]] = key;\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n    if (a === b) return true;\n    if (a.size !== b.size) return false;\n    for (let key of a){\n        if (!b.has(key)) return false;\n    }\n    return true;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $364191b3decf3697$var$RollingAverage {\n    addSample(sample) {\n        this.count++;\n        this.value += (sample - this.value) / this.count;\n    }\n    constructor(){\n        this.count = 0;\n        this.value = 0;\n    }\n}\nclass $364191b3decf3697$export$4455ee6afb38dcbb {\n    setVisibleRect(rect) {\n        let time = performance.now() - this.startTime;\n        if (time < 500) {\n            this.averageTime.addSample(time);\n            if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n            if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n        }\n        this.startTime = performance.now();\n        this.visibleRect = rect;\n    }\n    collectMetrics() {\n        let time = performance.now() - this.startTime;\n        if (time < 500) this.averagePerf.addSample(time);\n        if (this.visibleRect.height > 0) {\n            let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n            this.overscanY.addSample(o);\n        }\n        if (this.visibleRect.width > 0) {\n            let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n            this.overscanX.addSample(o);\n        }\n    }\n    getOverscannedRect() {\n        let overscanned = this.visibleRect.copy();\n        let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n        if (this.velocity.y > 0) {\n            overscanned.y -= overscanY * 0.2;\n            overscanned.height += overscanY + overscanY * 0.2;\n        } else {\n            overscanned.y -= overscanY;\n            overscanned.height += overscanY + overscanY * 0.2;\n        }\n        let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n        if (this.velocity.x > 0) {\n            overscanned.x -= overscanX * 0.2;\n            overscanned.width += overscanX + overscanX * 0.2;\n        } else {\n            overscanned.x -= overscanX;\n            overscanned.width += overscanX + overscanX * 0.2;\n        }\n        return overscanned;\n    }\n    constructor(){\n        this.startTime = 0;\n        this.averagePerf = new $364191b3decf3697$var$RollingAverage();\n        this.averageTime = new $364191b3decf3697$var$RollingAverage();\n        this.velocity = new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5);\n        this.overscanX = new $364191b3decf3697$var$RollingAverage();\n        this.overscanY = new $364191b3decf3697$var$RollingAverage();\n        this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $8e135e531d8dcb66$export$febc5573c75cefb0 {\n    constructor(){\n        this.level = 0;\n        this.actions = [];\n        this.animated = true;\n        this.initialMap = new Map();\n        this.finalMap = new Map();\n        this.initialLayoutInfo = new Map();\n        this.finalLayoutInfo = new Map();\n        this.removed = new Map();\n        this.toRemove = new Map();\n    }\n}\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n    _setContentSize(size) {\n        this._contentSize = size;\n        this.delegate.setContentSize(size);\n    }\n    _setContentOffset(offset) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n        this.delegate.setVisibleRect(rect);\n    }\n    /**\n   * Get the size of the scrollable content.\n   */ get contentSize() {\n        return this._contentSize;\n    }\n    /**\n   * Get the collection view's currently visible rectangle.\n   */ get visibleRect() {\n        return this._visibleRect;\n    }\n    /**\n   * Set the collection view's currently visible rectangle.\n   */ set visibleRect(rect) {\n        this._setVisibleRect(rect);\n    }\n    _setVisibleRect(rect, forceUpdate = false) {\n        let current = this._visibleRect;\n        // Ignore if the rects are equal\n        if (rect.equals(current)) return;\n        if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n        let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n        this._resetAnimatedContentOffset();\n        this._visibleRect = rect;\n        if (shouldInvalidate) this.relayoutNow({\n            offsetChanged: !rect.pointEquals(current),\n            sizeChanged: !rect.sizeEquals(current)\n        });\n        else this.updateSubviews(forceUpdate);\n    }\n    get collection() {\n        return this._collection;\n    }\n    set collection(data) {\n        this._setData(data);\n    }\n    _setData(data) {\n        if (data === this._collection) return;\n        if (this._collection) this._runTransaction(()=>{\n            this._collection = data;\n        }, this.transitionDuration > 0);\n        else {\n            this._collection = data;\n            this.reloadData();\n        }\n    }\n    /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */ reloadData() {\n        this.relayout({\n            contentChanged: true\n        });\n    }\n    /**\n   * Returns the item with the given key.\n   */ getItem(key) {\n        return this._collection ? this._collection.getItem(key) : null;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ get persistedKeys() {\n        return this._persistedKeys;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ set persistedKeys(persistedKeys) {\n        if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n            this._persistedKeys = persistedKeys;\n            this.updateSubviews();\n        }\n    }\n    /** Returns whether the given key, or an ancestor, is persisted. */ isPersistedKey(key) {\n        // Quick check if the key is directly in the set of persisted keys.\n        if (this._persistedKeys.has(key)) return true;\n        // If not, check if the key is an ancestor of any of the persisted keys.\n        for (let k of this._persistedKeys)while(k != null){\n            let layoutInfo = this.layout.getLayoutInfo(k);\n            if (!layoutInfo) break;\n            k = layoutInfo.parentKey;\n            if (k === key) return true;\n        }\n        return false;\n    }\n    /**\n   * Get the collection view's layout.\n   */ get layout() {\n        return this._layout;\n    }\n    /**\n   * Set the collection view's layout.\n   */ set layout(layout) {\n        this.setLayout(layout);\n    }\n    /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */ setLayout(layout, animated = false) {\n        if (layout === this._layout) return;\n        let applyLayout = ()=>{\n            if (this._layout) this._layout.virtualizer = null;\n            layout.virtualizer = this;\n            this._layout = layout;\n        };\n        if (animated) // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);\n        else {\n            applyLayout();\n            this.relayout();\n        }\n    }\n    _getReuseType(layoutInfo, content) {\n        if (layoutInfo.type === \"item\" && content) {\n            let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n            let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n            return {\n                type: type,\n                reuseType: reuseType\n            };\n        }\n        return {\n            type: layoutInfo.type,\n            reuseType: layoutInfo.type\n        };\n    }\n    getReusableView(layoutInfo) {\n        let content = this.getItem(layoutInfo.key);\n        let { reuseType: reuseType } = this._getReuseType(layoutInfo, content);\n        if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n        let reusable = this._reusableViews[reuseType];\n        let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n        view.viewType = reuseType;\n        if (!this._animatedContentOffset.isOrigin()) {\n            layoutInfo = layoutInfo.copy();\n            layoutInfo.rect.x += this._animatedContentOffset.x;\n            layoutInfo.rect.y += this._animatedContentOffset.y;\n        }\n        view.layoutInfo = layoutInfo;\n        this._renderView(view);\n        return view;\n    }\n    _renderView(reusableView) {\n        let { type: type, key: key } = reusableView.layoutInfo;\n        reusableView.content = this.getItem(key);\n        reusableView.rendered = this._renderContent(type, reusableView.content);\n    }\n    _renderContent(type, content) {\n        let cached = this._renderedContent.get(content);\n        if (cached != null) return cached;\n        let rendered = this.delegate.renderView(type, content);\n        if (content) this._renderedContent.set(content, rendered);\n        return rendered;\n    }\n    /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */ get visibleViews() {\n        return Array.from(this._visibleViews.values());\n    }\n    /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */ getView(key) {\n        return this._visibleViews.get(key) || null;\n    }\n    /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */ getViewsOfType(type) {\n        return this.visibleViews.filter((v)=>v.layoutInfo && v.layoutInfo.type === type);\n    }\n    /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */ keyForView(view) {\n        if (view && view.layoutInfo) return view.layoutInfo.key;\n        return null;\n    }\n    /**\n   * Returns the key for the item view currently at the given point.\n   */ keyAtPoint(point) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        // Layout may return multiple layout infos in the case of\n        // persisted keys, so find the first one that actually intersects.\n        for (let layoutInfo of layoutInfos){\n            if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n        }\n        return null;\n    }\n    /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */ willUnmount() {\n        cancelAnimationFrame(this._relayoutRaf);\n    }\n    /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */ relayout(context = {}) {\n        // Ignore relayouts while animating the scroll position\n        if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return;\n        // If we already scheduled a relayout, extend the invalidation\n        // context so we coalesce multiple relayouts in the same frame.\n        if (this._invalidationContext) {\n            Object.assign(this._invalidationContext, context);\n            return;\n        }\n        this._invalidationContext = context;\n    }\n    /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */ relayoutNow(context = this._invalidationContext || {}) {\n        // Cancel the scheduled relayout, since we're doing it now.\n        if (this._relayoutRaf) {\n            cancelAnimationFrame(this._relayoutRaf);\n            this._relayoutRaf = null;\n            // Update the provided context with the current invalidationContext since we are cancelling\n            // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n            context = {\n                ...this._invalidationContext,\n                ...context\n            };\n        }\n        // Reset the invalidation context\n        this._invalidationContext = null;\n        // Do nothing if we don't have a layout or content, or we are\n        // in the middle of an animated scroll transition.\n        if (!this.layout || !this._collection || this._scrollAnimation) return;\n        let scrollAnchor = this._getScrollAnchor();\n        // Trigger the beforeLayout hook, if provided\n        if (typeof context.beforeLayout === \"function\") context.beforeLayout();\n        // Validate the layout\n        this.layout.validate(context);\n        this._setContentSize(this.layout.getContentSize());\n        // Trigger the afterLayout hook, if provided\n        if (typeof context.afterLayout === \"function\") context.afterLayout();\n        // Adjust scroll position based on scroll anchor, and constrain.\n        // If the content changed, scroll to the top.\n        let visibleRect = this.getVisibleRect();\n        let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n        let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n        let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n        contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n        contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n        let hasLayoutUpdates = false;\n        if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n            // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n            // Save the difference between the current and new content offsets, and apply it to the\n            // individual content items instead. At the end of the animation, we'll reset and set the\n            // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n            // the scroll animation and the content animation.\n            if (context.animated || !this._animatedContentOffset.isOrigin()) {\n                this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n                this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n                hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n            } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n        } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n        // Apply layout infos, unless this is coming from an animated transaction\n        if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n        // Wait for animations, and apply the afterAnimation hook, if provided\n        if (context.animated && hasLayoutUpdates) {\n            this._enableTransitions();\n            let done = ()=>{\n                this._disableTransitions();\n                // Reset scroll position after animations (see above comment).\n                if (!this._animatedContentOffset.isOrigin()) {\n                    // Get the content offset to scroll to, taking _animatedContentOffset into account.\n                    let { x: x, y: y } = this.getVisibleRect();\n                    this._resetAnimatedContentOffset();\n                    this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n                }\n                if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n            };\n            // Sometimes the animation takes slightly longer than expected.\n            setTimeout(done, this.transitionDuration + 100);\n            return;\n        } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n    }\n    /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */ _correctItemOrder() {\n        // Defer until after scrolling and animated transactions are complete\n        if (this._isScrolling || this._transaction) return;\n        for (let key of this._visibleLayoutInfos.keys()){\n            let view = this._visibleViews.get(key);\n            this._children.delete(view);\n            this._children.add(view);\n        }\n    }\n    _enableTransitions() {\n        this.delegate.beginAnimations();\n    }\n    _disableTransitions() {\n        this.delegate.endAnimations();\n    }\n    _getScrollAnchor() {\n        if (!this.anchorScrollPosition) return null;\n        let visibleRect = this.getVisibleRect();\n        // Ask the delegate to provide a scroll anchor, if possible\n        if (this.delegate.getScrollAnchor) {\n            let key = this.delegate.getScrollAnchor(visibleRect);\n            if (key != null) {\n                let layoutInfo = this.layout.getLayoutInfo(key);\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let key = layoutInfo.key;\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    return {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        // No need to anchor the scroll position if it is at the top\n        if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n        // Find a view with a visible corner that has the smallest distance to the top of the collection view\n        let cornerAnchor = null;\n        for (let [key, view] of this._visibleViews){\n            let layoutInfo = view.layoutInfo;\n            if (layoutInfo && layoutInfo.rect.area > 0) {\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        return cornerAnchor;\n    }\n    _restoreScrollAnchor(scrollAnchor, context) {\n        let contentOffset = this.getVisibleRect();\n        if (scrollAnchor) {\n            var _context_transaction;\n            let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n            if (finalAnchor) {\n                let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n                contentOffset.y += adjustment;\n            }\n        }\n        return contentOffset;\n    }\n    getVisibleRect() {\n        let v = this.visibleRect;\n        let x = v.x - this._animatedContentOffset.x;\n        let y = v.y - this._animatedContentOffset.y;\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n    }\n    getVisibleLayoutInfos() {\n        let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n        this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n        return this._visibleLayoutInfos;\n    }\n    _getLayoutInfoMap(rect, copy = false) {\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        let map = new Map;\n        for (let layoutInfo of layoutInfos){\n            if (copy) layoutInfo = layoutInfo.copy();\n            map.set(layoutInfo.key, layoutInfo);\n        }\n        return map;\n    }\n    updateSubviews(forceUpdate = false) {\n        if (!this._collection) return;\n        let visibleLayoutInfos = this.getVisibleLayoutInfos();\n        let currentlyVisible = this._visibleViews;\n        let toAdd, toRemove, toUpdate;\n        // If this is a force update, remove and re-add all views.\n        // Otherwise, find and update the diff.\n        if (forceUpdate) {\n            toAdd = visibleLayoutInfos;\n            toRemove = currentlyVisible;\n            toUpdate = new Set();\n        } else {\n            ({ toAdd: toAdd, toRemove: toRemove, toUpdate: toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n            for (let key of toUpdate){\n                let view = currentlyVisible.get(key);\n                if (!view || !view.layoutInfo) continue;\n                let item = this.getItem(visibleLayoutInfos.get(key).key);\n                if (view.content === item) toUpdate.delete(key);\n                else {\n                    // If the view type changes, delete and recreate the view instead of updating\n                    let { reuseType: reuseType } = this._getReuseType(view.layoutInfo, item);\n                    if (view.viewType !== reuseType) {\n                        toUpdate.delete(key);\n                        toAdd.add(key);\n                        toRemove.add(key);\n                    }\n                }\n            }\n            // We are done if the sets are equal\n            if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n                if (this._transaction) this._applyLayoutInfos();\n                return;\n            }\n        }\n        // Track views that should be removed. They are not removed from\n        // the DOM immediately, since we may reuse and need to re-insert\n        // them back into the DOM anyway.\n        let removed = new Set();\n        for (let key of toRemove.keys()){\n            let view = this._visibleViews.get(key);\n            if (view) {\n                removed.add(view);\n                this._visibleViews.delete(key);\n                // If we are in the middle of a transaction, wait until the end\n                // of the animations to remove the views from the DOM. Also means\n                // we can't reuse those views immediately.\n                if (this._transaction) this._transaction.toRemove.set(key, view);\n                else this.reuseView(view);\n            }\n        }\n        for (let key of toAdd.keys()){\n            let layoutInfo = visibleLayoutInfos.get(key);\n            let view;\n            // If we're in a transaction, and a layout change happens\n            // during the animations such that a view that was going\n            // to be removed is now not, we don't create a new view\n            // since the old one is still in the DOM, marked as toRemove.\n            if (this._transaction) {\n                // if transaction, get initial layout attributes for the animation\n                if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);\n                view = this._transaction.toRemove.get(key);\n                if (view) {\n                    this._transaction.toRemove.delete(key);\n                    this._applyLayoutInfo(view, layoutInfo);\n                }\n            }\n            if (!view) {\n                // Create or reuse a view for this row\n                view = this.getReusableView(layoutInfo);\n                // Add the view to the DOM if needed\n                if (!removed.has(view)) this._children.add(view);\n            }\n            this._visibleViews.set(key, view);\n            removed.delete(view);\n        }\n        for (let key of toUpdate){\n            let view = currentlyVisible.get(key);\n            this._renderedContent.delete(key);\n            this._renderView(view);\n        }\n        // Remove the remaining rows to delete from the DOM\n        if (!this._transaction) this.removeViews(removed);\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n        if (hasLayoutUpdates) requestAnimationFrame(()=>{\n            // If we're in a transaction, apply animations to visible views\n            // and \"to be removed\" views, which animate off screen.\n            if (this._transaction) requestAnimationFrame(()=>this._applyLayoutInfos());\n        });\n        return hasLayoutUpdates;\n    }\n    afterRender() {\n        if (this._transactionQueue.length > 0) this._processTransactionQueue();\n        else if (this._invalidationContext) this.relayoutNow();\n        if (this.shouldOverscan) this._overscanManager.collectMetrics();\n    }\n    _flushVisibleViews() {\n        // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent hierarchy\n        // by referencing a parentKey. Just before rendering the visible views, we rebuild this hierarchy\n        // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n        // method to build the final tree.\n        let viewsByParentKey = new Map([\n            [\n                null,\n                []\n            ]\n        ]);\n        for (let view of this._children){\n            var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n            if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n            (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n            if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n        }\n        let buildTree = (parent, views)=>views.map((view)=>{\n                let children = viewsByParentKey.get(view.layoutInfo.key);\n                return this.delegate.renderWrapper(parent, view, children, (childViews)=>buildTree(view, childViews));\n            });\n        let children = buildTree(null, viewsByParentKey.get(null));\n        this.delegate.setVisibleViews(children);\n    }\n    _applyLayoutInfo(view, layoutInfo) {\n        if (view.layoutInfo === layoutInfo) return false;\n        view.layoutInfo = layoutInfo;\n        return true;\n    }\n    _applyLayoutInfos() {\n        let updated = false;\n        // Apply layout infos to visible views\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        // Apply final layout infos for views that will be removed\n        if (this._transaction) {\n            for (let view of this._transaction.toRemove.values()){\n                let cur = view.layoutInfo;\n                if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                    let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                    if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n                }\n            }\n            for (let view of this._transaction.removed.values()){\n                let cur = view.layoutInfo;\n                let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n                layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        if (updated) this._flushVisibleViews();\n    }\n    _hasLayoutUpdates() {\n        if (!this._transaction) return false;\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if (!cur) return true;\n            let layoutInfo = this.layout.getLayoutInfo(cur.key);\n            if (!cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n        }\n        return false;\n    }\n    reuseView(view) {\n        view.prepareForReuse();\n        this._reusableViews[view.viewType].push(view);\n    }\n    removeViews(toRemove) {\n        for (let view of toRemove)this._children.delete(view);\n    }\n    updateItemSize(key, size) {\n        // TODO: we should be able to invalidate a single index path\n        // @ts-ignore\n        if (!this.layout.updateItemSize) return;\n        // If the scroll position is currently animating, add the update\n        // to a queue to be processed after the animation is complete.\n        if (this._scrollAnimation) {\n            this._sizeUpdateQueue.set(key, size);\n            return;\n        }\n        // @ts-ignore\n        let changed = this.layout.updateItemSize(key, size);\n        if (changed) this.relayout();\n    }\n    startScrolling() {\n        this._isScrolling = true;\n    }\n    endScrolling() {\n        this._isScrolling = false;\n        this._correctItemOrder();\n        this._flushVisibleViews();\n    }\n    _resetAnimatedContentOffset() {\n        // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n        if (!this._animatedContentOffset.isOrigin()) {\n            this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n            this._applyLayoutInfos();\n        }\n    }\n    /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */ scrollToItem(key, options) {\n        // key can be 0, so check if null or undefined\n        if (key == null) return;\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        if (!layoutInfo) return;\n        let { duration: duration = 300, shouldScrollX: shouldScrollX = true, shouldScrollY: shouldScrollY = true, offsetX: offsetX = 0, offsetY: offsetY = 0 } = options;\n        let x = this.visibleRect.x;\n        let y = this.visibleRect.y;\n        let minX = layoutInfo.rect.x - offsetX;\n        let minY = layoutInfo.rect.y - offsetY;\n        let maxX = x + this.visibleRect.width;\n        let maxY = y + this.visibleRect.height;\n        if (shouldScrollX) {\n            if (minX <= x || maxX === 0) x = minX;\n            else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n        }\n        if (shouldScrollY) {\n            if (minY <= y || maxY === 0) y = minY;\n            else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n        }\n        return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n    }\n    /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */ scrollTo(offset, duration = 300) {\n        // Cancel the current scroll animation\n        if (this._scrollAnimation) {\n            this._scrollAnimation.cancel();\n            this._scrollAnimation = null;\n        }\n        // Set the content offset synchronously if the duration is zero\n        if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n            this._setContentOffset(offset);\n            return Promise.resolve();\n        }\n        this.startScrolling();\n        this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset)=>{\n            this._setContentOffset(offset);\n        });\n        this._scrollAnimation.then(()=>{\n            this._scrollAnimation = null;\n            // Process view size updates that occurred during the animation.\n            // Only views that are still visible will be actually updated.\n            for (let [key, size] of this._sizeUpdateQueue)this.updateItemSize(key, size);\n            this._sizeUpdateQueue.clear();\n            this.relayout();\n            this._processTransactionQueue();\n            this.endScrolling();\n        });\n        return this._scrollAnimation;\n    }\n    _runTransaction(action, animated) {\n        this._startTransaction();\n        if (this._nextTransaction) this._nextTransaction.actions.push(action);\n        this._endTransaction(animated);\n    }\n    _startTransaction() {\n        if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0);\n        this._nextTransaction.level++;\n    }\n    _endTransaction(animated) {\n        if (!this._nextTransaction) return false;\n        // Save whether the transaction should be animated.\n        if (animated != null) this._nextTransaction.animated = animated;\n        // If we haven't reached level 0, we are still in a\n        // nested transaction. Wait for the parent to end.\n        if (--this._nextTransaction.level > 0) return false;\n        // Do nothing for empty transactions\n        if (this._nextTransaction.actions.length === 0) {\n            this._nextTransaction = null;\n            return false;\n        }\n        // Default animations to true\n        if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n        // Enqueue the transaction\n        this._transactionQueue.push(this._nextTransaction);\n        this._nextTransaction = null;\n        return true;\n    }\n    _processTransactionQueue() {\n        // If the current transaction is animating, wait until the end\n        // to process the next transaction.\n        if (this._transaction || this._scrollAnimation) return;\n        let next = this._transactionQueue.shift();\n        if (next) this._performTransaction(next);\n    }\n    _getContentRect() {\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n    _performTransaction(transaction) {\n        this._transaction = transaction;\n        this.relayoutNow({\n            transaction: transaction,\n            animated: transaction.animated,\n            beforeLayout: ()=>{\n                // Get the initial layout infos for all views before the updates\n                // so we can figure out which views to add and remove.\n                if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n                // Apply the actions that occurred during this transaction\n                for (let action of transaction.actions)action();\n            },\n            afterLayout: ()=>{\n                // Get the final layout infos after the updates\n                if (transaction.animated) {\n                    transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n                    this._setupTransactionAnimations(transaction);\n                } else this._transaction = null;\n            },\n            afterAnimation: ()=>{\n                // Remove and reuse views when animations are done\n                if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())){\n                    this._children.delete(view);\n                    this.reuseView(view);\n                }\n                this._transaction = null;\n                // Ensure DOM order is correct for accessibility after animations are complete\n                this._correctItemOrder();\n                this._flushVisibleViews();\n                this._processTransactionQueue();\n            }\n        });\n    }\n    _setupTransactionAnimations(transaction) {\n        let { initialMap: initialMap, finalMap: finalMap } = transaction;\n        // Store initial and final layout infos for animations\n        for (let [key, layoutInfo] of initialMap)if (finalMap.has(key)) transaction.initialLayoutInfo.set(key, layoutInfo);\n        else // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n        // Get initial layout infos for views that were added\n        for (let [key, layoutInfo] of finalMap)if (!initialMap.has(key)) {\n            let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n            transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n        }\n        // Figure out which views were removed.\n        for (let [key, view] of this._visibleViews)// Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n        // added, removed... etc in a loop.\n        if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n            transaction.removed.set(key, view);\n            this._visibleViews.delete(key);\n            // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n            if (view.layoutInfo) {\n                if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n            }\n        }\n    }\n    constructor(options = {}){\n        this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n        this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d);\n        this._reusableViews = {};\n        this._visibleLayoutInfos = new Map();\n        this._visibleViews = new Map();\n        this._renderedContent = new WeakMap();\n        this._children = new Set();\n        this._invalidationContext = null;\n        this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n        this._persistedKeys = new Set();\n        this._scrollAnimation = null;\n        this._isScrolling = false;\n        this._sizeUpdateQueue = new Map();\n        this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n        this._transaction = null;\n        this._nextTransaction = null;\n        this._transactionQueue = [];\n        var _options_transitionDuration;\n        // Set options from passed object if given\n        this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n        this.anchorScrollPosition = options.anchorScrollPosition || false;\n        this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n        this.shouldOverscan = options.shouldOverscan !== false;\n        for (let key of [\n            \"delegate\",\n            \"size\",\n            \"layout\",\n            \"collection\"\n        ])if (options[key]) this[key] = options[key];\n    }\n}\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n    let [visibleViews, setVisibleViews] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let [contentSize, setContentSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());\n    let [isAnimating, setAnimating] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isScrolling, setScrolling] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let virtualizer = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);\n    virtualizer.delegate = {\n        setVisibleViews: setVisibleViews,\n        setVisibleRect (rect) {\n            virtualizer.visibleRect = rect;\n            opts.onVisibleRectChange(rect);\n        },\n        setContentSize: setContentSize,\n        renderView: opts.renderView,\n        renderWrapper: opts.renderWrapper,\n        beginAnimations: ()=>setAnimating(true),\n        endAnimations: ()=>setAnimating(false),\n        getScrollAnchor: opts.getScrollAnchor\n    };\n    virtualizer.layout = opts.layout;\n    virtualizer.collection = opts.collection;\n    virtualizer.transitionDuration = opts.transitionDuration;\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        virtualizer.afterRender();\n    });\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>virtualizer.willUnmount();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let setVisibleRect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rect)=>{\n        virtualizer.visibleRect = rect;\n    }, [\n        virtualizer\n    ]);\n    let startScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.startScrolling();\n        setScrolling(true);\n    }, [\n        virtualizer\n    ]);\n    let endScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.endScrolling();\n        setScrolling(false);\n    }, [\n        virtualizer\n    ]);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            virtualizer: virtualizer,\n            visibleViews: visibleViews,\n            setVisibleRect: setVisibleRect,\n            contentSize: contentSize,\n            isAnimating: isAnimating,\n            isScrolling: isScrolling,\n            startScrolling: startScrolling,\n            endScrolling: endScrolling\n        }), [\n        virtualizer,\n        visibleViews,\n        setVisibleRect,\n        contentSize,\n        isAnimating,\n        isScrolling,\n        startScrolling,\n        endScrolling\n    ]);\n    return state;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErSTtBQUNuRTtBQUU1RTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHLE1BQU1VO0lBQ047Ozs7O0dBS0QsR0FBR0MsaUJBQWlCQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUNqQywrQ0FBK0M7UUFDL0MsT0FBT0QsUUFBUUUsS0FBSyxLQUFLRCxRQUFRQyxLQUFLLElBQUlGLFFBQVFHLE1BQU0sS0FBS0YsUUFBUUUsTUFBTTtJQUMvRTtJQUNBOzs7OztHQUtELEdBQUdDLFNBQVNDLG1CQUFtQixFQUFFLENBQUM7SUFDakM7Ozs7R0FJRCxHQUFHLG1EQUFtRDtJQUNyRCxxREFBcUQ7SUFDckQsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQixNQUFNO0lBQ04sYUFBYTtJQUNiLG9CQUFvQjtJQUNwQixrQkFBa0I7SUFDbEIsT0FBTztJQUNQLElBQUk7SUFDSjs7OztHQUlELEdBQUcsbURBQW1EO0lBQ3JELGlCQUFpQjtJQUNqQixJQUFJO0lBQ0o7Ozs7OztHQU1ELEdBQUdDLHFCQUFxQkMsVUFBVSxFQUFFO1FBQy9CLE9BQU9BO0lBQ1g7SUFDQTs7Ozs7O0dBTUQsR0FBR0MsbUJBQW1CRCxVQUFVLEVBQUU7UUFDN0IsT0FBT0E7SUFDWDtBQUNKO0FBR0E7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLE1BQU1FO0lBQ047O0dBRUQsR0FBR0MsT0FBTztRQUNMLElBQUlDLE1BQU0sSUFBSUYsMENBQTBDLElBQUksQ0FBQ0csSUFBSSxFQUFFLElBQUksQ0FBQ0MsR0FBRyxFQUFFLElBQUksQ0FBQ0MsSUFBSSxDQUFDSixJQUFJO1FBQzNGQyxJQUFJSSxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhO1FBQ3RDSixJQUFJSyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPO1FBQzFCTCxJQUFJTSxTQUFT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LDhDQUFpQixFQUFHLENBQUNtQjtRQUMxQzBDLFlBQVlrRSxXQUFXLEdBQUc1RztJQUM5QixHQUFHO1FBQ0MwQztLQUNIO0lBQ0QsSUFBSXVPLGlCQUFpQixDQUFDLEdBQUdwUyw4Q0FBaUIsRUFBRztRQUN6QzZELFlBQVl1TyxjQUFjO1FBQzFCNkIsYUFBYTtJQUNqQixHQUFHO1FBQ0NwUTtLQUNIO0lBQ0QsSUFBSXdPLGVBQWUsQ0FBQyxHQUFHclMsOENBQWlCLEVBQUc7UUFDdkM2RCxZQUFZd08sWUFBWTtRQUN4QjRCLGFBQWE7SUFDakIsR0FBRztRQUNDcFE7S0FDSDtJQUNELElBQUlzUSxRQUFRLENBQUMsR0FBR3ZVLDBDQUFhLEVBQUcsSUFBSztZQUM3QmlFLGFBQWFBO1lBQ2JnSixjQUFjQTtZQUNkbEYsZ0JBQWdCQTtZQUNoQmlDLGFBQWFBO1lBQ2JrSyxhQUFhQTtZQUNiRSxhQUFhQTtZQUNiNUIsZ0JBQWdCQTtZQUNoQkMsY0FBY0E7UUFDbEIsSUFBSTtRQUNKeE87UUFDQWdKO1FBQ0FsRjtRQUNBaUM7UUFDQWtLO1FBQ0FFO1FBQ0E1QjtRQUNBQztLQUNIO0lBQ0QsT0FBTzhCO0FBQ1g7QUFLNFksQ0FDNVksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvZGlzdC9pbXBvcnQubWpzP2U5YTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VTdGF0ZSBhcyAkOEQzbnIkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDhEM25yJHVzZU1lbW8sIHVzZUVmZmVjdCBhcyAkOEQzbnIkdXNlRWZmZWN0LCB1c2VDYWxsYmFjayBhcyAkOEQzbnIkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VMYXlvdXRFZmZlY3QgYXMgJDhEM25yJHVzZUxheW91dEVmZmVjdH0gZnJvbSBcIkByZWFjdC1hcmlhL3V0aWxzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJGM3NGNkYTdkMzFhZjEyNTMkZXhwb3J0JGM4NDY3MWY0NmQ2YTFjYSB7XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBpbnZhbGlkYXRlIGluIHJlc3BvbnNlIHRvXG4gICAqIHZpc2libGUgcmVjdGFuZ2xlIGNoYW5nZXMuIEJ5IGRlZmF1bHQsIGl0IG9ubHkgaW52YWxpZGF0ZXNcbiAgICogd2hlbiB0aGUgY29sbGVjdGlvbiB2aWV3J3Mgc2l6ZSBjaGFuZ2VzLiBSZXR1cm4gdHJ1ZSBhbHdheXNcbiAgICogdG8gbWFrZSB0aGUgbGF5b3V0IGludmFsaWRhdGUgd2hpbGUgc2Nyb2xsaW5nIChlLmcuIHN0aWNreSBoZWFkZXJzKS5cbiAgICovIHNob3VsZEludmFsaWRhdGUobmV3UmVjdCwgb2xkUmVjdCkge1xuICAgICAgICAvLyBCeSBkZWZhdWx0LCBpbnZhbGlkYXRlIHdoZW4gdGhlIHNpemUgY2hhbmdlc1xuICAgICAgICByZXR1cm4gbmV3UmVjdC53aWR0aCAhPT0gb2xkUmVjdC53aWR0aCB8fCBuZXdSZWN0LmhlaWdodCAhPT0gb2xkUmVjdC5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgdGhlIGxheW91dCB0byBwZXJmb3JtIGFueSBwcmUtY29tcHV0YXRpb25cbiAgICogaXQgbmVlZHMgdG8gaW4gb3JkZXIgdG8gcHJlcGFyZSB7QGxpbmsgTGF5b3V0SW5mb31zIGZvciByZXRyaWV2YWwuXG4gICAqIENhbGxlZCBieSB0aGUgY29sbGVjdGlvbiB2aWV3IGJlZm9yZSB7QGxpbmsgZ2V0VmlzaWJsZUxheW91dEluZm9zfVxuICAgKiBvciB7QGxpbmsgZ2V0TGF5b3V0SW5mb30gYXJlIGNhbGxlZC5cbiAgICovIHZhbGlkYXRlKGludmFsaWRhdGlvbkNvbnRleHQpIHt9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSB7QGxpbmsgRHJhZ1RhcmdldH0gZGVzY3JpYmluZyBhIHZpZXcgYXQgdGhlIGdpdmVuIHBvaW50IHRvIGJlIGRyYWdnZWQuXG4gICAqIFJldHVybiBgbnVsbGAgdG8gY2FuY2VsIHRoZSBkcmFnLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIHRoZSB2aWV3IGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCBhdCB3aGljaCB0aGUgZHJhZyBvY2N1cnJlZC5cbiAgICovIC8vIGdldERyYWdUYXJnZXQocG9pbnQ6IFBvaW50KTogRHJhZ1RhcmdldCB8IG51bGwge1xuICAgIC8vICAgbGV0IHRhcmdldCA9IHRoaXMudmlydHVhbGl6ZXIua2V5QXRQb2ludChwb2ludCk7XG4gICAgLy8gICBpZiAoIXRhcmdldCkge1xuICAgIC8vICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiB7XG4gICAgLy8gICAgIHR5cGU6ICdpdGVtJyxcbiAgICAvLyAgICAga2V5OiB0YXJnZXRcbiAgICAvLyAgIH07XG4gICAgLy8gfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEge0BsaW5rIERyYWdUYXJnZXR9IG9iamVjdCBkZXNjcmliaW5nIHdoZXJlIGEgZHJvcCBzaG91bGQgb2NjdXIuIFJldHVybiBgbnVsbGBcbiAgICogdG8gcmVqZWN0IHRoZSBkcm9wLiBUaGUgZHJvcHBlZCBpdGVtcyB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSB0aGUgcmVzdWx0aW5nIHRhcmdldC5cbiAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCBhdCB3aGljaCB0aGUgZHJvcCBvY2N1cnJlZC5cbiAgICovIC8vIGdldERyb3BUYXJnZXQocG9pbnQ6IFBvaW50KTogRHJvcFRhcmdldCB8IG51bGwge1xuICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgLy8gfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGFydGluZyBhdHRyaWJ1dGVzIGZvciBhbiBhbmltYXRlZCBpbnNlcnRpb24uXG4gICAqIFRoZSB2aWV3IGlzIGFuaW1hdGVkIGZyb20gdGhpcyB7QGxpbmsgTGF5b3V0SW5mb30gdG8gdGhlIG9uZSByZXR1cm5lZCBieSB7QGxpbmsgZ2V0TGF5b3V0SW5mb30uXG4gICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJucyBpdHMgaW5wdXQuXG4gICAqXG4gICAqIEBwYXJhbSBsYXlvdXRJbmZvIFRoZSBwcm9wb3NlZCBMYXlvdXRJbmZvIGZvciB0aGlzIHZpZXcuXG4gICAqLyBnZXRJbml0aWFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvKSB7XG4gICAgICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgZW5kaW5nIGF0dHJpYnV0ZXMgZm9yIGFuIGFuaW1hdGVkIHJlbW92YWwuXG4gICAqIFRoZSB2aWV3IGlzIGFuaW1hdGVkIGZyb20gdGhlIHtAbGluayBMYXlvdXRJbmZvfSByZXR1cm5lZCBieSB7QGxpbmsgZ2V0TGF5b3V0SW5mb31cbiAgICogdG8gdGhlIG9uZSByZXR1cm5lZCBieSB0aGlzIG1ldGhvZC4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBpdHMgaW5wdXQuXG4gICAqXG4gICAqIEBwYXJhbSBsYXlvdXRJbmZvIFRoZSBvcmlnaW5hbCBMYXlvdXRJbmZvIGZvciB0aGlzIHZpZXcuXG4gICAqLyBnZXRGaW5hbExheW91dEluZm8obGF5b3V0SW5mbykge1xuICAgICAgICByZXR1cm4gbGF5b3V0SW5mbztcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICRkN2ZkNjEwMDljMjFkMGJiJGV4cG9ydCQ3ZTBlZWI5ZGE3MDJhMDg1IHtcbiAgICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIExheW91dEluZm8uXG4gICAqLyBjb3B5KCkge1xuICAgICAgICBsZXQgcmVzID0gbmV3ICRkN2ZkNjEwMDljMjFkMGJiJGV4cG9ydCQ3ZTBlZWI5ZGE3MDJhMDg1KHRoaXMudHlwZSwgdGhpcy5rZXksIHRoaXMucmVjdC5jb3B5KCkpO1xuICAgICAgICByZXMuZXN0aW1hdGVkU2l6ZSA9IHRoaXMuZXN0aW1hdGVkU2l6ZTtcbiAgICAgICAgcmVzLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgIHJlcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgcmVzLnBhcmVudEtleSA9IHRoaXMucGFyZW50S2V5O1xuICAgICAgICByZXMuaXNTdGlja3kgPSB0aGlzLmlzU3RpY2t5O1xuICAgICAgICByZXMuekluZGV4ID0gdGhpcy56SW5kZXg7XG4gICAgICAgIHJlcy5hbGxvd092ZXJmbG93ID0gdGhpcy5hbGxvd092ZXJmbG93O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICogQHBhcmFtIHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2aWV3IHR5cGUuIFNob3VsZCBiZSBgJ2l0ZW0nYCBmb3IgaXRlbSB2aWV3cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPdGhlciB0eXBlcyBhcmUgdXNlZCBieSBzdXBwbGVtZW50YXJ5IHZpZXdzLlxuICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUga2V5IGZvciB0aGlzIHZpZXcuXG4gICAqIEBwYXJhbSByZWN0IFRoZSByZWN0YW5nbGUgZGVzY3JpYmluZyB0aGUgc2l6ZSBhbmQgcG9zaXRpb24gb2YgdGhpcyB2aWV3LlxuICAgKi8gY29uc3RydWN0b3IodHlwZSwga2V5LCByZWN0KXtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucGFyZW50S2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWN0ID0gcmVjdDtcbiAgICAgICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdGlja3kgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xuICAgICAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYWxsb3dPdmVyZmxvdyA9IGZhbHNlO1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEge1xuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHBvaW50LlxuICAgKi8gY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSh0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDaGVja3MgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWwuXG4gICAqLyBlcXVhbHMocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcG9pbnQueCAmJiB0aGlzLnkgPT09IHBvaW50Lnk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyB0aGUgb3JpZ2luLlxuICAgKi8gaXNPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApe1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jbGFzcyAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCB7XG4gICAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHgtY29vcmRpbmF0ZSBpbiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IG1heFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIG1heGltdW0geS1jb29yZGluYXRlIGluIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgbWF4WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIGFyZWEgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCBhcmVhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IHRvcExlZnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IHRvcFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkodGhpcy5tYXhYLCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IGJvdHRvbUxlZnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLngsIHRoaXMubWF4WSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IGJvdHRvbVJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkodGhpcy5tYXhYLCB0aGlzLm1heFkpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgcmVjdGFuZ2xlIGludGVyc2VjdHMgYW5vdGhlciByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBjaGVjay5cbiAgICovIGludGVyc2VjdHMocmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy54IDw9IHJlY3QueCArIHJlY3Qud2lkdGggJiYgcmVjdC54IDw9IHRoaXMueCArIHRoaXMud2lkdGggJiYgdGhpcy55IDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0ICYmIHJlY3QueSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIHJlY3RhbmdsZSBmdWxseSBjb250YWlucyBhbm90aGVyIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGNoZWNrLlxuICAgKi8gY29udGFpbnNSZWN0KHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA8PSByZWN0LnggJiYgdGhpcy55IDw9IHJlY3QueSAmJiB0aGlzLm1heFggPj0gcmVjdC5tYXhYICYmIHRoaXMubWF4WSA+PSByZWN0Lm1heFk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byBjaGVjay5cbiAgICovIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA8PSBwb2ludC54ICYmIHRoaXMueSA8PSBwb2ludC55ICYmIHRoaXMubWF4WCA+PSBwb2ludC54ICYmIHRoaXMubWF4WSA+PSBwb2ludC55O1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgY29ybmVyIG9mIHRoaXMgcmVjdGFuZ2xlIChmcm9tIHRvcCB0byBib3R0b20sIGxlZnQgdG8gcmlnaHQpXG4gICAqIHRoYXQgaXMgY29udGFpbmVkIGluIHRoZSBnaXZlbiByZWN0YW5nbGUsIG9yIG51bGwgb2YgdGhlIHJlY3RhbmdsZXMgZG8gbm90IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGNoZWNrLlxuICAgKi8gZ2V0Q29ybmVySW5SZWN0KHJlY3QpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIFtcbiAgICAgICAgICAgIFwidG9wTGVmdFwiLFxuICAgICAgICAgICAgXCJ0b3BSaWdodFwiLFxuICAgICAgICAgICAgXCJib3R0b21MZWZ0XCIsXG4gICAgICAgICAgICBcImJvdHRvbVJpZ2h0XCJcbiAgICAgICAgXSl7XG4gICAgICAgICAgICBpZiAocmVjdC5jb250YWluc1BvaW50KHRoaXNba2V5XSkpIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVxdWFscyhyZWN0KSB7XG4gICAgICAgIHJldHVybiByZWN0LnggPT09IHRoaXMueCAmJiByZWN0LnkgPT09IHRoaXMueSAmJiByZWN0LndpZHRoID09PSB0aGlzLndpZHRoICYmIHJlY3QuaGVpZ2h0ID09PSB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgcG9pbnRFcXVhbHMocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcG9pbnQueCAmJiB0aGlzLnkgPT09IHBvaW50Lnk7XG4gICAgfVxuICAgIHNpemVFcXVhbHMoc2l6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gc2l6ZS53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZS5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmlvbiBvZiB0aGlzIFJlY3QgYW5kIGFub3RoZXIuXG4gICAqLyB1bmlvbihvdGhlcikge1xuICAgICAgICBsZXQgeCA9IE1hdGgubWluKHRoaXMueCwgb3RoZXIueCk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5taW4odGhpcy55LCBvdGhlci55KTtcbiAgICAgICAgbGV0IHdpZHRoID0gTWF0aC5tYXgodGhpcy5tYXhYLCBvdGhlci5tYXhYKSAtIHg7XG4gICAgICAgIGxldCBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLm1heFksIG90aGVyLm1heFkpIC0geTtcbiAgICAgICAgcmV0dXJuIG5ldyAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIFJlY3Qgd2l0aCBhbm90aGVyLlxuICAgKiBJZiB0aGUgcmVjdGFuZ2xlcyBkbyBub3QgaW50ZXJzZWN0LCBhbiBhbGwgemVybyBSZWN0IGlzIHJldHVybmVkLlxuICAgKi8gaW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnRlcnNlY3RzKG90aGVyKSkgcmV0dXJuIG5ldyAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCgwLCAwLCAwLCAwKTtcbiAgICAgICAgbGV0IHggPSBNYXRoLm1heCh0aGlzLngsIG90aGVyLngpO1xuICAgICAgICBsZXQgeSA9IE1hdGgubWF4KHRoaXMueSwgb3RoZXIueSk7XG4gICAgICAgIHJldHVybiBuZXcgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QoeCwgeSwgTWF0aC5taW4odGhpcy5tYXhYLCBvdGhlci5tYXhYKSAtIHgsIE1hdGgubWluKHRoaXMubWF4WSwgb3RoZXIubWF4WSkgLSB5KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcmVjdGFuZ2xlLlxuICAgKi8gY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCl7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYyB7XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgc2l6ZS5cbiAgICovIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgc2l6ZSBpcyBlcXVhbCB0byBhbm90aGVyIG9uZS5cbiAgICovIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gb3RoZXIud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IG90aGVyLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSB0b3RhbCBhcmVhIG9mIHRoZSBTaXplLlxuICAgKi8gZ2V0IGFyZWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHdpZHRoID0gMCwgaGVpZ2h0ID0gMCl7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBsZXQgJGFkMWQ5OGFhOGYwYzMxYjQkdmFyJEtFWSA9IDA7XG5jbGFzcyAkYWQxZDk4YWE4ZjBjMzFiNCRleHBvcnQkMWE1MjIzODg3YzU2MDQ0MSB7XG4gICAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSB2aWV3IGZvciByZXVzZS4gQ2FsbGVkIGp1c3QgYmVmb3JlIHRoZSB2aWV3IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICAgKi8gcHJlcGFyZUZvclJldXNlKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXlvdXRJbmZvID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmlydHVhbGl6ZXIpe1xuICAgICAgICB0aGlzLnZpcnR1YWxpemVyID0gdmlydHVhbGl6ZXI7XG4gICAgICAgIHRoaXMua2V5ID0gKyskYWQxZDk4YWE4ZjBjMzFiNCR2YXIkS0VZO1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8vIHVzZSBoaWdoIHJlcyB0aW1lciBpZiBhdmFpbGFibGVcbmxldCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cucGVyZm9ybWFuY2UgOiBudWxsO1xuLy8gQHRzLWlnbm9yZVxubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmTm93ID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYgJiYgKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmLm5vdyB8fCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZi53ZWJraXROb3cgfHwgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYubXNOb3cgfHwgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYubW96Tm93KTtcbmxldCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZ2V0VGltZSA9ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmTm93ID8gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmZOb3cuYmluZCgkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZikgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59O1xubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcztcbmZ1bmN0aW9uICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCRkYzBiNjM3MjA3ODgwOTBjKGJlZ2luLCBlbmQsIGR1cmF0aW9uLCBlYXNlLCBmbikge1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCByYWZfaWQ7XG4gICAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgbGV0IHN0YXJ0ID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUoKTtcbiAgICAgICAgbGV0IGRpZmZYID0gZW5kLnggLSBiZWdpbi54O1xuICAgICAgICBsZXQgZGlmZlkgPSBlbmQueSAtIGJlZ2luLnk7XG4gICAgICAgIHJhZl9pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBydW4odCkge1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgdXNpbmcgYSBoaWdoIHJlcyB0aW1lciwgbWFrZSBzdXJlIHRpbWVzdGFtcCBpcyBub3QgdGhlIG9sZCBlcG9jaC1iYXNlZCB2YWx1ZS5cbiAgICAgICAgICAgIC8vIGh0dHA6Ly91cGRhdGVzLmh0bWw1cm9ja3MuY29tLzIwMTIvMDUvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLUFQSS1ub3ctd2l0aC1zdWItbWlsbGlzZWNvbmQtcHJlY2lzaW9uXG4gICAgICAgICAgICBpZiAoJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzID09IG51bGwpICQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcyA9IHQgPiAxZTEyICE9PSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZ2V0VGltZSgpID4gMWUxMjtcbiAgICAgICAgICAgIGlmICgkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHMpIHQgPSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZ2V0VGltZSgpO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UncmUgZG9uZVxuICAgICAgICAgICAgbGV0IGRlbHRhID0gdCAtIHN0YXJ0O1xuICAgICAgICAgICAgaWYgKGRlbHRhID4gZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBmbihlbmQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCBmcmFtZSBjYWxsYmFjayBhZnRlciBjb21wdXRpbmcgZWFzZWQgdGltZSBhbmQgZ2V0IHRoZSBuZXh0IGZyYW1lXG4gICAgICAgICAgICAgICAgbGV0IHByb2NlZWQgPSBmbihuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKShiZWdpbi54ICsgZGlmZlggKiBlYXNlKGRlbHRhIC8gZHVyYXRpb24pLCBiZWdpbi55ICsgZGlmZlkgKiBlYXNlKGRlbHRhIC8gZHVyYXRpb24pKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2NlZWQgIT09IGZhbHNlICYmICFjYW5jZWxlZCkgcmFmX2lkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJ1bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmX2lkKTtcbiAgICB9O1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDc3ODYwYzEwNmI0YTZhMmUodCkge1xuICAgIHJldHVybiB0O1xufVxuZnVuY3Rpb24gJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDU3NjM2YmI0M2IxY2NiYjAodCkge1xuICAgIHJldHVybiBNYXRoLnNpbih0ICogTWF0aC5QSSAvIDIpO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkMzdhMjZiMjgzZmQ3NzQwZShhLCBiKSB7XG4gICAgbGV0IHJlcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBrZXkgb2YgYS5rZXlzKCkpaWYgKCFiLmhhcyhrZXkpKSByZXMuYWRkKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhY2FmOTZhMjc0MzgyNDZiKGEsIGIpIHtcbiAgICBsZXQgdG9SZW1vdmUgPSAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkMzdhMjZiMjgzZmQ3NzQwZShhLCBiKTtcbiAgICBsZXQgdG9BZGQgPSAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkMzdhMjZiMjgzZmQ3NzQwZShiLCBhKTtcbiAgICBsZXQgdG9VcGRhdGUgPSBuZXcgU2V0O1xuICAgIGZvciAobGV0IGtleSBvZiBhLmtleXMoKSlpZiAoYi5oYXMoa2V5KSkgdG9VcGRhdGUuYWRkKGtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9SZW1vdmU6IHRvUmVtb3ZlLFxuICAgICAgICB0b0FkZDogdG9BZGQsXG4gICAgICAgIHRvVXBkYXRlOiB0b1VwZGF0ZVxuICAgIH07XG59XG5mdW5jdGlvbiogJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGNmYzE0MDg4ZGZlZmNlNWYoLi4uaXRlcmF0b3JzKSB7XG4gICAgZm9yIChsZXQgaXRlcmF0b3Igb2YgaXRlcmF0b3JzKXlpZWxkKiBpdGVyYXRvcjtcbn1cbmZ1bmN0aW9uICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQ2ODk3YzI4NGI2ZjlmNGRjKG9iamVjdCkge1xuICAgIGxldCByZXMgPSB7fTtcbiAgICBmb3IobGV0IGtleSBpbiBvYmplY3QpcmVzW29iamVjdFtrZXldXSA9IGtleTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGE4ZDBkMGM4ZDFjNWRmNjQoYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2YgYSl7XG4gICAgICAgIGlmICghYi5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNsYXNzICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSB7XG4gICAgYWRkU2FtcGxlKHNhbXBsZSkge1xuICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIHRoaXMudmFsdWUgKz0gKHNhbXBsZSAtIHRoaXMudmFsdWUpIC8gdGhpcy5jb3VudDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMudmFsdWUgPSAwO1xuICAgIH1cbn1cbmNsYXNzICQzNjQxOTFiM2RlY2YzNjk3JGV4cG9ydCQ0NDU1ZWU2YWZiMzhkY2JiIHtcbiAgICBzZXRWaXNpYmxlUmVjdChyZWN0KSB7XG4gICAgICAgIGxldCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgaWYgKHRpbWUgPCA1MDApIHtcbiAgICAgICAgICAgIHRoaXMuYXZlcmFnZVRpbWUuYWRkU2FtcGxlKHRpbWUpO1xuICAgICAgICAgICAgaWYgKHJlY3QueCAhPT0gdGhpcy52aXNpYmxlUmVjdC54ICYmIHRpbWUgPiAwKSB0aGlzLnZlbG9jaXR5LnggPSAocmVjdC54IC0gdGhpcy52aXNpYmxlUmVjdC54KSAvIHRpbWU7XG4gICAgICAgICAgICBpZiAocmVjdC55ICE9PSB0aGlzLnZpc2libGVSZWN0LnkgJiYgdGltZSA+IDApIHRoaXMudmVsb2NpdHkueSA9IChyZWN0LnkgLSB0aGlzLnZpc2libGVSZWN0LnkpIC8gdGltZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLnZpc2libGVSZWN0ID0gcmVjdDtcbiAgICB9XG4gICAgY29sbGVjdE1ldHJpY3MoKSB7XG4gICAgICAgIGxldCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgaWYgKHRpbWUgPCA1MDApIHRoaXMuYXZlcmFnZVBlcmYuYWRkU2FtcGxlKHRpbWUpO1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlUmVjdC5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbyA9IE1hdGguYWJzKHRoaXMudmVsb2NpdHkueSAqICh0aGlzLmF2ZXJhZ2VUaW1lLnZhbHVlICsgdGhpcy5hdmVyYWdlUGVyZi52YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5vdmVyc2NhblkuYWRkU2FtcGxlKG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc2libGVSZWN0LndpZHRoID4gMCkge1xuICAgICAgICAgICAgbGV0IG8gPSBNYXRoLmFicyh0aGlzLnZlbG9jaXR5LnggKiAodGhpcy5hdmVyYWdlVGltZS52YWx1ZSArIHRoaXMuYXZlcmFnZVBlcmYudmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcnNjYW5YLmFkZFNhbXBsZShvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRPdmVyc2Nhbm5lZFJlY3QoKSB7XG4gICAgICAgIGxldCBvdmVyc2Nhbm5lZCA9IHRoaXMudmlzaWJsZVJlY3QuY29weSgpO1xuICAgICAgICBsZXQgb3ZlcnNjYW5ZID0gTWF0aC5yb3VuZChNYXRoLm1pbih0aGlzLnZpc2libGVSZWN0LmhlaWdodCAqIDIsIHRoaXMub3ZlcnNjYW5ZLnZhbHVlKSAvIDEwMCkgKiAxMDA7XG4gICAgICAgIGlmICh0aGlzLnZlbG9jaXR5LnkgPiAwKSB7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC55IC09IG92ZXJzY2FuWSAqIDAuMjtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLmhlaWdodCArPSBvdmVyc2NhblkgKyBvdmVyc2NhblkgKiAwLjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC55IC09IG92ZXJzY2FuWTtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLmhlaWdodCArPSBvdmVyc2NhblkgKyBvdmVyc2NhblkgKiAwLjI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG92ZXJzY2FuWCA9IE1hdGgucm91bmQoTWF0aC5taW4odGhpcy52aXNpYmxlUmVjdC53aWR0aCAqIDIsIHRoaXMub3ZlcnNjYW5YLnZhbHVlKSAvIDEwMCkgKiAxMDA7XG4gICAgICAgIGlmICh0aGlzLnZlbG9jaXR5LnggPiAwKSB7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC54IC09IG92ZXJzY2FuWCAqIDAuMjtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLndpZHRoICs9IG92ZXJzY2FuWCArIG92ZXJzY2FuWCAqIDAuMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnggLT0gb3ZlcnNjYW5YO1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQud2lkdGggKz0gb3ZlcnNjYW5YICsgb3ZlcnNjYW5YICogMC4yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdmVyc2Nhbm5lZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmF2ZXJhZ2VQZXJmID0gbmV3ICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSgpO1xuICAgICAgICB0aGlzLmF2ZXJhZ2VUaW1lID0gbmV3ICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSgpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoNSwgNSk7XG4gICAgICAgIHRoaXMub3ZlcnNjYW5YID0gbmV3ICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSgpO1xuICAgICAgICB0aGlzLm92ZXJzY2FuWSA9IG5ldyAkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2UoKTtcbiAgICAgICAgdGhpcy52aXNpYmxlUmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKCk7XG4gICAgfVxufVxuXG5cblxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICQ4ZTEzNWU1MzFkOGRjYjY2JGV4cG9ydCRmZWJjNTU3M2M3NWNlZmIwIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmxldmVsID0gMDtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmluaXRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZmluYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbExheW91dEluZm8gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZmluYWxMYXlvdXRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudG9SZW1vdmUgPSBuZXcgTWFwKCk7XG4gICAgfVxufVxuXG5cbmNsYXNzICQzOGI5NDkwYzFjY2E4ZmM0JGV4cG9ydCQ4OWJlNWEyNDNlNTljNGIyIHtcbiAgICBfc2V0Q29udGVudFNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLl9jb250ZW50U2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0Q29udGVudFNpemUoc2l6ZSk7XG4gICAgfVxuICAgIF9zZXRDb250ZW50T2Zmc2V0KG9mZnNldCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKG9mZnNldC54LCBvZmZzZXQueSwgdGhpcy5fdmlzaWJsZVJlY3Qud2lkdGgsIHRoaXMuX3Zpc2libGVSZWN0LmhlaWdodCk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0VmlzaWJsZVJlY3QocmVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgY29udGVudC5cbiAgICovIGdldCBjb250ZW50U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICogR2V0IHRoZSBjb2xsZWN0aW9uIHZpZXcncyBjdXJyZW50bHkgdmlzaWJsZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgdmlzaWJsZVJlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlUmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldCB0aGUgY29sbGVjdGlvbiB2aWV3J3MgY3VycmVudGx5IHZpc2libGUgcmVjdGFuZ2xlLlxuICAgKi8gc2V0IHZpc2libGVSZWN0KHJlY3QpIHtcbiAgICAgICAgdGhpcy5fc2V0VmlzaWJsZVJlY3QocmVjdCk7XG4gICAgfVxuICAgIF9zZXRWaXNpYmxlUmVjdChyZWN0LCBmb3JjZVVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5fdmlzaWJsZVJlY3Q7XG4gICAgICAgIC8vIElnbm9yZSBpZiB0aGUgcmVjdHMgYXJlIGVxdWFsXG4gICAgICAgIGlmIChyZWN0LmVxdWFscyhjdXJyZW50KSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRPdmVyc2NhbikgdGhpcy5fb3ZlcnNjYW5NYW5hZ2VyLnNldFZpc2libGVSZWN0KHJlY3QpO1xuICAgICAgICBsZXQgc2hvdWxkSW52YWxpZGF0ZSA9IHRoaXMubGF5b3V0ICYmIHRoaXMubGF5b3V0LnNob3VsZEludmFsaWRhdGUocmVjdCwgdGhpcy5fdmlzaWJsZVJlY3QpO1xuICAgICAgICB0aGlzLl9yZXNldEFuaW1hdGVkQ29udGVudE9mZnNldCgpO1xuICAgICAgICB0aGlzLl92aXNpYmxlUmVjdCA9IHJlY3Q7XG4gICAgICAgIGlmIChzaG91bGRJbnZhbGlkYXRlKSAvLyBXZSBhcmUgYWxyZWFkeSBpbiBhIGxheW91dCBlZmZlY3Qgd2hlbiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHNvIHJlbGF5b3V0Tm93IGlzIGFwcHJvcHJpYXRlLlxuICAgICAgICB0aGlzLnJlbGF5b3V0Tm93KHtcbiAgICAgICAgICAgIG9mZnNldENoYW5nZWQ6ICFyZWN0LnBvaW50RXF1YWxzKGN1cnJlbnQpLFxuICAgICAgICAgICAgc2l6ZUNoYW5nZWQ6ICFyZWN0LnNpemVFcXVhbHMoY3VycmVudClcbiAgICAgICAgfSk7XG4gICAgICAgIGVsc2UgdGhpcy51cGRhdGVTdWJ2aWV3cyhmb3JjZVVwZGF0ZSk7XG4gICAgfVxuICAgIGdldCBjb2xsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbjtcbiAgICB9XG4gICAgc2V0IGNvbGxlY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLl9zZXREYXRhKGRhdGEpO1xuICAgIH1cbiAgICBfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB0aGlzLl9jb2xsZWN0aW9uKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uKSB0aGlzLl9ydW5UcmFuc2FjdGlvbigoKT0+e1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IGRhdGE7XG4gICAgICAgIH0sIHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uID4gMCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZERhdGEoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICogUmVsb2FkcyB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhIHNvdXJjZSBhbmQgcmVsYXlvdXRzIHRoZSBjb2xsZWN0aW9uIHZpZXcuXG4gICAqIERvZXMgbm90IGFuaW1hdGUgYW55IGNoYW5nZXMuIEVxdWl2YWxlbnQgdG8gcmUtYXNzaWduaW5nIHRoZSBzYW1lIGRhdGEgc291cmNlXG4gICAqIHRvIHRoZSBjb2xsZWN0aW9uIHZpZXcuXG4gICAqLyByZWxvYWREYXRhKCkge1xuICAgICAgICB0aGlzLnJlbGF5b3V0KHtcbiAgICAgICAgICAgIGNvbnRlbnRDaGFuZ2VkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlbSB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gICAqLyBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbiA/IHRoaXMuX2NvbGxlY3Rpb24uZ2V0SXRlbShrZXkpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqIFRoZSBzZXQgb2YgcGVyc2lzdGVkIGtleXMgYXJlIGFsd2F5cyBwcmVzZW50IGluIHRoZSBET00sIGV2ZW4gaWYgbm90IGN1cnJlbnRseSBpbiB2aWV3LiAqLyBnZXQgcGVyc2lzdGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlcnNpc3RlZEtleXM7XG4gICAgfVxuICAgIC8qKiBUaGUgc2V0IG9mIHBlcnNpc3RlZCBrZXlzIGFyZSBhbHdheXMgcHJlc2VudCBpbiB0aGUgRE9NLCBldmVuIGlmIG5vdCBjdXJyZW50bHkgaW4gdmlldy4gKi8gc2V0IHBlcnNpc3RlZEtleXMocGVyc2lzdGVkS2V5cykge1xuICAgICAgICBpZiAoISgwLCAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYThkMGQwYzhkMWM1ZGY2NCkocGVyc2lzdGVkS2V5cywgdGhpcy5fcGVyc2lzdGVkS2V5cykpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcnNpc3RlZEtleXMgPSBwZXJzaXN0ZWRLZXlzO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdWJ2aWV3cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGtleSwgb3IgYW4gYW5jZXN0b3IsIGlzIHBlcnNpc3RlZC4gKi8gaXNQZXJzaXN0ZWRLZXkoa2V5KSB7XG4gICAgICAgIC8vIFF1aWNrIGNoZWNrIGlmIHRoZSBrZXkgaXMgZGlyZWN0bHkgaW4gdGhlIHNldCBvZiBwZXJzaXN0ZWQga2V5cy5cbiAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlZEtleXMuaGFzKGtleSkpIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBJZiBub3QsIGNoZWNrIGlmIHRoZSBrZXkgaXMgYW4gYW5jZXN0b3Igb2YgYW55IG9mIHRoZSBwZXJzaXN0ZWQga2V5cy5cbiAgICAgICAgZm9yIChsZXQgayBvZiB0aGlzLl9wZXJzaXN0ZWRLZXlzKXdoaWxlKGsgIT0gbnVsbCl7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oayk7XG4gICAgICAgICAgICBpZiAoIWxheW91dEluZm8pIGJyZWFrO1xuICAgICAgICAgICAgayA9IGxheW91dEluZm8ucGFyZW50S2V5O1xuICAgICAgICAgICAgaWYgKGsgPT09IGtleSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICogR2V0IHRoZSBjb2xsZWN0aW9uIHZpZXcncyBsYXlvdXQuXG4gICAqLyBnZXQgbGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0O1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0IHRoZSBjb2xsZWN0aW9uIHZpZXcncyBsYXlvdXQuXG4gICAqLyBzZXQgbGF5b3V0KGxheW91dCkge1xuICAgICAgICB0aGlzLnNldExheW91dChsYXlvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0cyB0aGUgY29sbGVjdGlvbiB2aWV3J3MgbGF5b3V0LCBvcHRpb25hbGx5IHdpdGggYW4gYW5pbWF0ZWQgdHJhbnNpdGlvblxuICAgKiBmcm9tIHRoZSBjdXJyZW50IGxheW91dCB0byB0aGUgbmV3IGxheW91dC5cbiAgICogQHBhcmFtIGxheW91dCBUaGUgbGF5b3V0IHRvIHN3aXRjaCB0by5cbiAgICogQHBhcmFtIGFuaW1hdGVkIFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgbGF5b3V0IGNoYW5nZS5cbiAgICovIHNldExheW91dChsYXlvdXQsIGFuaW1hdGVkID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gdGhpcy5fbGF5b3V0KSByZXR1cm47XG4gICAgICAgIGxldCBhcHBseUxheW91dCA9ICgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5fbGF5b3V0KSAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQudmlydHVhbGl6ZXIgPSBudWxsO1xuICAgICAgICAgICAgbGF5b3V0LnZpcnR1YWxpemVyID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2xheW91dCA9IGxheW91dDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFuaW1hdGVkKSAvLyBBbmltYXRlZCBsYXlvdXQgdHJhbnNpdGlvbnMgYXJlIHJlYWxseSBzaW1wbGUsIHRoYW5rcyB0byBvdXIgdHJhbnNhY3Rpb24gc3VwcG9ydC5cbiAgICAgICAgLy8gV2UganVzdCBzZXQgdGhlIGxheW91dCBpbnNpZGUgYSB0cmFuc2FjdGlvbiBhY3Rpb24sIHdoaWNoIHJ1bnMgYWZ0ZXIgdGhlIGluaXRpYWxcbiAgICAgICAgLy8gbGF5b3V0IGluZm9zIGZvciB0aGUgYW5pbWF0aW9uIGFyZSByZXRyaWV2ZWQgZnJvbSB0aGUgcHJldmlvdXMgbGF5b3V0LiBUaGVuLCB0aGVcbiAgICAgICAgLy8gZmluYWwgbGF5b3V0IGluZm9zIGFyZSByZXRyaWV2ZWQgZnJvbSB0aGUgbmV3IGxheW91dCwgYW5kIGFuaW1hdGlvbnMgb2NjdXIuXG4gICAgICAgIHRoaXMuX3J1blRyYW5zYWN0aW9uKGFwcGx5TGF5b3V0KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcHBseUxheW91dCgpO1xuICAgICAgICAgICAgdGhpcy5yZWxheW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRSZXVzZVR5cGUobGF5b3V0SW5mbywgY29udGVudCkge1xuICAgICAgICBpZiAobGF5b3V0SW5mby50eXBlID09PSBcIml0ZW1cIiAmJiBjb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMuZGVsZWdhdGUuZ2V0VHlwZSA/IHRoaXMuZGVsZWdhdGUuZ2V0VHlwZShjb250ZW50KSA6IFwiaXRlbVwiO1xuICAgICAgICAgICAgbGV0IHJldXNlVHlwZSA9IHR5cGUgPT09IFwiaXRlbVwiID8gXCJpdGVtXCIgOiBsYXlvdXRJbmZvLnR5cGUgKyBcIl9cIiArIHR5cGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgcmV1c2VUeXBlOiByZXVzZVR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGxheW91dEluZm8udHlwZSxcbiAgICAgICAgICAgIHJldXNlVHlwZTogbGF5b3V0SW5mby50eXBlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFJldXNhYmxlVmlldyhsYXlvdXRJbmZvKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5nZXRJdGVtKGxheW91dEluZm8ua2V5KTtcbiAgICAgICAgbGV0IHsgcmV1c2VUeXBlOiByZXVzZVR5cGUgfSA9IHRoaXMuX2dldFJldXNlVHlwZShsYXlvdXRJbmZvLCBjb250ZW50KTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXVzYWJsZVZpZXdzW3JldXNlVHlwZV0pIHRoaXMuX3JldXNhYmxlVmlld3NbcmV1c2VUeXBlXSA9IFtdO1xuICAgICAgICBsZXQgcmV1c2FibGUgPSB0aGlzLl9yZXVzYWJsZVZpZXdzW3JldXNlVHlwZV07XG4gICAgICAgIGxldCB2aWV3ID0gcmV1c2FibGUubGVuZ3RoID4gMCA/IHJldXNhYmxlLnBvcCgpIDogbmV3ICgwLCAkYWQxZDk4YWE4ZjBjMzFiNCRleHBvcnQkMWE1MjIzODg3YzU2MDQ0MSkodGhpcyk7XG4gICAgICAgIHZpZXcudmlld1R5cGUgPSByZXVzZVR5cGU7XG4gICAgICAgIGlmICghdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcbiAgICAgICAgICAgIGxheW91dEluZm8gPSBsYXlvdXRJbmZvLmNvcHkoKTtcbiAgICAgICAgICAgIGxheW91dEluZm8ucmVjdC54ICs9IHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC54O1xuICAgICAgICAgICAgbGF5b3V0SW5mby5yZWN0LnkgKz0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lnk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5sYXlvdXRJbmZvID0gbGF5b3V0SW5mbztcbiAgICAgICAgdGhpcy5fcmVuZGVyVmlldyh2aWV3KTtcbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfVxuICAgIF9yZW5kZXJWaWV3KHJldXNhYmxlVmlldykge1xuICAgICAgICBsZXQgeyB0eXBlOiB0eXBlLCBrZXk6IGtleSB9ID0gcmV1c2FibGVWaWV3LmxheW91dEluZm87XG4gICAgICAgIHJldXNhYmxlVmlldy5jb250ZW50ID0gdGhpcy5nZXRJdGVtKGtleSk7XG4gICAgICAgIHJldXNhYmxlVmlldy5yZW5kZXJlZCA9IHRoaXMuX3JlbmRlckNvbnRlbnQodHlwZSwgcmV1c2FibGVWaWV3LmNvbnRlbnQpO1xuICAgIH1cbiAgICBfcmVuZGVyQ29udGVudCh0eXBlLCBjb250ZW50KSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9yZW5kZXJlZENvbnRlbnQuZ2V0KGNvbnRlbnQpO1xuICAgICAgICBpZiAoY2FjaGVkICE9IG51bGwpIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGxldCByZW5kZXJlZCA9IHRoaXMuZGVsZWdhdGUucmVuZGVyVmlldyh0eXBlLCBjb250ZW50KTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHRoaXMuX3JlbmRlcmVkQ29udGVudC5zZXQoY29udGVudCwgcmVuZGVyZWQpO1xuICAgICAgICByZXR1cm4gcmVuZGVyZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBjdXJyZW50bHkgdmlzaWJsZSB2aWV3cywgaW5jbHVkaW5nIGJvdGhcbiAgICogaXRlbSB2aWV3cyBhbmQgc3VwcGxlbWVudGFyeSB2aWV3cy5cbiAgICovIGdldCB2aXNpYmxlVmlld3MoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3Zpc2libGVWaWV3cy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXRzIHRoZSB2aXNpYmxlIHZpZXcgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBrZXkuIFJldHVybnMgbnVsbCBpZlxuICAgKiB0aGUgdmlldyBpcyBub3QgY3VycmVudGx5IHZpc2libGUuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdmlldyB0byByZXRyaWV2ZS5cbiAgICovIGdldFZpZXcoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlVmlld3MuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdmlzaWJsZSB2aWV3cyBtYXRjaGluZyB0aGUgZ2l2ZW4gdHlwZS5cbiAgICogQHBhcmFtIHR5cGUgVGhlIHZpZXcgdHlwZSB0byBmaW5kLlxuICAgKi8gZ2V0Vmlld3NPZlR5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlVmlld3MuZmlsdGVyKCh2KT0+di5sYXlvdXRJbmZvICYmIHYubGF5b3V0SW5mby50eXBlID09PSB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleSBmb3IgdGhlIGdpdmVuIHZpZXcuIFJldHVybnMgbnVsbFxuICAgKiBpZiB0aGUgdmlldyBpcyBub3QgY3VycmVudGx5IHZpc2libGUuXG4gICAqLyBrZXlGb3JWaWV3KHZpZXcpIHtcbiAgICAgICAgaWYgKHZpZXcgJiYgdmlldy5sYXlvdXRJbmZvKSByZXR1cm4gdmlldy5sYXlvdXRJbmZvLmtleTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXkgZm9yIHRoZSBpdGVtIHZpZXcgY3VycmVudGx5IGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICovIGtleUF0UG9pbnQocG9pbnQpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKShwb2ludC54LCBwb2ludC55LCAxLCAxKTtcbiAgICAgICAgbGV0IGxheW91dEluZm9zID0gdGhpcy5sYXlvdXQuZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpO1xuICAgICAgICAvLyBMYXlvdXQgbWF5IHJldHVybiBtdWx0aXBsZSBsYXlvdXQgaW5mb3MgaW4gdGhlIGNhc2Ugb2ZcbiAgICAgICAgLy8gcGVyc2lzdGVkIGtleXMsIHNvIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGFjdHVhbGx5IGludGVyc2VjdHMuXG4gICAgICAgIGZvciAobGV0IGxheW91dEluZm8gb2YgbGF5b3V0SW5mb3Mpe1xuICAgICAgICAgICAgaWYgKGxheW91dEluZm8ucmVjdC5pbnRlcnNlY3RzKHJlY3QpKSByZXR1cm4gbGF5b3V0SW5mby5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDbGVhbnVwIGZvciB3aGVuIHRoZSBWaXJ0dWFsaXplciB3aWxsIGJlIHVubW91bnRlZC5cbiAgICovIHdpbGxVbm1vdW50KCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZWxheW91dFJhZik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUcmlnZ2VycyBhIGxheW91dCBpbnZhbGlkYXRpb24sIGFuZCB1cGRhdGVzIHRoZSB2aXNpYmxlIHN1YnZpZXdzLlxuICAgKi8gcmVsYXlvdXQoY29udGV4dCA9IHt9KSB7XG4gICAgICAgIC8vIElnbm9yZSByZWxheW91dHMgd2hpbGUgYW5pbWF0aW5nIHRoZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbEFuaW1hdGlvbiB8fCB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgc2NoZWR1bGVkIGEgcmVsYXlvdXQsIGV4dGVuZCB0aGUgaW52YWxpZGF0aW9uXG4gICAgICAgIC8vIGNvbnRleHQgc28gd2UgY29hbGVzY2UgbXVsdGlwbGUgcmVsYXlvdXRzIGluIHRoZSBzYW1lIGZyYW1lLlxuICAgICAgICBpZiAodGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0LCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgcmVsYXlvdXQgaW1tZWRpYXRlbHkuIFByZWZlciB7QGxpbmsgcmVsYXlvdXR9IG92ZXIgdGhpcyBtZXRob2RcbiAgICogd2hlcmUgcG9zc2libGUsIHNpbmNlIGl0IGNvYWxlc2NlcyBtdWx0aXBsZSBsYXlvdXQgcGFzc2VzIGluIHRoZSBzYW1lIHRpY2suXG4gICAqLyByZWxheW91dE5vdyhjb250ZXh0ID0gdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCB8fCB7fSkge1xuICAgICAgICAvLyBDYW5jZWwgdGhlIHNjaGVkdWxlZCByZWxheW91dCwgc2luY2Ugd2UncmUgZG9pbmcgaXQgbm93LlxuICAgICAgICBpZiAodGhpcy5fcmVsYXlvdXRSYWYpIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbGF5b3V0UmFmKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbGF5b3V0UmFmID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvdmlkZWQgY29udGV4dCB3aXRoIHRoZSBjdXJyZW50IGludmFsaWRhdGlvbkNvbnRleHQgc2luY2Ugd2UgYXJlIGNhbmNlbGxpbmdcbiAgICAgICAgICAgIC8vIGEgc2NoZWR1bGVkIHJlbGF5b3V0Tm93IGNhbGwgdGhhdCBoYXMgdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCBzZXQgYXMgaXRzIGRlZmF1bHQgY29udGV4dCBhcmcgKHJlbGF5b3V0Tm93KCkgaW4gcmVsYXlvdXQpXG4gICAgICAgICAgICBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQsXG4gICAgICAgICAgICAgICAgLi4uY29udGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgaW52YWxpZGF0aW9uIGNvbnRleHRcbiAgICAgICAgdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCA9IG51bGw7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgd2UgZG9uJ3QgaGF2ZSBhIGxheW91dCBvciBjb250ZW50LCBvciB3ZSBhcmVcbiAgICAgICAgLy8gaW4gdGhlIG1pZGRsZSBvZiBhbiBhbmltYXRlZCBzY3JvbGwgdHJhbnNpdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLmxheW91dCB8fCAhdGhpcy5fY29sbGVjdGlvbiB8fCB0aGlzLl9zY3JvbGxBbmltYXRpb24pIHJldHVybjtcbiAgICAgICAgbGV0IHNjcm9sbEFuY2hvciA9IHRoaXMuX2dldFNjcm9sbEFuY2hvcigpO1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBiZWZvcmVMYXlvdXQgaG9vaywgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmJlZm9yZUxheW91dCA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0LmJlZm9yZUxheW91dCgpO1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgbGF5b3V0XG4gICAgICAgIHRoaXMubGF5b3V0LnZhbGlkYXRlKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9zZXRDb250ZW50U2l6ZSh0aGlzLmxheW91dC5nZXRDb250ZW50U2l6ZSgpKTtcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgYWZ0ZXJMYXlvdXQgaG9vaywgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmFmdGVyTGF5b3V0ID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYWZ0ZXJMYXlvdXQoKTtcbiAgICAgICAgLy8gQWRqdXN0IHNjcm9sbCBwb3NpdGlvbiBiYXNlZCBvbiBzY3JvbGwgYW5jaG9yLCBhbmQgY29uc3RyYWluLlxuICAgICAgICAvLyBJZiB0aGUgY29udGVudCBjaGFuZ2VkLCBzY3JvbGwgdG8gdGhlIHRvcC5cbiAgICAgICAgbGV0IHZpc2libGVSZWN0ID0gdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICBsZXQgcmVzdG9yZWRTY3JvbGxBbmNob3IgPSB0aGlzLl9yZXN0b3JlU2Nyb2xsQW5jaG9yKHNjcm9sbEFuY2hvciwgY29udGV4dCk7XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0WCA9IGNvbnRleHQuY29udGVudENoYW5nZWQgPyAwIDogcmVzdG9yZWRTY3JvbGxBbmNob3IueDtcbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXRZID0gY29udGV4dC5jb250ZW50Q2hhbmdlZCA/IDAgOiByZXN0b3JlZFNjcm9sbEFuY2hvci55O1xuICAgICAgICBjb250ZW50T2Zmc2V0WCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuY29udGVudFNpemUud2lkdGggLSB2aXNpYmxlUmVjdC53aWR0aCwgY29udGVudE9mZnNldFgpKTtcbiAgICAgICAgY29udGVudE9mZnNldFkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmNvbnRlbnRTaXplLmhlaWdodCAtIHZpc2libGVSZWN0LmhlaWdodCwgY29udGVudE9mZnNldFkpKTtcbiAgICAgICAgbGV0IGhhc0xheW91dFVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNvbnRlbnRPZmZzZXRYICE9PSB2aXNpYmxlUmVjdC54IHx8IGNvbnRlbnRPZmZzZXRZICE9PSB2aXNpYmxlUmVjdC55KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGFuaW1hdGVkIHJlbGF5b3V0LCB3ZSBkbyBub3QgaW1tZWRpYXRlbHkgc2Nyb2xsIGJlY2F1c2UgaXQgd291bGQgYmUgaml0dGVyeS5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgbmV3IGNvbnRlbnQgb2Zmc2V0cywgYW5kIGFwcGx5IGl0IHRvIHRoZVxuICAgICAgICAgICAgLy8gaW5kaXZpZHVhbCBjb250ZW50IGl0ZW1zIGluc3RlYWQuIEF0IHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvbiwgd2UnbGwgcmVzZXQgYW5kIHNldCB0aGVcbiAgICAgICAgICAgIC8vIHNjcm9sbCBvZmZzZXQgZm9yIHJlYWwuIFRoaXMgZW5zdXJlcyBqaXR0ZXItZnJlZSBhbmltYXRpb24gc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byBzeW5jXG4gICAgICAgICAgICAvLyB0aGUgc2Nyb2xsIGFuaW1hdGlvbiBhbmQgdGhlIGNvbnRlbnQgYW5pbWF0aW9uLlxuICAgICAgICAgICAgaWYgKGNvbnRleHQuYW5pbWF0ZWQgfHwgIXRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC5pc09yaWdpbigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LnggKz0gdmlzaWJsZVJlY3QueCAtIGNvbnRlbnRPZmZzZXRYO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC55ICs9IHZpc2libGVSZWN0LnkgLSBjb250ZW50T2Zmc2V0WTtcbiAgICAgICAgICAgICAgICBoYXNMYXlvdXRVcGRhdGVzID0gdGhpcy51cGRhdGVTdWJ2aWV3cyhjb250ZXh0LmNvbnRlbnRDaGFuZ2VkKTtcbiAgICAgICAgICAgIH0gZWxzZSB0aGlzLl9zZXRDb250ZW50T2Zmc2V0KG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKGNvbnRlbnRPZmZzZXRYLCBjb250ZW50T2Zmc2V0WSkpO1xuICAgICAgICB9IGVsc2UgaGFzTGF5b3V0VXBkYXRlcyA9IHRoaXMudXBkYXRlU3Vidmlld3MoY29udGV4dC5jb250ZW50Q2hhbmdlZCk7XG4gICAgICAgIC8vIEFwcGx5IGxheW91dCBpbmZvcywgdW5sZXNzIHRoaXMgaXMgY29taW5nIGZyb20gYW4gYW5pbWF0ZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgaWYgKCEoY29udGV4dC50cmFuc2FjdGlvbiAmJiBjb250ZXh0LmFuaW1hdGVkKSkgdGhpcy5fYXBwbHlMYXlvdXRJbmZvcygpO1xuICAgICAgICAvLyBXYWl0IGZvciBhbmltYXRpb25zLCBhbmQgYXBwbHkgdGhlIGFmdGVyQW5pbWF0aW9uIGhvb2ssIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmIChjb250ZXh0LmFuaW1hdGVkICYmIGhhc0xheW91dFVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZVRyYW5zaXRpb25zKCk7XG4gICAgICAgICAgICBsZXQgZG9uZSA9ICgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzYWJsZVRyYW5zaXRpb25zKCk7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgc2Nyb2xsIHBvc2l0aW9uIGFmdGVyIGFuaW1hdGlvbnMgKHNlZSBhYm92ZSBjb21tZW50KS5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC5pc09yaWdpbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY29udGVudCBvZmZzZXQgdG8gc2Nyb2xsIHRvLCB0YWtpbmcgX2FuaW1hdGVkQ29udGVudE9mZnNldCBpbnRvIGFjY291bnQuXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHg6IHgsIHk6IHkgfSA9IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRBbmltYXRlZENvbnRlbnRPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudE9mZnNldChuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh4LCB5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5hZnRlckFuaW1hdGlvbiA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0LmFmdGVyQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU29tZXRpbWVzIHRoZSBhbmltYXRpb24gdGFrZXMgc2xpZ2h0bHkgbG9uZ2VyIHRoYW4gZXhwZWN0ZWQuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uICsgMTAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dC5hZnRlckFuaW1hdGlvbiA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0LmFmdGVyQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDb3JyZWN0cyBET00gb3JkZXIgb2YgdmlzaWJsZSB2aWV3cyB0byBtYXRjaCBpdGVtIG9yZGVyIG9mIGNvbGxlY3Rpb24uXG4gICAqLyBfY29ycmVjdEl0ZW1PcmRlcigpIHtcbiAgICAgICAgLy8gRGVmZXIgdW50aWwgYWZ0ZXIgc2Nyb2xsaW5nIGFuZCBhbmltYXRlZCB0cmFuc2FjdGlvbnMgYXJlIGNvbXBsZXRlXG4gICAgICAgIGlmICh0aGlzLl9pc1Njcm9sbGluZyB8fCB0aGlzLl90cmFuc2FjdGlvbikgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5fdmlzaWJsZUxheW91dEluZm9zLmtleXMoKSl7XG4gICAgICAgICAgICBsZXQgdmlldyA9IHRoaXMuX3Zpc2libGVWaWV3cy5nZXQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmRlbGV0ZSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmFkZCh2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW5hYmxlVHJhbnNpdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuYmVnaW5BbmltYXRpb25zKCk7XG4gICAgfVxuICAgIF9kaXNhYmxlVHJhbnNpdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuZW5kQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgICBfZ2V0U2Nyb2xsQW5jaG9yKCkge1xuICAgICAgICBpZiAoIXRoaXMuYW5jaG9yU2Nyb2xsUG9zaXRpb24pIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdmlzaWJsZVJlY3QgPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgIC8vIEFzayB0aGUgZGVsZWdhdGUgdG8gcHJvdmlkZSBhIHNjcm9sbCBhbmNob3IsIGlmIHBvc3NpYmxlXG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmdldFNjcm9sbEFuY2hvcikge1xuICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuZGVsZWdhdGUuZ2V0U2Nyb2xsQW5jaG9yKHZpc2libGVSZWN0KTtcbiAgICAgICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhrZXkpO1xuICAgICAgICAgICAgICAgIGxldCBjb3JuZXIgPSBsYXlvdXRJbmZvLnJlY3QuZ2V0Q29ybmVySW5SZWN0KHZpc2libGVSZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSBsYXlvdXRJbmZvLmtleTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGxheW91dEluZm8ucmVjdFtjb3JuZXJdLnkgLSB2aXNpYmxlUmVjdC55O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVyOiBjb3JuZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBObyBuZWVkIHRvIGFuY2hvciB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlmIGl0IGlzIGF0IHRoZSB0b3BcbiAgICAgICAgaWYgKHZpc2libGVSZWN0LnkgPT09IDAgJiYgIXRoaXMuYW5jaG9yU2Nyb2xsUG9zaXRpb25BdFRvcCkgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEZpbmQgYSB2aWV3IHdpdGggYSB2aXNpYmxlIGNvcm5lciB0aGF0IGhhcyB0aGUgc21hbGxlc3QgZGlzdGFuY2UgdG8gdGhlIHRvcCBvZiB0aGUgY29sbGVjdGlvbiB2aWV3XG4gICAgICAgIGxldCBjb3JuZXJBbmNob3IgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2aWV3XSBvZiB0aGlzLl92aXNpYmxlVmlld3Mpe1xuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB2aWV3LmxheW91dEluZm87XG4gICAgICAgICAgICBpZiAobGF5b3V0SW5mbyAmJiBsYXlvdXRJbmZvLnJlY3QuYXJlYSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgY29ybmVyID0gbGF5b3V0SW5mby5yZWN0LmdldENvcm5lckluUmVjdCh2aXNpYmxlUmVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvcm5lcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gbGF5b3V0SW5mby5yZWN0W2Nvcm5lcl0ueSAtIHZpc2libGVSZWN0Lnk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29ybmVyQW5jaG9yIHx8IG9mZnNldCA8IGNvcm5lckFuY2hvci5vZmZzZXQpIGNvcm5lckFuY2hvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcm5lcjogY29ybmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcm5lckFuY2hvcjtcbiAgICB9XG4gICAgX3Jlc3RvcmVTY3JvbGxBbmNob3Ioc2Nyb2xsQW5jaG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICBpZiAoc2Nyb2xsQW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgX2NvbnRleHRfdHJhbnNhY3Rpb247XG4gICAgICAgICAgICBsZXQgZmluYWxBbmNob3IgPSAoKF9jb250ZXh0X3RyYW5zYWN0aW9uID0gY29udGV4dC50cmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2NvbnRleHRfdHJhbnNhY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb250ZXh0X3RyYW5zYWN0aW9uLmFuaW1hdGVkKSA/IGNvbnRleHQudHJhbnNhY3Rpb24uZmluYWxNYXAuZ2V0KHNjcm9sbEFuY2hvci5rZXkpIDogdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhzY3JvbGxBbmNob3IubGF5b3V0SW5mby5rZXkpO1xuICAgICAgICAgICAgaWYgKGZpbmFsQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFkanVzdG1lbnQgPSBmaW5hbEFuY2hvci5yZWN0W3Njcm9sbEFuY2hvci5jb3JuZXJdLnkgLSBjb250ZW50T2Zmc2V0LnkgLSBzY3JvbGxBbmNob3Iub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQueSArPSBhZGp1c3RtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50T2Zmc2V0O1xuICAgIH1cbiAgICBnZXRWaXNpYmxlUmVjdCgpIHtcbiAgICAgICAgbGV0IHYgPSB0aGlzLnZpc2libGVSZWN0O1xuICAgICAgICBsZXQgeCA9IHYueCAtIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC54O1xuICAgICAgICBsZXQgeSA9IHYueSAtIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC55O1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkoeCwgeSwgdi53aWR0aCwgdi5oZWlnaHQpO1xuICAgIH1cbiAgICBnZXRWaXNpYmxlTGF5b3V0SW5mb3MoKSB7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5zaG91bGRPdmVyc2NhbiA/IHRoaXMuX292ZXJzY2FuTWFuYWdlci5nZXRPdmVyc2Nhbm5lZFJlY3QoKSA6IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZUxheW91dEluZm9zID0gdGhpcy5fZ2V0TGF5b3V0SW5mb01hcChyZWN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVMYXlvdXRJbmZvcztcbiAgICB9XG4gICAgX2dldExheW91dEluZm9NYXAocmVjdCwgY29weSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvcyA9IHRoaXMubGF5b3V0LmdldFZpc2libGVMYXlvdXRJbmZvcyhyZWN0KTtcbiAgICAgICAgbGV0IG1hcCA9IG5ldyBNYXA7XG4gICAgICAgIGZvciAobGV0IGxheW91dEluZm8gb2YgbGF5b3V0SW5mb3Mpe1xuICAgICAgICAgICAgaWYgKGNvcHkpIGxheW91dEluZm8gPSBsYXlvdXRJbmZvLmNvcHkoKTtcbiAgICAgICAgICAgIG1hcC5zZXQobGF5b3V0SW5mby5rZXksIGxheW91dEluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHVwZGF0ZVN1YnZpZXdzKGZvcmNlVXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb2xsZWN0aW9uKSByZXR1cm47XG4gICAgICAgIGxldCB2aXNpYmxlTGF5b3V0SW5mb3MgPSB0aGlzLmdldFZpc2libGVMYXlvdXRJbmZvcygpO1xuICAgICAgICBsZXQgY3VycmVudGx5VmlzaWJsZSA9IHRoaXMuX3Zpc2libGVWaWV3cztcbiAgICAgICAgbGV0IHRvQWRkLCB0b1JlbW92ZSwgdG9VcGRhdGU7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBmb3JjZSB1cGRhdGUsIHJlbW92ZSBhbmQgcmUtYWRkIGFsbCB2aWV3cy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBmaW5kIGFuZCB1cGRhdGUgdGhlIGRpZmYuXG4gICAgICAgIGlmIChmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgdG9BZGQgPSB2aXNpYmxlTGF5b3V0SW5mb3M7XG4gICAgICAgICAgICB0b1JlbW92ZSA9IGN1cnJlbnRseVZpc2libGU7XG4gICAgICAgICAgICB0b1VwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICh7IHRvQWRkOiB0b0FkZCwgdG9SZW1vdmU6IHRvUmVtb3ZlLCB0b1VwZGF0ZTogdG9VcGRhdGUgfSA9ICgwLCAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYWNhZjk2YTI3NDM4MjQ2YikoY3VycmVudGx5VmlzaWJsZSwgdmlzaWJsZUxheW91dEluZm9zKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgdG9VcGRhdGUpe1xuICAgICAgICAgICAgICAgIGxldCB2aWV3ID0gY3VycmVudGx5VmlzaWJsZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcgfHwgIXZpZXcubGF5b3V0SW5mbykgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmdldEl0ZW0odmlzaWJsZUxheW91dEluZm9zLmdldChrZXkpLmtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcuY29udGVudCA9PT0gaXRlbSkgdG9VcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2aWV3IHR5cGUgY2hhbmdlcywgZGVsZXRlIGFuZCByZWNyZWF0ZSB0aGUgdmlldyBpbnN0ZWFkIG9mIHVwZGF0aW5nXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHJldXNlVHlwZTogcmV1c2VUeXBlIH0gPSB0aGlzLl9nZXRSZXVzZVR5cGUodmlldy5sYXlvdXRJbmZvLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcudmlld1R5cGUgIT09IHJldXNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9VcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0FkZC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmVtb3ZlLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgYXJlIGRvbmUgaWYgdGhlIHNldHMgYXJlIGVxdWFsXG4gICAgICAgICAgICBpZiAodG9BZGQuc2l6ZSA9PT0gMCAmJiB0b1JlbW92ZS5zaXplID09PSAwICYmIHRvVXBkYXRlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHRoaXMuX2FwcGx5TGF5b3V0SW5mb3MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhY2sgdmlld3MgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC4gVGhleSBhcmUgbm90IHJlbW92ZWQgZnJvbVxuICAgICAgICAvLyB0aGUgRE9NIGltbWVkaWF0ZWx5LCBzaW5jZSB3ZSBtYXkgcmV1c2UgYW5kIG5lZWQgdG8gcmUtaW5zZXJ0XG4gICAgICAgIC8vIHRoZW0gYmFjayBpbnRvIHRoZSBET00gYW55d2F5LlxuICAgICAgICBsZXQgcmVtb3ZlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRvUmVtb3ZlLmtleXMoKSl7XG4gICAgICAgICAgICBsZXQgdmlldyA9IHRoaXMuX3Zpc2libGVWaWV3cy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZC5hZGQodmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXdzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgdHJhbnNhY3Rpb24sIHdhaXQgdW50aWwgdGhlIGVuZFxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBhbmltYXRpb25zIHRvIHJlbW92ZSB0aGUgdmlld3MgZnJvbSB0aGUgRE9NLiBBbHNvIG1lYW5zXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgcmV1c2UgdGhvc2Ugdmlld3MgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSB0aGlzLl90cmFuc2FjdGlvbi50b1JlbW92ZS5zZXQoa2V5LCB2aWV3KTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMucmV1c2VWaWV3KHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0b0FkZC5rZXlzKCkpe1xuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB2aXNpYmxlTGF5b3V0SW5mb3MuZ2V0KGtleSk7XG4gICAgICAgICAgICBsZXQgdmlldztcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIGEgdHJhbnNhY3Rpb24sIGFuZCBhIGxheW91dCBjaGFuZ2UgaGFwcGVuc1xuICAgICAgICAgICAgLy8gZHVyaW5nIHRoZSBhbmltYXRpb25zIHN1Y2ggdGhhdCBhIHZpZXcgdGhhdCB3YXMgZ29pbmdcbiAgICAgICAgICAgIC8vIHRvIGJlIHJlbW92ZWQgaXMgbm93IG5vdCwgd2UgZG9uJ3QgY3JlYXRlIGEgbmV3IHZpZXdcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBvbGQgb25lIGlzIHN0aWxsIGluIHRoZSBET00sIG1hcmtlZCBhcyB0b1JlbW92ZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRyYW5zYWN0aW9uLCBnZXQgaW5pdGlhbCBsYXlvdXQgYXR0cmlidXRlcyBmb3IgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbi5pbml0aWFsTGF5b3V0SW5mby5oYXMoa2V5KSkgbGF5b3V0SW5mbyA9IHRoaXMuX3RyYW5zYWN0aW9uLmluaXRpYWxMYXlvdXRJbmZvLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIHZpZXcgPSB0aGlzLl90cmFuc2FjdGlvbi50b1JlbW92ZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2FjdGlvbi50b1JlbW92ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlMYXlvdXRJbmZvKHZpZXcsIGxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmlldykge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBvciByZXVzZSBhIHZpZXcgZm9yIHRoaXMgcm93XG4gICAgICAgICAgICAgICAgdmlldyA9IHRoaXMuZ2V0UmV1c2FibGVWaWV3KGxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdmlldyB0byB0aGUgRE9NIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmICghcmVtb3ZlZC5oYXModmlldykpIHRoaXMuX2NoaWxkcmVuLmFkZCh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVWaWV3cy5zZXQoa2V5LCB2aWV3KTtcbiAgICAgICAgICAgIHJlbW92ZWQuZGVsZXRlKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0b1VwZGF0ZSl7XG4gICAgICAgICAgICBsZXQgdmlldyA9IGN1cnJlbnRseVZpc2libGUuZ2V0KGtleSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZENvbnRlbnQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJWaWV3KHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcmVtYWluaW5nIHJvd3MgdG8gZGVsZXRlIGZyb20gdGhlIERPTVxuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSB0aGlzLnJlbW92ZVZpZXdzKHJlbW92ZWQpO1xuICAgICAgICB0aGlzLl9jb3JyZWN0SXRlbU9yZGVyKCk7XG4gICAgICAgIHRoaXMuX2ZsdXNoVmlzaWJsZVZpZXdzKCk7XG4gICAgICAgIGxldCBoYXNMYXlvdXRVcGRhdGVzID0gdGhpcy5fdHJhbnNhY3Rpb24gJiYgKHRvQWRkLnNpemUgPiAwIHx8IHRvUmVtb3ZlLnNpemUgPiAwIHx8IHRoaXMuX2hhc0xheW91dFVwZGF0ZXMoKSk7XG4gICAgICAgIGlmIChoYXNMYXlvdXRVcGRhdGVzKSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIGEgdHJhbnNhY3Rpb24sIGFwcGx5IGFuaW1hdGlvbnMgdG8gdmlzaWJsZSB2aWV3c1xuICAgICAgICAgICAgLy8gYW5kIFwidG8gYmUgcmVtb3ZlZFwiIHZpZXdzLCB3aGljaCBhbmltYXRlIG9mZiBzY3JlZW4uXG4gICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+dGhpcy5fYXBwbHlMYXlvdXRJbmZvcygpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYXNMYXlvdXRVcGRhdGVzO1xuICAgIH1cbiAgICBhZnRlclJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uUXVldWUubGVuZ3RoID4gMCkgdGhpcy5fcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCkgdGhpcy5yZWxheW91dE5vdygpO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRPdmVyc2NhbikgdGhpcy5fb3ZlcnNjYW5NYW5hZ2VyLmNvbGxlY3RNZXRyaWNzKCk7XG4gICAgfVxuICAgIF9mbHVzaFZpc2libGVWaWV3cygpIHtcbiAgICAgICAgLy8gQ29sbGVjdGlvblZpcnR1YWxpemVyIGRlYWxzIHdpdGggYSBmbGF0dGVuZWQgc2V0IG9mIExheW91dEluZm9zLCBidXQgdGhleSBjYW4gcmVwcmVzZW50IGhpZXJhcmNoeVxuICAgICAgICAvLyBieSByZWZlcmVuY2luZyBhIHBhcmVudEtleS4gSnVzdCBiZWZvcmUgcmVuZGVyaW5nIHRoZSB2aXNpYmxlIHZpZXdzLCB3ZSByZWJ1aWxkIHRoaXMgaGllcmFyY2h5XG4gICAgICAgIC8vIGJ5IGNyZWF0aW5nIGEgbWFwcGluZyBvZiB2aWV3cyBieSBwYXJlbnQga2V5IGFuZCByZWN1cnNpdmVseSBjYWxsaW5nIHRoZSBkZWxlZ2F0ZSdzIHJlbmRlcldyYXBwZXJcbiAgICAgICAgLy8gbWV0aG9kIHRvIGJ1aWxkIHRoZSBmaW5hbCB0cmVlLlxuICAgICAgICBsZXQgdmlld3NCeVBhcmVudEtleSA9IG5ldyBNYXAoW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgIF1cbiAgICAgICAgXSk7XG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fY2hpbGRyZW4pe1xuICAgICAgICAgICAgdmFyIF92aWV3X2xheW91dEluZm8sIF92aWV3c0J5UGFyZW50S2V5X2dldCwgX3ZpZXdfbGF5b3V0SW5mbzEsIF92aWV3X2xheW91dEluZm8yLCBfdmlld19sYXlvdXRJbmZvMztcbiAgICAgICAgICAgIGlmICgoKF92aWV3X2xheW91dEluZm8gPSB2aWV3LmxheW91dEluZm8pID09PSBudWxsIHx8IF92aWV3X2xheW91dEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92aWV3X2xheW91dEluZm8ucGFyZW50S2V5KSAhPSBudWxsICYmICF2aWV3c0J5UGFyZW50S2V5Lmhhcyh2aWV3LmxheW91dEluZm8ucGFyZW50S2V5KSkgdmlld3NCeVBhcmVudEtleS5zZXQodmlldy5sYXlvdXRJbmZvLnBhcmVudEtleSwgW10pO1xuICAgICAgICAgICAgKF92aWV3c0J5UGFyZW50S2V5X2dldCA9IHZpZXdzQnlQYXJlbnRLZXkuZ2V0KChfdmlld19sYXlvdXRJbmZvMSA9IHZpZXcubGF5b3V0SW5mbykgPT09IG51bGwgfHwgX3ZpZXdfbGF5b3V0SW5mbzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92aWV3X2xheW91dEluZm8xLnBhcmVudEtleSkpID09PSBudWxsIHx8IF92aWV3c0J5UGFyZW50S2V5X2dldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0LnB1c2godmlldyk7XG4gICAgICAgICAgICBpZiAoIXZpZXdzQnlQYXJlbnRLZXkuaGFzKChfdmlld19sYXlvdXRJbmZvMiA9IHZpZXcubGF5b3V0SW5mbykgPT09IG51bGwgfHwgX3ZpZXdfbGF5b3V0SW5mbzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92aWV3X2xheW91dEluZm8yLmtleSkpIHZpZXdzQnlQYXJlbnRLZXkuc2V0KChfdmlld19sYXlvdXRJbmZvMyA9IHZpZXcubGF5b3V0SW5mbykgPT09IG51bGwgfHwgX3ZpZXdfbGF5b3V0SW5mbzMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92aWV3X2xheW91dEluZm8zLmtleSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBidWlsZFRyZWUgPSAocGFyZW50LCB2aWV3cyk9PnZpZXdzLm1hcCgodmlldyk9PntcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSB2aWV3c0J5UGFyZW50S2V5LmdldCh2aWV3LmxheW91dEluZm8ua2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5yZW5kZXJXcmFwcGVyKHBhcmVudCwgdmlldywgY2hpbGRyZW4sIChjaGlsZFZpZXdzKT0+YnVpbGRUcmVlKHZpZXcsIGNoaWxkVmlld3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBidWlsZFRyZWUobnVsbCwgdmlld3NCeVBhcmVudEtleS5nZXQobnVsbCkpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFZpc2libGVWaWV3cyhjaGlsZHJlbik7XG4gICAgfVxuICAgIF9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykge1xuICAgICAgICBpZiAodmlldy5sYXlvdXRJbmZvID09PSBsYXlvdXRJbmZvKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZpZXcubGF5b3V0SW5mbyA9IGxheW91dEluZm87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfYXBwbHlMYXlvdXRJbmZvcygpIHtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQXBwbHkgbGF5b3V0IGluZm9zIHRvIHZpc2libGUgdmlld3NcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl92aXNpYmxlVmlld3MudmFsdWVzKCkpe1xuICAgICAgICAgICAgbGV0IGN1ciA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgIGlmICgoY3VyID09PSBudWxsIHx8IGN1ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VyLmtleSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhjdXIua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXBwbHlMYXlvdXRJbmZvKHZpZXcsIGxheW91dEluZm8pKSB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBseSBmaW5hbCBsYXlvdXQgaW5mb3MgZm9yIHZpZXdzIHRoYXQgd2lsbCBiZSByZW1vdmVkXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl90cmFuc2FjdGlvbi50b1JlbW92ZS52YWx1ZXMoKSl7XG4gICAgICAgICAgICAgICAgbGV0IGN1ciA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgICAgICBpZiAoKGN1ciA9PT0gbnVsbCB8fCBjdXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1ci5rZXkpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGN1ci5rZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXBwbHlMYXlvdXRJbmZvKHZpZXcsIGxheW91dEluZm8pKSB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX3RyYW5zYWN0aW9uLnJlbW92ZWQudmFsdWVzKCkpe1xuICAgICAgICAgICAgICAgIGxldCBjdXIgPSB2aWV3LmxheW91dEluZm87XG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLl90cmFuc2FjdGlvbi5maW5hbExheW91dEluZm8uZ2V0KGN1ci5rZXkpIHx8IGN1cjtcbiAgICAgICAgICAgICAgICBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0RmluYWxMYXlvdXRJbmZvKGxheW91dEluZm8uY29weSgpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXBwbHlMYXlvdXRJbmZvKHZpZXcsIGxheW91dEluZm8pKSB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZCkgdGhpcy5fZmx1c2hWaXNpYmxlVmlld3MoKTtcbiAgICB9XG4gICAgX2hhc0xheW91dFVwZGF0ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb24pIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl92aXNpYmxlVmlld3MudmFsdWVzKCkpe1xuICAgICAgICAgICAgbGV0IGN1ciA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgIGlmICghY3VyKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhjdXIua2V5KTtcbiAgICAgICAgICAgIGlmICgvLyBVc2VzIGVxdWFscyByYXRoZXIgdGhhbiBwb2ludEVxdWFscyBzbyB0aGF0IHdpZHRoL2hlaWdodCBjaGFuZ2VzIGFyZSB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICFjdXIucmVjdC5lcXVhbHMobGF5b3V0SW5mby5yZWN0KSB8fCBjdXIub3BhY2l0eSAhPT0gbGF5b3V0SW5mby5vcGFjaXR5IHx8IGN1ci50cmFuc2Zvcm0gIT09IGxheW91dEluZm8udHJhbnNmb3JtKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldXNlVmlldyh2aWV3KSB7XG4gICAgICAgIHZpZXcucHJlcGFyZUZvclJldXNlKCk7XG4gICAgICAgIHRoaXMuX3JldXNhYmxlVmlld3Nbdmlldy52aWV3VHlwZV0ucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgcmVtb3ZlVmlld3ModG9SZW1vdmUpIHtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0b1JlbW92ZSl0aGlzLl9jaGlsZHJlbi5kZWxldGUodmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZUl0ZW1TaXplKGtleSwgc2l6ZSkge1xuICAgICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgYmUgYWJsZSB0byBpbnZhbGlkYXRlIGEgc2luZ2xlIGluZGV4IHBhdGhcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoIXRoaXMubGF5b3V0LnVwZGF0ZUl0ZW1TaXplKSByZXR1cm47XG4gICAgICAgIC8vIElmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgY3VycmVudGx5IGFuaW1hdGluZywgYWRkIHRoZSB1cGRhdGVcbiAgICAgICAgLy8gdG8gYSBxdWV1ZSB0byBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbEFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc2l6ZVVwZGF0ZVF1ZXVlLnNldChrZXksIHNpemUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLmxheW91dC51cGRhdGVJdGVtU2l6ZShrZXksIHNpemUpO1xuICAgICAgICBpZiAoY2hhbmdlZCkgdGhpcy5yZWxheW91dCgpO1xuICAgIH1cbiAgICBzdGFydFNjcm9sbGluZygpIHtcbiAgICAgICAgdGhpcy5faXNTY3JvbGxpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBlbmRTY3JvbGxpbmcoKSB7XG4gICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RJdGVtT3JkZXIoKTtcbiAgICAgICAgdGhpcy5fZmx1c2hWaXNpYmxlVmlld3MoKTtcbiAgICB9XG4gICAgX3Jlc2V0QW5pbWF0ZWRDb250ZW50T2Zmc2V0KCkge1xuICAgICAgICAvLyBSZXNldCB0aGUgYW5pbWF0ZWQgY29udGVudCBvZmZzZXQgb2Ygc3Vidmlld3MuIFNlZSBjb21tZW50IGluIHJlbGF5b3V0Tm93IGZvciBkZXRhaWxzLlxuICAgICAgICBpZiAoIXRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC5pc09yaWdpbigpKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQgPSBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSgwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5TGF5b3V0SW5mb3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICogU2Nyb2xscyB0aGUgaXRlbSB3aXRoIHRoZSBnaXZlbiBrZXkgaW50byB2aWV3LCBvcHRpb25hbGx5IHdpdGggYW4gYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gc2Nyb2xsIGludG8gdmlldy5cbiAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgc2Nyb2xsIGFuaW1hdGlvbi5cbiAgICovIHNjcm9sbFRvSXRlbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgLy8ga2V5IGNhbiBiZSAwLCBzbyBjaGVjayBpZiBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybjtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGtleSk7XG4gICAgICAgIGlmICghbGF5b3V0SW5mbykgcmV0dXJuO1xuICAgICAgICBsZXQgeyBkdXJhdGlvbjogZHVyYXRpb24gPSAzMDAsIHNob3VsZFNjcm9sbFg6IHNob3VsZFNjcm9sbFggPSB0cnVlLCBzaG91bGRTY3JvbGxZOiBzaG91bGRTY3JvbGxZID0gdHJ1ZSwgb2Zmc2V0WDogb2Zmc2V0WCA9IDAsIG9mZnNldFk6IG9mZnNldFkgPSAwIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgeCA9IHRoaXMudmlzaWJsZVJlY3QueDtcbiAgICAgICAgbGV0IHkgPSB0aGlzLnZpc2libGVSZWN0Lnk7XG4gICAgICAgIGxldCBtaW5YID0gbGF5b3V0SW5mby5yZWN0LnggLSBvZmZzZXRYO1xuICAgICAgICBsZXQgbWluWSA9IGxheW91dEluZm8ucmVjdC55IC0gb2Zmc2V0WTtcbiAgICAgICAgbGV0IG1heFggPSB4ICsgdGhpcy52aXNpYmxlUmVjdC53aWR0aDtcbiAgICAgICAgbGV0IG1heFkgPSB5ICsgdGhpcy52aXNpYmxlUmVjdC5oZWlnaHQ7XG4gICAgICAgIGlmIChzaG91bGRTY3JvbGxYKSB7XG4gICAgICAgICAgICBpZiAobWluWCA8PSB4IHx8IG1heFggPT09IDApIHggPSBtaW5YO1xuICAgICAgICAgICAgZWxzZSBpZiAobGF5b3V0SW5mby5yZWN0Lm1heFggPiBtYXhYKSB4ICs9IGxheW91dEluZm8ucmVjdC5tYXhYIC0gbWF4WDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsWSkge1xuICAgICAgICAgICAgaWYgKG1pblkgPD0geSB8fCBtYXhZID09PSAwKSB5ID0gbWluWTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxheW91dEluZm8ucmVjdC5tYXhZID4gbWF4WSkgeSArPSBsYXlvdXRJbmZvLnJlY3QubWF4WSAtIG1heFk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG8obmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoeCwgeSksIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGFuIGFuaW1hdGVkIHNjcm9sbCB0byB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCB0byBzY3JvbGwgdG8uXG4gICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKi8gc2Nyb2xsVG8ob2Zmc2V0LCBkdXJhdGlvbiA9IDMwMCkge1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGN1cnJlbnQgc2Nyb2xsIGFuaW1hdGlvblxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgY29udGVudCBvZmZzZXQgc3luY2hyb25vdXNseSBpZiB0aGUgZHVyYXRpb24gaXMgemVyb1xuICAgICAgICBpZiAoZHVyYXRpb24gPD0gMCB8fCB0aGlzLnZpc2libGVSZWN0LnBvaW50RXF1YWxzKG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnRPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U2Nyb2xsaW5nKCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbiA9ICgwLCAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkZGMwYjYzNzIwNzg4MDkwYykodGhpcy52aXNpYmxlUmVjdCwgb2Zmc2V0LCBkdXJhdGlvbiwgKDAsICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ1NzYzNmJiNDNiMWNjYmIwKSwgKG9mZnNldCk9PntcbiAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnRPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbi50aGVuKCgpPT57XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB2aWV3IHNpemUgdXBkYXRlcyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuICAgICAgICAgICAgLy8gT25seSB2aWV3cyB0aGF0IGFyZSBzdGlsbCB2aXNpYmxlIHdpbGwgYmUgYWN0dWFsbHkgdXBkYXRlZC5cbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHNpemVdIG9mIHRoaXMuX3NpemVVcGRhdGVRdWV1ZSl0aGlzLnVwZGF0ZUl0ZW1TaXplKGtleSwgc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLl9zaXplVXBkYXRlUXVldWUuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMucmVsYXlvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmVuZFNjcm9sbGluZygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbEFuaW1hdGlvbjtcbiAgICB9XG4gICAgX3J1blRyYW5zYWN0aW9uKGFjdGlvbiwgYW5pbWF0ZWQpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5fbmV4dFRyYW5zYWN0aW9uKSB0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgIHRoaXMuX2VuZFRyYW5zYWN0aW9uKGFuaW1hdGVkKTtcbiAgICB9XG4gICAgX3N0YXJ0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbmV4dFRyYW5zYWN0aW9uKSB0aGlzLl9uZXh0VHJhbnNhY3Rpb24gPSBuZXcgKDAsICQ4ZTEzNWU1MzFkOGRjYjY2JGV4cG9ydCRmZWJjNTU3M2M3NWNlZmIwKTtcbiAgICAgICAgdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmxldmVsKys7XG4gICAgfVxuICAgIF9lbmRUcmFuc2FjdGlvbihhbmltYXRlZCkge1xuICAgICAgICBpZiAoIXRoaXMuX25leHRUcmFuc2FjdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBTYXZlIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhbmltYXRlZC5cbiAgICAgICAgaWYgKGFuaW1hdGVkICE9IG51bGwpIHRoaXMuX25leHRUcmFuc2FjdGlvbi5hbmltYXRlZCA9IGFuaW1hdGVkO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHJlYWNoZWQgbGV2ZWwgMCwgd2UgYXJlIHN0aWxsIGluIGFcbiAgICAgICAgLy8gbmVzdGVkIHRyYW5zYWN0aW9uLiBXYWl0IGZvciB0aGUgcGFyZW50IHRvIGVuZC5cbiAgICAgICAgaWYgKC0tdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmxldmVsID4gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBEbyBub3RoaW5nIGZvciBlbXB0eSB0cmFuc2FjdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuX25leHRUcmFuc2FjdGlvbi5hY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IGFuaW1hdGlvbnMgdG8gdHJ1ZVxuICAgICAgICBpZiAodGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFuaW1hdGVkID09IG51bGwpIHRoaXMuX25leHRUcmFuc2FjdGlvbi5hbmltYXRlZCA9IHRydWU7XG4gICAgICAgIC8vIEVucXVldWUgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uUXVldWUucHVzaCh0aGlzLl9uZXh0VHJhbnNhY3Rpb24pO1xuICAgICAgICB0aGlzLl9uZXh0VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlKCkge1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBpcyBhbmltYXRpbmcsIHdhaXQgdW50aWwgdGhlIGVuZFxuICAgICAgICAvLyB0byBwcm9jZXNzIHRoZSBuZXh0IHRyYW5zYWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24gfHwgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSByZXR1cm47XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5fdHJhbnNhY3Rpb25RdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAobmV4dCkgdGhpcy5fcGVyZm9ybVRyYW5zYWN0aW9uKG5leHQpO1xuICAgIH1cbiAgICBfZ2V0Q29udGVudFJlY3QoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKSgwLCAwLCB0aGlzLmNvbnRlbnRTaXplLndpZHRoLCB0aGlzLmNvbnRlbnRTaXplLmhlaWdodCk7XG4gICAgfVxuICAgIF9wZXJmb3JtVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgdGhpcy5yZWxheW91dE5vdyh7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBhbmltYXRlZDogdHJhbnNhY3Rpb24uYW5pbWF0ZWQsXG4gICAgICAgICAgICBiZWZvcmVMYXlvdXQ6ICgpPT57XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbml0aWFsIGxheW91dCBpbmZvcyBmb3IgYWxsIHZpZXdzIGJlZm9yZSB0aGUgdXBkYXRlc1xuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGNhbiBmaWd1cmUgb3V0IHdoaWNoIHZpZXdzIHRvIGFkZCBhbmQgcmVtb3ZlLlxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5hbmltYXRlZCkgdHJhbnNhY3Rpb24uaW5pdGlhbE1hcCA9IHRoaXMuX2dldExheW91dEluZm9NYXAodGhpcy5fZ2V0Q29udGVudFJlY3QoKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGFjdGlvbnMgdGhhdCBvY2N1cnJlZCBkdXJpbmcgdGhpcyB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGFjdGlvbiBvZiB0cmFuc2FjdGlvbi5hY3Rpb25zKWFjdGlvbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFmdGVyTGF5b3V0OiAoKT0+e1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZmluYWwgbGF5b3V0IGluZm9zIGFmdGVyIHRoZSB1cGRhdGVzXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmZpbmFsTWFwID0gdGhpcy5fZ2V0TGF5b3V0SW5mb01hcCh0aGlzLl9nZXRDb250ZW50UmVjdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBUcmFuc2FjdGlvbkFuaW1hdGlvbnModHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXJBbmltYXRpb246ICgpPT57XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFuZCByZXVzZSB2aWV3cyB3aGVuIGFuaW1hdGlvbnMgYXJlIGRvbmVcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24udG9SZW1vdmUuc2l6ZSA+IDAgfHwgdHJhbnNhY3Rpb24ucmVtb3ZlZC5zaXplID4gMCkgZm9yIChsZXQgdmlldyBvZiAoMCwgJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGNmYzE0MDg4ZGZlZmNlNWYpKHRyYW5zYWN0aW9uLnRvUmVtb3ZlLnZhbHVlcygpLCB0cmFuc2FjdGlvbi5yZW1vdmVkLnZhbHVlcygpKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmRlbGV0ZSh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXVzZVZpZXcodmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgRE9NIG9yZGVyIGlzIGNvcnJlY3QgZm9yIGFjY2Vzc2liaWxpdHkgYWZ0ZXIgYW5pbWF0aW9ucyBhcmUgY29tcGxldGVcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3JyZWN0SXRlbU9yZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmx1c2hWaXNpYmxlVmlld3MoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3NldHVwVHJhbnNhY3Rpb25BbmltYXRpb25zKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGxldCB7IGluaXRpYWxNYXA6IGluaXRpYWxNYXAsIGZpbmFsTWFwOiBmaW5hbE1hcCB9ID0gdHJhbnNhY3Rpb247XG4gICAgICAgIC8vIFN0b3JlIGluaXRpYWwgYW5kIGZpbmFsIGxheW91dCBpbmZvcyBmb3IgYW5pbWF0aW9uc1xuICAgICAgICBmb3IgKGxldCBba2V5LCBsYXlvdXRJbmZvXSBvZiBpbml0aWFsTWFwKWlmIChmaW5hbE1hcC5oYXMoa2V5KSkgLy8gU3RvcmUgdGhlIGluaXRpYWwgbGF5b3V0IGluZm8gZm9yIHVzZSBkdXJpbmcgYW5pbWF0aW9ucy5cbiAgICAgICAgdHJhbnNhY3Rpb24uaW5pdGlhbExheW91dEluZm8uc2V0KGtleSwgbGF5b3V0SW5mbyk7XG4gICAgICAgIGVsc2UgLy8gVGhpcyB2aWV3IHdhcyByZW1vdmVkLiBTdG9yZSB0aGUgbGF5b3V0IGluZm8gZm9yIHVzZVxuICAgICAgICAvLyBpbiBMYXlvdXQjZ2V0RmluYWxMYXlvdXRJbmZvIGR1cmluZyBhbmltYXRpb25zLlxuICAgICAgICB0cmFuc2FjdGlvbi5maW5hbExheW91dEluZm8uc2V0KGxheW91dEluZm8ua2V5LCBsYXlvdXRJbmZvKTtcbiAgICAgICAgLy8gR2V0IGluaXRpYWwgbGF5b3V0IGluZm9zIGZvciB2aWV3cyB0aGF0IHdlcmUgYWRkZWRcbiAgICAgICAgZm9yIChsZXQgW2tleSwgbGF5b3V0SW5mb10gb2YgZmluYWxNYXApaWYgKCFpbml0aWFsTWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbExheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRJbml0aWFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvLmNvcHkoKSk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5pbml0aWFsTGF5b3V0SW5mby5zZXQoa2V5LCBpbml0aWFsTGF5b3V0SW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCB2aWV3cyB3ZXJlIHJlbW92ZWQuXG4gICAgICAgIGZvciAobGV0IFtrZXksIHZpZXddIG9mIHRoaXMuX3Zpc2libGVWaWV3cykvLyBJZiBhbiBpdGVtIGhhcyBhIHdpZHRoIG9mIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmVtb3ZlIGl0IGZyb20gdGhlIF92aXNpYmxlVmlld3MuXG4gICAgICAgIC8vIFJlbW92aW5nIGFuIGl0ZW0gd2l0aCAgd2lkdGggb2YgMCBjYW4gY2F1c2UgYSBsb29wIHdoZXJlIHRoZSBpdGVtIGdldHMgYWRkZWQsIHJlbW92ZWQsXG4gICAgICAgIC8vIGFkZGVkLCByZW1vdmVkLi4uIGV0YyBpbiBhIGxvb3AuXG4gICAgICAgIGlmICghZmluYWxNYXAuaGFzKGtleSkgJiYgdmlldy5sYXlvdXRJbmZvLnJlY3Qud2lkdGggPiAwKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5yZW1vdmVkLnNldChrZXksIHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXdzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBzb21ldGhpbmcgd2VpcmQgaGFwcGVuZWQsIHdoZXJlIHdlIGhhdmUgYSB2aWV3IGJ1dCBub1xuICAgICAgICAgICAgLy8gaW5pdGlhbCBsYXlvdXQgaW5mbywgdXNlIHRoZSBvbmUgYXR0YWNoZWQgdG8gdGhlIHZpZXcuXG4gICAgICAgICAgICBpZiAodmlldy5sYXlvdXRJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5maW5hbExheW91dEluZm8uaGFzKHZpZXcubGF5b3V0SW5mby5rZXkpKSB0cmFuc2FjdGlvbi5maW5hbExheW91dEluZm8uc2V0KHZpZXcubGF5b3V0SW5mby5rZXksIHZpZXcubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KXtcbiAgICAgICAgdGhpcy5fY29udGVudFNpemUgPSBuZXcgKDAsICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVJlY3QgPSBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKTtcbiAgICAgICAgdGhpcy5fcmV1c2FibGVWaWV3cyA9IHt9O1xuICAgICAgICB0aGlzLl92aXNpYmxlTGF5b3V0SW5mb3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Zpc2libGVWaWV3cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50ID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIgPSBuZXcgKDAsICQzNjQxOTFiM2RlY2YzNjk3JGV4cG9ydCQ0NDU1ZWU2YWZiMzhkY2JiKSgpO1xuICAgICAgICB0aGlzLl9wZXJzaXN0ZWRLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zaXplVXBkYXRlUXVldWUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldCA9IG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKDAsIDApO1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX25leHRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgdmFyIF9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgICAgLy8gU2V0IG9wdGlvbnMgZnJvbSBwYXNzZWQgb2JqZWN0IGlmIGdpdmVuXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uID0gKF9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbiA9IG9wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uKSAhPT0gbnVsbCAmJiBfb3B0aW9uc190cmFuc2l0aW9uRHVyYXRpb24gIT09IHZvaWQgMCA/IF9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbiA6IDUwMDtcbiAgICAgICAgdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbiA9IG9wdGlvbnMuYW5jaG9yU2Nyb2xsUG9zaXRpb24gfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuYW5jaG9yU2Nyb2xsUG9zaXRpb25BdFRvcCA9IG9wdGlvbnMuYW5jaG9yU2Nyb2xsUG9zaXRpb25BdFRvcCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRPdmVyc2NhbiA9IG9wdGlvbnMuc2hvdWxkT3ZlcnNjYW4gIT09IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgW1xuICAgICAgICAgICAgXCJkZWxlZ2F0ZVwiLFxuICAgICAgICAgICAgXCJzaXplXCIsXG4gICAgICAgICAgICBcImxheW91dFwiLFxuICAgICAgICAgICAgXCJjb2xsZWN0aW9uXCJcbiAgICAgICAgXSlpZiAob3B0aW9uc1trZXldKSB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uICRmYzBiMTNiNDg0YWMxMTk0JGV4cG9ydCQxNTA1ZGI4MmZlMzU3ZTY1KG9wdHMpIHtcbiAgICBsZXQgW3Zpc2libGVWaWV3cywgc2V0VmlzaWJsZVZpZXdzXSA9ICgwLCAkOEQzbnIkdXNlU3RhdGUpKFtdKTtcbiAgICBsZXQgW2NvbnRlbnRTaXplLCBzZXRDb250ZW50U2l6ZV0gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShuZXcgKDAsICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjKSgpKTtcbiAgICBsZXQgW2lzQW5pbWF0aW5nLCBzZXRBbmltYXRpbmddID0gKDAsICQ4RDNuciR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCBbaXNTY3JvbGxpbmcsIHNldFNjcm9sbGluZ10gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IHZpcnR1YWxpemVyID0gKDAsICQ4RDNuciR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkMzhiOTQ5MGMxY2NhOGZjNCRleHBvcnQkODliZTVhMjQzZTU5YzRiMikoKSwgW10pO1xuICAgIHZpcnR1YWxpemVyLmRlbGVnYXRlID0ge1xuICAgICAgICBzZXRWaXNpYmxlVmlld3M6IHNldFZpc2libGVWaWV3cyxcbiAgICAgICAgc2V0VmlzaWJsZVJlY3QgKHJlY3QpIHtcbiAgICAgICAgICAgIHZpcnR1YWxpemVyLnZpc2libGVSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgIG9wdHMub25WaXNpYmxlUmVjdENoYW5nZShyZWN0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q29udGVudFNpemU6IHNldENvbnRlbnRTaXplLFxuICAgICAgICByZW5kZXJWaWV3OiBvcHRzLnJlbmRlclZpZXcsXG4gICAgICAgIHJlbmRlcldyYXBwZXI6IG9wdHMucmVuZGVyV3JhcHBlcixcbiAgICAgICAgYmVnaW5BbmltYXRpb25zOiAoKT0+c2V0QW5pbWF0aW5nKHRydWUpLFxuICAgICAgICBlbmRBbmltYXRpb25zOiAoKT0+c2V0QW5pbWF0aW5nKGZhbHNlKSxcbiAgICAgICAgZ2V0U2Nyb2xsQW5jaG9yOiBvcHRzLmdldFNjcm9sbEFuY2hvclxuICAgIH07XG4gICAgdmlydHVhbGl6ZXIubGF5b3V0ID0gb3B0cy5sYXlvdXQ7XG4gICAgdmlydHVhbGl6ZXIuY29sbGVjdGlvbiA9IG9wdHMuY29sbGVjdGlvbjtcbiAgICB2aXJ0dWFsaXplci50cmFuc2l0aW9uRHVyYXRpb24gPSBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAoMCwgJDhEM25yJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgdmlydHVhbGl6ZXIuYWZ0ZXJSZW5kZXIoKTtcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyb3ctYm9keS1zdHlsZVxuICAgICgwLCAkOEQzbnIkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICByZXR1cm4gKCk9PnZpcnR1YWxpemVyLndpbGxVbm1vdW50KCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtdKTtcbiAgICBsZXQgc2V0VmlzaWJsZVJlY3QgPSAoMCwgJDhEM25yJHVzZUNhbGxiYWNrKSgocmVjdCk9PntcbiAgICAgICAgdmlydHVhbGl6ZXIudmlzaWJsZVJlY3QgPSByZWN0O1xuICAgIH0sIFtcbiAgICAgICAgdmlydHVhbGl6ZXJcbiAgICBdKTtcbiAgICBsZXQgc3RhcnRTY3JvbGxpbmcgPSAoMCwgJDhEM25yJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICB2aXJ0dWFsaXplci5zdGFydFNjcm9sbGluZygpO1xuICAgICAgICBzZXRTY3JvbGxpbmcodHJ1ZSk7XG4gICAgfSwgW1xuICAgICAgICB2aXJ0dWFsaXplclxuICAgIF0pO1xuICAgIGxldCBlbmRTY3JvbGxpbmcgPSAoMCwgJDhEM25yJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICB2aXJ0dWFsaXplci5lbmRTY3JvbGxpbmcoKTtcbiAgICAgICAgc2V0U2Nyb2xsaW5nKGZhbHNlKTtcbiAgICB9LCBbXG4gICAgICAgIHZpcnR1YWxpemVyXG4gICAgXSk7XG4gICAgbGV0IHN0YXRlID0gKDAsICQ4RDNuciR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHZpcnR1YWxpemVyOiB2aXJ0dWFsaXplcixcbiAgICAgICAgICAgIHZpc2libGVWaWV3czogdmlzaWJsZVZpZXdzLFxuICAgICAgICAgICAgc2V0VmlzaWJsZVJlY3Q6IHNldFZpc2libGVSZWN0LFxuICAgICAgICAgICAgY29udGVudFNpemU6IGNvbnRlbnRTaXplLFxuICAgICAgICAgICAgaXNBbmltYXRpbmc6IGlzQW5pbWF0aW5nLFxuICAgICAgICAgICAgaXNTY3JvbGxpbmc6IGlzU2Nyb2xsaW5nLFxuICAgICAgICAgICAgc3RhcnRTY3JvbGxpbmc6IHN0YXJ0U2Nyb2xsaW5nLFxuICAgICAgICAgICAgZW5kU2Nyb2xsaW5nOiBlbmRTY3JvbGxpbmdcbiAgICAgICAgfSksIFtcbiAgICAgICAgdmlydHVhbGl6ZXIsXG4gICAgICAgIHZpc2libGVWaWV3cyxcbiAgICAgICAgc2V0VmlzaWJsZVJlY3QsXG4gICAgICAgIGNvbnRlbnRTaXplLFxuICAgICAgICBpc0FuaW1hdGluZyxcbiAgICAgICAgaXNTY3JvbGxpbmcsXG4gICAgICAgIHN0YXJ0U2Nyb2xsaW5nLFxuICAgICAgICBlbmRTY3JvbGxpbmdcbiAgICBdKTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5cblxuXG5cbmV4cG9ydCB7JGM3NGNkYTdkMzFhZjEyNTMkZXhwb3J0JGM4NDY3MWY0NmQ2YTFjYSBhcyBMYXlvdXQsICRkN2ZkNjEwMDljMjFkMGJiJGV4cG9ydCQ3ZTBlZWI5ZGE3MDJhMDg1IGFzIExheW91dEluZm8sICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhIGFzIFBvaW50LCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCBhcyBSZWN0LCAkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYyBhcyBTaXplLCAkYWQxZDk4YWE4ZjBjMzFiNCRleHBvcnQkMWE1MjIzODg3YzU2MDQ0MSBhcyBSZXVzYWJsZVZpZXcsICRmYzBiMTNiNDg0YWMxMTk0JGV4cG9ydCQxNTA1ZGI4MmZlMzU3ZTY1IGFzIHVzZVZpcnR1YWxpemVyU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwiJDhEM25yJHVzZVN0YXRlIiwidXNlTWVtbyIsIiQ4RDNuciR1c2VNZW1vIiwidXNlRWZmZWN0IiwiJDhEM25yJHVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiJDhEM25yJHVzZUNhbGxiYWNrIiwidXNlTGF5b3V0RWZmZWN0IiwiJDhEM25yJHVzZUxheW91dEVmZmVjdCIsIiRjNzRjZGE3ZDMxYWYxMjUzJGV4cG9ydCRjODQ2NzFmNDZkNmExY2EiLCJzaG91bGRJbnZhbGlkYXRlIiwibmV3UmVjdCIsIm9sZFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInZhbGlkYXRlIiwiaW52YWxpZGF0aW9uQ29udGV4dCIsImdldEluaXRpYWxMYXlvdXRJbmZvIiwibGF5b3V0SW5mbyIsImdldEZpbmFsTGF5b3V0SW5mbyIsIiRkN2ZkNjEwMDljMjFkMGJiJGV4cG9ydCQ3ZTBlZWI5ZGE3MDJhMDg1IiwiY29weSIsInJlcyIsInR5cGUiLCJrZXkiLCJyZWN0IiwiZXN0aW1hdGVkU2l6ZSIsIm9wYWNpdHkiLCJ0cmFuc2Zvcm0iLCJwYXJlbnRLZXkiLCJpc1N0aWNreSIsInpJbmRleCIsImFsbG93T3ZlcmZsb3ciLCJjb25zdHJ1Y3RvciIsIiQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhIiwieCIsInkiLCJlcXVhbHMiLCJwb2ludCIsImlzT3JpZ2luIiwiJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QiLCJtYXhYIiwibWF4WSIsImFyZWEiLCJ0b3BMZWZ0IiwidG9wUmlnaHQiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJpbnRlcnNlY3RzIiwiY29udGFpbnNSZWN0IiwiY29udGFpbnNQb2ludCIsImdldENvcm5lckluUmVjdCIsInBvaW50RXF1YWxzIiwic2l6ZUVxdWFscyIsInNpemUiLCJ1bmlvbiIsIm90aGVyIiwiTWF0aCIsIm1pbiIsIm1heCIsImludGVyc2VjdGlvbiIsIiRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjIiwiJGFkMWQ5OGFhOGYwYzMxYjQkdmFyJEtFWSIsIiRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxIiwicHJlcGFyZUZvclJldXNlIiwiY29udGVudCIsInJlbmRlcmVkIiwidmlydHVhbGl6ZXIiLCIkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZiIsIndpbmRvdyIsInBlcmZvcm1hbmNlIiwiJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmZOb3ciLCJub3ciLCJ3ZWJraXROb3ciLCJtc05vdyIsIm1vek5vdyIsIiQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lIiwiYmluZCIsIkRhdGUiLCJnZXRUaW1lIiwiJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzIiwiJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JGRjMGI2MzcyMDc4ODA5MGMiLCJiZWdpbiIsImVuZCIsImR1cmF0aW9uIiwiZWFzZSIsImZuIiwiY2FuY2VsZWQiLCJyYWZfaWQiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdGFydCIsImRpZmZYIiwiZGlmZlkiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJydW4iLCJ0IiwiZGVsdGEiLCJwcm9jZWVkIiwiY2FuY2VsIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCIkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkNzc4NjBjMTA2YjRhNmEyZSIsIiQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ1NzYzNmJiNDNiMWNjYmIwIiwic2luIiwiUEkiLCIkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkMzdhMjZiMjgzZmQ3NzQwZSIsImEiLCJiIiwiU2V0Iiwia2V5cyIsImhhcyIsImFkZCIsIiRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhY2FmOTZhMjc0MzgyNDZiIiwidG9SZW1vdmUiLCJ0b0FkZCIsInRvVXBkYXRlIiwiJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGNmYzE0MDg4ZGZlZmNlNWYiLCJpdGVyYXRvcnMiLCJpdGVyYXRvciIsIiRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQ2ODk3YzI4NGI2ZjlmNGRjIiwib2JqZWN0IiwiJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGE4ZDBkMGM4ZDFjNWRmNjQiLCIkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2UiLCJhZGRTYW1wbGUiLCJzYW1wbGUiLCJjb3VudCIsInZhbHVlIiwiJDM2NDE5MWIzZGVjZjM2OTckZXhwb3J0JDQ0NTVlZTZhZmIzOGRjYmIiLCJzZXRWaXNpYmxlUmVjdCIsInRpbWUiLCJzdGFydFRpbWUiLCJhdmVyYWdlVGltZSIsInZpc2libGVSZWN0IiwidmVsb2NpdHkiLCJjb2xsZWN0TWV0cmljcyIsImF2ZXJhZ2VQZXJmIiwibyIsImFicyIsIm92ZXJzY2FuWSIsIm92ZXJzY2FuWCIsImdldE92ZXJzY2FubmVkUmVjdCIsIm92ZXJzY2FubmVkIiwicm91bmQiLCIkOGUxMzVlNTMxZDhkY2I2NiRleHBvcnQkZmViYzU1NzNjNzVjZWZiMCIsImxldmVsIiwiYWN0aW9ucyIsImFuaW1hdGVkIiwiaW5pdGlhbE1hcCIsIk1hcCIsImZpbmFsTWFwIiwiaW5pdGlhbExheW91dEluZm8iLCJmaW5hbExheW91dEluZm8iLCJyZW1vdmVkIiwiJDM4Yjk0OTBjMWNjYThmYzQkZXhwb3J0JDg5YmU1YTI0M2U1OWM0YjIiLCJfc2V0Q29udGVudFNpemUiLCJfY29udGVudFNpemUiLCJkZWxlZ2F0ZSIsInNldENvbnRlbnRTaXplIiwiX3NldENvbnRlbnRPZmZzZXQiLCJvZmZzZXQiLCJfdmlzaWJsZVJlY3QiLCJjb250ZW50U2l6ZSIsIl9zZXRWaXNpYmxlUmVjdCIsImZvcmNlVXBkYXRlIiwiY3VycmVudCIsInNob3VsZE92ZXJzY2FuIiwiX292ZXJzY2FuTWFuYWdlciIsImxheW91dCIsIl9yZXNldEFuaW1hdGVkQ29udGVudE9mZnNldCIsInJlbGF5b3V0Tm93Iiwib2Zmc2V0Q2hhbmdlZCIsInNpemVDaGFuZ2VkIiwidXBkYXRlU3Vidmlld3MiLCJjb2xsZWN0aW9uIiwiX2NvbGxlY3Rpb24iLCJkYXRhIiwiX3NldERhdGEiLCJfcnVuVHJhbnNhY3Rpb24iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJyZWxvYWREYXRhIiwicmVsYXlvdXQiLCJjb250ZW50Q2hhbmdlZCIsImdldEl0ZW0iLCJwZXJzaXN0ZWRLZXlzIiwiX3BlcnNpc3RlZEtleXMiLCJpc1BlcnNpc3RlZEtleSIsImsiLCJnZXRMYXlvdXRJbmZvIiwiX2xheW91dCIsInNldExheW91dCIsImFwcGx5TGF5b3V0IiwiX2dldFJldXNlVHlwZSIsImdldFR5cGUiLCJyZXVzZVR5cGUiLCJnZXRSZXVzYWJsZVZpZXciLCJfcmV1c2FibGVWaWV3cyIsInJldXNhYmxlIiwidmlldyIsImxlbmd0aCIsInBvcCIsInZpZXdUeXBlIiwiX2FuaW1hdGVkQ29udGVudE9mZnNldCIsIl9yZW5kZXJWaWV3IiwicmV1c2FibGVWaWV3IiwiX3JlbmRlckNvbnRlbnQiLCJjYWNoZWQiLCJfcmVuZGVyZWRDb250ZW50IiwiZ2V0IiwicmVuZGVyVmlldyIsInNldCIsInZpc2libGVWaWV3cyIsIkFycmF5IiwiZnJvbSIsIl92aXNpYmxlVmlld3MiLCJ2YWx1ZXMiLCJnZXRWaWV3IiwiZ2V0Vmlld3NPZlR5cGUiLCJmaWx0ZXIiLCJ2Iiwia2V5Rm9yVmlldyIsImtleUF0UG9pbnQiLCJsYXlvdXRJbmZvcyIsImdldFZpc2libGVMYXlvdXRJbmZvcyIsIndpbGxVbm1vdW50IiwiX3JlbGF5b3V0UmFmIiwiY29udGV4dCIsIl9zY3JvbGxBbmltYXRpb24iLCJfaW52YWxpZGF0aW9uQ29udGV4dCIsIk9iamVjdCIsImFzc2lnbiIsInNjcm9sbEFuY2hvciIsIl9nZXRTY3JvbGxBbmNob3IiLCJiZWZvcmVMYXlvdXQiLCJnZXRDb250ZW50U2l6ZSIsImFmdGVyTGF5b3V0IiwiZ2V0VmlzaWJsZVJlY3QiLCJyZXN0b3JlZFNjcm9sbEFuY2hvciIsIl9yZXN0b3JlU2Nyb2xsQW5jaG9yIiwiY29udGVudE9mZnNldFgiLCJjb250ZW50T2Zmc2V0WSIsImhhc0xheW91dFVwZGF0ZXMiLCJ0cmFuc2FjdGlvbiIsIl9hcHBseUxheW91dEluZm9zIiwiX2VuYWJsZVRyYW5zaXRpb25zIiwiZG9uZSIsIl9kaXNhYmxlVHJhbnNpdGlvbnMiLCJhZnRlckFuaW1hdGlvbiIsInNldFRpbWVvdXQiLCJfY29ycmVjdEl0ZW1PcmRlciIsIl9pc1Njcm9sbGluZyIsIl90cmFuc2FjdGlvbiIsIl92aXNpYmxlTGF5b3V0SW5mb3MiLCJfY2hpbGRyZW4iLCJkZWxldGUiLCJiZWdpbkFuaW1hdGlvbnMiLCJlbmRBbmltYXRpb25zIiwiYW5jaG9yU2Nyb2xsUG9zaXRpb24iLCJnZXRTY3JvbGxBbmNob3IiLCJjb3JuZXIiLCJhbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wIiwiY29ybmVyQW5jaG9yIiwiY29udGVudE9mZnNldCIsIl9jb250ZXh0X3RyYW5zYWN0aW9uIiwiZmluYWxBbmNob3IiLCJhZGp1c3RtZW50IiwiX2dldExheW91dEluZm9NYXAiLCJtYXAiLCJ2aXNpYmxlTGF5b3V0SW5mb3MiLCJjdXJyZW50bHlWaXNpYmxlIiwiaXRlbSIsInJldXNlVmlldyIsIl9hcHBseUxheW91dEluZm8iLCJyZW1vdmVWaWV3cyIsIl9mbHVzaFZpc2libGVWaWV3cyIsIl9oYXNMYXlvdXRVcGRhdGVzIiwiYWZ0ZXJSZW5kZXIiLCJfdHJhbnNhY3Rpb25RdWV1ZSIsIl9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSIsInZpZXdzQnlQYXJlbnRLZXkiLCJfdmlld19sYXlvdXRJbmZvIiwiX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0IiwiX3ZpZXdfbGF5b3V0SW5mbzEiLCJfdmlld19sYXlvdXRJbmZvMiIsIl92aWV3X2xheW91dEluZm8zIiwicHVzaCIsImJ1aWxkVHJlZSIsInBhcmVudCIsInZpZXdzIiwiY2hpbGRyZW4iLCJyZW5kZXJXcmFwcGVyIiwiY2hpbGRWaWV3cyIsInNldFZpc2libGVWaWV3cyIsInVwZGF0ZWQiLCJjdXIiLCJ1cGRhdGVJdGVtU2l6ZSIsIl9zaXplVXBkYXRlUXVldWUiLCJjaGFuZ2VkIiwic3RhcnRTY3JvbGxpbmciLCJlbmRTY3JvbGxpbmciLCJzY3JvbGxUb0l0ZW0iLCJvcHRpb25zIiwic2hvdWxkU2Nyb2xsWCIsInNob3VsZFNjcm9sbFkiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIm1pblgiLCJtaW5ZIiwic2Nyb2xsVG8iLCJ0aGVuIiwiY2xlYXIiLCJhY3Rpb24iLCJfc3RhcnRUcmFuc2FjdGlvbiIsIl9uZXh0VHJhbnNhY3Rpb24iLCJfZW5kVHJhbnNhY3Rpb24iLCJuZXh0Iiwic2hpZnQiLCJfcGVyZm9ybVRyYW5zYWN0aW9uIiwiX2dldENvbnRlbnRSZWN0IiwiX3NldHVwVHJhbnNhY3Rpb25BbmltYXRpb25zIiwiV2Vha01hcCIsIl9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbiIsIiRmYzBiMTNiNDg0YWMxMTk0JGV4cG9ydCQxNTA1ZGI4MmZlMzU3ZTY1Iiwib3B0cyIsImlzQW5pbWF0aW5nIiwic2V0QW5pbWF0aW5nIiwiaXNTY3JvbGxpbmciLCJzZXRTY3JvbGxpbmciLCJvblZpc2libGVSZWN0Q2hhbmdlIiwic3RhdGUiLCJMYXlvdXQiLCJMYXlvdXRJbmZvIiwiUG9pbnQiLCJSZWN0IiwiU2l6ZSIsIlJldXNhYmxlVmlldyIsInVzZVZpcnR1YWxpemVyU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/virtualizer/node_modules/@react-aria/ssr/dist/import.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@react-stately/virtualizer/node_modules/@react-aria/ssr/dist/import.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SSRProvider: () => (/* binding */ $b5e257d569688ac6$export$9f8ac96af4b1b2ae),\n/* harmony export */   useIsSSR: () => (/* binding */ $b5e257d569688ac6$export$535bd6ca7f90a273),\n/* harmony export */   useSSRSafeId: () => (/* binding */ $b5e257d569688ac6$export$619500959fc48b26)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is\n// guarded by a check that it only runs on the client side.\n// eslint-disable-next-line rulesdir/useLayoutEffectRule\n// Default context value to use in case there is no SSRProvider. This is fine for\n// client-only apps. In order to support multiple copies of React Aria potentially\n// being on the page at once, the prefix is set to a random number. SSRProvider\n// will reset this to zero for consistency between server and client, so in the\n// SSR case multiple copies of React Aria is not supported.\nconst $b5e257d569688ac6$var$defaultContext = {\n    prefix: String(Math.round(Math.random() * 10000000000)),\n    current: 0\n};\nconst $b5e257d569688ac6$var$SSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext($b5e257d569688ac6$var$defaultContext);\nconst $b5e257d569688ac6$var$IsSSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(false);\n// This is only used in React < 18.\nfunction $b5e257d569688ac6$var$LegacySSRProvider(props) {\n    let cur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let counter = $b5e257d569688ac6$var$useCounter(cur === $b5e257d569688ac6$var$defaultContext);\n    let [isSSR, setIsSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            // If this is the first SSRProvider, start with an empty string prefix, otherwise\n            // append and increment the counter.\n            prefix: cur === $b5e257d569688ac6$var$defaultContext ? \"\" : `${cur.prefix}-${counter}`,\n            current: 0\n        }), [\n        cur,\n        counter\n    ]);\n    // If on the client, and the component was initially server rendered,\n    // then schedule a layout effect to update the component after hydration.\n    if (typeof document !== \"undefined\") // because the condition never changes after mounting.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        setIsSSR(false);\n    }, []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$SSRContext.Provider, {\n        value: value\n    }, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$IsSSRContext.Provider, {\n        value: isSSR\n    }, props.children));\n}\nlet $b5e257d569688ac6$var$warnedAboutSSRProvider = false;\nfunction $b5e257d569688ac6$export$9f8ac96af4b1b2ae(props) {\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\") {\n        if ( true && !$b5e257d569688ac6$var$warnedAboutSSRProvider) {\n            console.warn(\"In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.\");\n            $b5e257d569688ac6$var$warnedAboutSSRProvider = true;\n        }\n        return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, react__WEBPACK_IMPORTED_MODULE_0__).Fragment, null, props.children);\n    }\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$LegacySSRProvider, props);\n}\nlet $b5e257d569688ac6$var$canUseDOM = Boolean( false && 0);\nlet $b5e257d569688ac6$var$componentIds = new WeakMap();\nfunction $b5e257d569688ac6$var$useCounter(isDisabled = false) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // eslint-disable-next-line rulesdir/pure-render\n    if (ref.current === null && !isDisabled) {\n        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.\n        // This means our id counter will be incremented twice instead of once. This is a problem because on the\n        // server, components are only rendered once and so ids generated on the server won't match the client.\n        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this\n        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.\n        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.\n        // To ensure that we only increment the global counter once, we store the starting id for this component in\n        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.\n        // Since React runs the second render immediately after the first, this is safe.\n        // @ts-ignore\n        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, react__WEBPACK_IMPORTED_MODULE_0__).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;\n        if (currentOwner) {\n            let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);\n            if (prevComponentValue == null) $b5e257d569688ac6$var$componentIds.set(currentOwner, {\n                id: ctx.current,\n                state: currentOwner.memoizedState\n            });\n            else if (currentOwner.memoizedState !== prevComponentValue.state) {\n                // On the second render, the memoizedState gets reset by React.\n                // Reset the counter, and remove from the weak map so we don't\n                // do this for subsequent useId calls.\n                ctx.current = prevComponentValue.id;\n                $b5e257d569688ac6$var$componentIds.delete(currentOwner);\n            }\n        }\n        // eslint-disable-next-line rulesdir/pure-render\n        ref.current = ++ctx.current;\n    }\n    // eslint-disable-next-line rulesdir/pure-render\n    return ref.current;\n}\nfunction $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    // If we are rendering in a non-DOM environment, and there's no SSRProvider,\n    // provide a warning to hint to the developer to add one.\n    if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM) console.warn(\"When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.\");\n    let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);\n    let prefix = ctx === $b5e257d569688ac6$var$defaultContext && \"development\" === \"test\" ? 0 : `react-aria${ctx.prefix}`;\n    return defaultId || `${prefix}-${counter}`;\n}\nfunction $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {\n    // @ts-ignore\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__).useId();\n    let [didSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());\n    let prefix = didSSR || \"development\" === \"test\" ? \"react-aria\" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;\n    return defaultId || `${prefix}-${id}`;\n}\nconst $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;\nfunction $b5e257d569688ac6$var$getSnapshot() {\n    return false;\n}\nfunction $b5e257d569688ac6$var$getServerSnapshot() {\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction $b5e257d569688ac6$var$subscribe(onStoreChange) {\n    // noop\n    return ()=>{};\n}\nfunction $b5e257d569688ac6$export$535bd6ca7f90a273() {\n    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"] === \"function\") return (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$IsSSRContext);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3Nzci9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnTTtBQUVoTTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHLDBGQUEwRjtBQUM5RiwyREFBMkQ7QUFDM0Qsd0RBQXdEO0FBRXhELGlGQUFpRjtBQUNqRixrRkFBa0Y7QUFDbEYsK0VBQStFO0FBQy9FLCtFQUErRTtBQUMvRSwyREFBMkQ7QUFDM0QsTUFBTVcsdUNBQXVDO0lBQ3pDQyxRQUFRQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSztJQUMxQ0MsU0FBUztBQUNiO0FBQ0EsTUFBTUMsbUNBQWlELFdBQUgsR0FBSSxJQUFHbEIsa0NBQVcsRUFBR21CLGFBQWEsQ0FBQ1I7QUFDdkYsTUFBTVMscUNBQW1ELFdBQUgsR0FBSSxJQUFHcEIsa0NBQVcsRUFBR21CLGFBQWEsQ0FBQztBQUN6RixtQ0FBbUM7QUFDbkMsU0FBU0Usd0NBQXdDQyxLQUFLO0lBQ2xELElBQUlDLE1BQU0sQ0FBQyxHQUFHckIsNkNBQWdCLEVBQUdnQjtJQUNqQyxJQUFJTSxVQUFVQyxpQ0FBaUNGLFFBQVFaO0lBQ3ZELElBQUksQ0FBQ2UsT0FBT0MsU0FBUyxHQUFHLENBQUMsR0FBR3ZCLDJDQUFjLEVBQUc7SUFDN0MsSUFBSXdCLFFBQVEsQ0FBQyxHQUFHdEIsMENBQWEsRUFBRyxJQUFLO1lBQzdCLGlGQUFpRjtZQUNqRixvQ0FBb0M7WUFDcENNLFFBQVFXLFFBQVFaLHVDQUF1QyxLQUFLLENBQUMsRUFBRVksSUFBSVgsTUFBTSxDQUFDLENBQUMsRUFBRVksUUFBUSxDQUFDO1lBQ3RGUCxTQUFTO1FBQ2IsSUFBSTtRQUNKTTtRQUNBQztLQUNIO0lBQ0QscUVBQXFFO0lBQ3JFLHlFQUF5RTtJQUN6RSxJQUFJLE9BQU9LLGFBQWEsYUFHeEIsc0RBRnNEO0lBQ3RELHNEQUFzRDtJQUNyRCxJQUFHckIsa0RBQXFCLEVBQUc7UUFDeEJtQixTQUFTO0lBQ2IsR0FBRyxFQUFFO0lBQ0wsT0FBcUIsV0FBSCxHQUFJLElBQUczQixrQ0FBVyxFQUFHOEIsYUFBYSxDQUFDWixpQ0FBaUNhLFFBQVEsRUFBRTtRQUM1RkgsT0FBT0E7SUFDWCxHQUFpQixXQUFILEdBQUksSUFBRzVCLGtDQUFXLEVBQUc4QixhQUFhLENBQUNWLG1DQUFtQ1csUUFBUSxFQUFFO1FBQzFGSCxPQUFPRjtJQUNYLEdBQUdKLE1BQU1VLFFBQVE7QUFDckI7QUFDQSxJQUFJQywrQ0FBK0M7QUFDbkQsU0FBU0MsMENBQTBDWixLQUFLO0lBQ3BELElBQUksT0FBTyxDQUFDLEdBQUd0QixrQ0FBVyxDQUFFLENBQUMsUUFBUSxLQUFLLFlBQVk7UUFDbEQsSUFBSW1DLEtBQStCLElBQUksQ0FBQ0YsOENBQThDO1lBQ2xGRyxRQUFRQyxJQUFJLENBQUM7WUFDYkosK0NBQStDO1FBQ25EO1FBQ0EsT0FBcUIsV0FBSCxHQUFJLElBQUdqQyxrQ0FBVyxFQUFHOEIsYUFBYSxDQUFDLENBQUMsR0FBRzlCLGtDQUFXLEVBQUdzQyxRQUFRLEVBQUUsTUFBTWhCLE1BQU1VLFFBQVE7SUFDekc7SUFDQSxPQUFxQixXQUFILEdBQUksSUFBR2hDLGtDQUFXLEVBQUc4QixhQUFhLENBQUNULHlDQUF5Q0M7QUFDbEc7QUFDQSxJQUFJaUIsa0NBQWtDQyxRQUFRLE1BQWdELElBQUlDLENBQTZCO0FBQy9ILElBQUlDLHFDQUFxQyxJQUFJQztBQUM3QyxTQUFTbEIsaUNBQWlDbUIsYUFBYSxLQUFLO0lBQ3hELElBQUlDLE1BQU0sQ0FBQyxHQUFHM0MsNkNBQWdCLEVBQUdnQjtJQUNqQyxJQUFJNEIsTUFBTSxDQUFDLEdBQUdwQyx5Q0FBWSxFQUFHO0lBQzdCLGdEQUFnRDtJQUNoRCxJQUFJb0MsSUFBSTdCLE9BQU8sS0FBSyxRQUFRLENBQUMyQixZQUFZO1FBQ3JDLElBQUlHLDZFQUE2RUM7UUFDakYsMEdBQTBHO1FBQzFHLHdHQUF3RztRQUN4Ryx1R0FBdUc7UUFDdkcsK0dBQStHO1FBQy9HLGdIQUFnSDtRQUNoSCx1SEFBdUg7UUFDdkgsMkdBQTJHO1FBQzNHLHlHQUF5RztRQUN6RyxnRkFBZ0Y7UUFDaEYsYUFBYTtRQUNiLElBQUlDLGVBQWUsQ0FBQ0QsNERBQTRELENBQUMsR0FBR2hELGtDQUFXLEVBQUdrRCxrREFBa0QsTUFBTSxRQUFRRiw4REFBOEQsS0FBSyxJQUFJLEtBQUssSUFBSSxDQUFDRCw4RUFBOEVDLDBEQUEwREcsaUJBQWlCLE1BQU0sUUFBUUosZ0ZBQWdGLEtBQUssSUFBSSxLQUFLLElBQUlBLDRFQUE0RTlCLE9BQU87UUFDL2tCLElBQUlnQyxjQUFjO1lBQ2QsSUFBSUcscUJBQXFCVixtQ0FBbUNXLEdBQUcsQ0FBQ0o7WUFDaEUsSUFBSUcsc0JBQXNCLE1BQzFCVixtQ0FBbUNZLEdBQUcsQ0FBQ0wsY0FBYztnQkFDakRNLElBQUlWLElBQUk1QixPQUFPO2dCQUNmdUMsT0FBT1AsYUFBYVEsYUFBYTtZQUNyQztpQkFDSyxJQUFJUixhQUFhUSxhQUFhLEtBQUtMLG1CQUFtQkksS0FBSyxFQUFFO2dCQUM5RCwrREFBK0Q7Z0JBQy9ELDhEQUE4RDtnQkFDOUQsc0NBQXNDO2dCQUN0Q1gsSUFBSTVCLE9BQU8sR0FBR21DLG1CQUFtQkcsRUFBRTtnQkFDbkNiLG1DQUFtQ2dCLE1BQU0sQ0FBQ1Q7WUFDOUM7UUFDSjtRQUNBLGdEQUFnRDtRQUNoREgsSUFBSTdCLE9BQU8sR0FBRyxFQUFFNEIsSUFBSTVCLE9BQU87SUFDL0I7SUFDQSxnREFBZ0Q7SUFDaEQsT0FBTzZCLElBQUk3QixPQUFPO0FBQ3RCO0FBQ0EsU0FBUzBDLHlDQUF5Q0MsU0FBUztJQUN2RCxJQUFJZixNQUFNLENBQUMsR0FBRzNDLDZDQUFnQixFQUFHZ0I7SUFDakMsNEVBQTRFO0lBQzVFLHlEQUF5RDtJQUN6RCxJQUFJMkIsUUFBUWxDLHdDQUF3QyxDQUFDNEIsaUNBQWlDSCxRQUFRQyxJQUFJLENBQUM7SUFDbkcsSUFBSWIsVUFBVUMsaUNBQWlDLENBQUMsQ0FBQ21DO0lBQ2pELElBQUloRCxTQUFTaUMsUUFBUWxDLHdDQUF3Q3dCLGtCQUF5QixTQUFTLENBQVksR0FBRyxDQUFDLFVBQVUsRUFBRVUsSUFBSWpDLE1BQU0sQ0FBQyxDQUFDO0lBQ3ZJLE9BQU9nRCxhQUFhLENBQUMsRUFBRWhELE9BQU8sQ0FBQyxFQUFFWSxRQUFRLENBQUM7QUFDOUM7QUFDQSxTQUFTcUMseUNBQXlDRCxTQUFTO0lBQ3ZELGFBQWE7SUFDYixJQUFJTCxLQUFLLENBQUMsR0FBR3ZELGtDQUFXLEVBQUc4RCxLQUFLO0lBQ2hDLElBQUksQ0FBQ0MsT0FBTyxHQUFHLENBQUMsR0FBRzNELDJDQUFjLEVBQUc0RDtJQUNwQyxJQUFJcEQsU0FBU21ELFVBQVU1QixrQkFBeUIsU0FBUyxlQUFlLENBQUMsVUFBVSxFQUFFeEIscUNBQXFDQyxNQUFNLENBQUMsQ0FBQztJQUNsSSxPQUFPZ0QsYUFBYSxDQUFDLEVBQUVoRCxPQUFPLENBQUMsRUFBRTJDLEdBQUcsQ0FBQztBQUN6QztBQUNBLE1BQU1VLDRDQUE0QyxPQUFPLENBQUMsR0FBR2pFLGtDQUFXLENBQUUsQ0FBQyxRQUFRLEtBQUssYUFBYTZELDJDQUEyQ0Y7QUFDaEosU0FBU087SUFDTCxPQUFPO0FBQ1g7QUFDQSxTQUFTQztJQUNMLE9BQU87QUFDWDtBQUNBLDZEQUE2RDtBQUM3RCxTQUFTQyxnQ0FBZ0NDLGFBQWE7SUFDbEQsT0FBTztJQUNQLE9BQU8sS0FBSztBQUNoQjtBQUNBLFNBQVNMO0lBQ0wsaUdBQWlHO0lBQ2pHLElBQUksT0FBTyxDQUFDLEdBQUdoRSxrQ0FBVyxDQUFFLENBQUMsdUJBQXVCLEtBQUssWUFBWSxPQUFPLENBQUMsR0FBR0Esa0NBQVcsQ0FBRSxDQUFDLHVCQUF1QixDQUFDb0UsaUNBQWlDRixtQ0FBbUNDO0lBQzFMLHNEQUFzRDtJQUN0RCxPQUFPLENBQUMsR0FBR2pFLDZDQUFnQixFQUFHa0I7QUFDbEM7QUFLb0wsQ0FDcEwsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3Nzci9kaXN0L2ltcG9ydC5tanM/MzBlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJDczU0p4JHJlYWN0LCB7dXNlQ29udGV4dCBhcyAkNzNTSngkdXNlQ29udGV4dCwgdXNlU3RhdGUgYXMgJDczU0p4JHVzZVN0YXRlLCB1c2VNZW1vIGFzICQ3M1NKeCR1c2VNZW1vLCB1c2VMYXlvdXRFZmZlY3QgYXMgJDczU0p4JHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIGFzICQ3M1NKeCR1c2VSZWZ9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFdlIG11c3QgYXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5IHdpdGggQHJlYWN0LWFyaWEvdXRpbHMsIGFuZCB0aGlzIHVzZUxheW91dEVmZmVjdCBpc1xuLy8gZ3VhcmRlZCBieSBhIGNoZWNrIHRoYXQgaXQgb25seSBydW5zIG9uIHRoZSBjbGllbnQgc2lkZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci91c2VMYXlvdXRFZmZlY3RSdWxlXG5cbi8vIERlZmF1bHQgY29udGV4dCB2YWx1ZSB0byB1c2UgaW4gY2FzZSB0aGVyZSBpcyBubyBTU1JQcm92aWRlci4gVGhpcyBpcyBmaW5lIGZvclxuLy8gY2xpZW50LW9ubHkgYXBwcy4gSW4gb3JkZXIgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgQXJpYSBwb3RlbnRpYWxseVxuLy8gYmVpbmcgb24gdGhlIHBhZ2UgYXQgb25jZSwgdGhlIHByZWZpeCBpcyBzZXQgdG8gYSByYW5kb20gbnVtYmVyLiBTU1JQcm92aWRlclxuLy8gd2lsbCByZXNldCB0aGlzIHRvIHplcm8gZm9yIGNvbnNpc3RlbmN5IGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQsIHNvIGluIHRoZVxuLy8gU1NSIGNhc2UgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IEFyaWEgaXMgbm90IHN1cHBvcnRlZC5cbmNvbnN0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCA9IHtcbiAgICBwcmVmaXg6IFN0cmluZyhNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMCkpLFxuICAgIGN1cnJlbnQ6IDBcbn07XG5jb25zdCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlQ29udGV4dCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQpO1xuY29uc3QgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJElzU1NSQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vLyBUaGlzIGlzIG9ubHkgdXNlZCBpbiBSZWFjdCA8IDE4LlxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJExlZ2FjeVNTUlByb3ZpZGVyKHByb3BzKSB7XG4gICAgbGV0IGN1ciA9ICgwLCAkNzNTSngkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIGxldCBjb3VudGVyID0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoY3VyID09PSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQpO1xuICAgIGxldCBbaXNTU1IsIHNldElzU1NSXSA9ICgwLCAkNzNTSngkdXNlU3RhdGUpKHRydWUpO1xuICAgIGxldCB2YWx1ZSA9ICgwLCAkNzNTSngkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBTU1JQcm92aWRlciwgc3RhcnQgd2l0aCBhbiBlbXB0eSBzdHJpbmcgcHJlZml4LCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIGFwcGVuZCBhbmQgaW5jcmVtZW50IHRoZSBjb3VudGVyLlxuICAgICAgICAgICAgcHJlZml4OiBjdXIgPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCA/IFwiXCIgOiBgJHtjdXIucHJlZml4fS0ke2NvdW50ZXJ9YCxcbiAgICAgICAgICAgIGN1cnJlbnQ6IDBcbiAgICAgICAgfSksIFtcbiAgICAgICAgY3VyLFxuICAgICAgICBjb3VudGVyXG4gICAgXSk7XG4gICAgLy8gSWYgb24gdGhlIGNsaWVudCwgYW5kIHRoZSBjb21wb25lbnQgd2FzIGluaXRpYWxseSBzZXJ2ZXIgcmVuZGVyZWQsXG4gICAgLy8gdGhlbiBzY2hlZHVsZSBhIGxheW91dCBlZmZlY3QgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQgYWZ0ZXIgaHlkcmF0aW9uLlxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIC8vIFRoaXMgaWYgc3RhdGVtZW50IHRlY2huaWNhbGx5IGJyZWFrcyB0aGUgcnVsZXMgb2YgaG9va3MsIGJ1dCBpcyBzYWZlXG4gICAgLy8gYmVjYXVzZSB0aGUgY29uZGl0aW9uIG5ldmVyIGNoYW5nZXMgYWZ0ZXIgbW91bnRpbmcuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgKDAsICQ3M1NKeCR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIHNldElzU1NSKGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlRWxlbWVudCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9LCAvKiNfX1BVUkVfXyovICgwLCAkNzNTSngkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJElzU1NSQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogaXNTU1JcbiAgICB9LCBwcm9wcy5jaGlsZHJlbikpO1xufVxubGV0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciR3YXJuZWRBYm91dFNTUlByb3ZpZGVyID0gZmFsc2U7XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkOWY4YWM5NmFmNGIxYjJhZShwcm9wcykge1xuICAgIGlmICh0eXBlb2YgKDAsICQ3M1NKeCRyZWFjdClbXCJ1c2VJZFwiXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJ0ZXN0XCIgJiYgISRiNWUyNTdkNTY5Njg4YWM2JHZhciR3YXJuZWRBYm91dFNTUlByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbiBSZWFjdCAxOCwgU1NSUHJvdmlkZXIgaXMgbm90IG5lY2Vzc2FyeSBhbmQgaXMgYSBub29wLiBZb3UgY2FuIHJlbW92ZSBpdCBmcm9tIHlvdXIgYXBwLlwiKTtcbiAgICAgICAgICAgICRiNWUyNTdkNTY5Njg4YWM2JHZhciR3YXJuZWRBYm91dFNTUlByb3ZpZGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVFbGVtZW50KCgwLCAkNzNTSngkcmVhY3QpLkZyYWdtZW50LCBudWxsLCBwcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkNzNTSngkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJExlZ2FjeVNTUlByb3ZpZGVyLCBwcm9wcyk7XG59XG5sZXQgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNhblVzZURPTSA9IEJvb2xlYW4odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubGV0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoaXNEaXNhYmxlZCA9IGZhbHNlKSB7XG4gICAgbGV0IGN0eCA9ICgwLCAkNzNTSngkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIGxldCByZWYgPSAoMCwgJDczU0p4JHVzZVJlZikobnVsbCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3B1cmUtcmVuZGVyXG4gICAgaWYgKHJlZi5jdXJyZW50ID09PSBudWxsICYmICFpc0Rpc2FibGVkKSB7XG4gICAgICAgIHZhciBfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIsIF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICAgICAgLy8gSW4gc3RyaWN0IG1vZGUsIFJlYWN0IHJlbmRlcnMgY29tcG9uZW50cyB0d2ljZSwgYW5kIHRoZSByZWYgd2lsbCBiZSByZXNldCB0byBudWxsIG9uIHRoZSBzZWNvbmQgcmVuZGVyLlxuICAgICAgICAvLyBUaGlzIG1lYW5zIG91ciBpZCBjb3VudGVyIHdpbGwgYmUgaW5jcmVtZW50ZWQgdHdpY2UgaW5zdGVhZCBvZiBvbmNlLiBUaGlzIGlzIGEgcHJvYmxlbSBiZWNhdXNlIG9uIHRoZVxuICAgICAgICAvLyBzZXJ2ZXIsIGNvbXBvbmVudHMgYXJlIG9ubHkgcmVuZGVyZWQgb25jZSBhbmQgc28gaWRzIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyIHdvbid0IG1hdGNoIHRoZSBjbGllbnQuXG4gICAgICAgIC8vIEluIFJlYWN0IDE4LCB1c2VJZCB3YXMgaW50cm9kdWNlZCB0byBzb2x2ZSB0aGlzLCBidXQgaXQgaXMgbm90IGF2YWlsYWJsZSBpbiBvbGRlciB2ZXJzaW9ucy4gU28gdG8gc29sdmUgdGhpc1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHVzZSBzb21lIFJlYWN0IGludGVybmFscyB0byBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgRmliZXIgaW5zdGFuY2UsIHdoaWNoIGlzIHN0YWJsZSBiZXR3ZWVuIHJlbmRlcnMuXG4gICAgICAgIC8vIFRoaXMgaXMgZXhwb3NlZCBhcyBSZWFjdEN1cnJlbnRPd25lciBpbiBkZXZlbG9wbWVudCwgd2hpY2ggaXMgYWxsIHdlIG5lZWQgc2luY2UgU3RyaWN0TW9kZSBvbmx5IHJ1bnMgaW4gZGV2ZWxvcG1lbnQuXG4gICAgICAgIC8vIFRvIGVuc3VyZSB0aGF0IHdlIG9ubHkgaW5jcmVtZW50IHRoZSBnbG9iYWwgY291bnRlciBvbmNlLCB3ZSBzdG9yZSB0aGUgc3RhcnRpbmcgaWQgZm9yIHRoaXMgY29tcG9uZW50IGluXG4gICAgICAgIC8vIGEgd2VhayBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoZSBGaWJlci4gT24gdGhlIHNlY29uZCByZW5kZXIsIHdlIHJlc2V0IHRoZSBnbG9iYWwgY291bnRlciB0byB0aGlzIHZhbHVlLlxuICAgICAgICAvLyBTaW5jZSBSZWFjdCBydW5zIHRoZSBzZWNvbmQgcmVuZGVyIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBmaXJzdCwgdGhpcyBpcyBzYWZlLlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBjdXJyZW50T3duZXIgPSAoX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gKDAsICQ3M1NKeCRyZWFjdCkuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQpID09PSBudWxsIHx8IF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lciA9IF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcikgPT09IG51bGwgfHwgX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEX1JlYWN0Q3VycmVudE93bmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGN1cnJlbnRPd25lcikge1xuICAgICAgICAgICAgbGV0IHByZXZDb21wb25lbnRWYWx1ZSA9ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMuZ2V0KGN1cnJlbnRPd25lcik7XG4gICAgICAgICAgICBpZiAocHJldkNvbXBvbmVudFZhbHVlID09IG51bGwpIC8vIE9uIHRoZSBmaXJzdCByZW5kZXIsIGFuZCBmaXJzdCBjYWxsIHRvIHVzZUlkLCBzdG9yZSB0aGUgaWQgYW5kIHN0YXRlIGluIG91ciB3ZWFrIG1hcC5cbiAgICAgICAgICAgICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMuc2V0KGN1cnJlbnRPd25lciwge1xuICAgICAgICAgICAgICAgIGlkOiBjdHguY3VycmVudCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogY3VycmVudE93bmVyLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudE93bmVyLm1lbW9pemVkU3RhdGUgIT09IHByZXZDb21wb25lbnRWYWx1ZS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIE9uIHRoZSBzZWNvbmQgcmVuZGVyLCB0aGUgbWVtb2l6ZWRTdGF0ZSBnZXRzIHJlc2V0IGJ5IFJlYWN0LlxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjb3VudGVyLCBhbmQgcmVtb3ZlIGZyb20gdGhlIHdlYWsgbWFwIHNvIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gZG8gdGhpcyBmb3Igc3Vic2VxdWVudCB1c2VJZCBjYWxscy5cbiAgICAgICAgICAgICAgICBjdHguY3VycmVudCA9IHByZXZDb21wb25lbnRWYWx1ZS5pZDtcbiAgICAgICAgICAgICAgICAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY29tcG9uZW50SWRzLmRlbGV0ZShjdXJyZW50T3duZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci9wdXJlLXJlbmRlclxuICAgICAgICByZWYuY3VycmVudCA9ICsrY3R4LmN1cnJlbnQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci9wdXJlLXJlbmRlclxuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JHZhciR1c2VMZWdhY3lTU1JTYWZlSWQoZGVmYXVsdElkKSB7XG4gICAgbGV0IGN0eCA9ICgwLCAkNzNTSngkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIC8vIElmIHdlIGFyZSByZW5kZXJpbmcgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCBhbmQgdGhlcmUncyBubyBTU1JQcm92aWRlcixcbiAgICAvLyBwcm92aWRlIGEgd2FybmluZyB0byBoaW50IHRvIHRoZSBkZXZlbG9wZXIgdG8gYWRkIG9uZS5cbiAgICBpZiAoY3R4ID09PSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQgJiYgISRiNWUyNTdkNTY5Njg4YWM2JHZhciRjYW5Vc2VET00pIGNvbnNvbGUud2FybihcIldoZW4gc2VydmVyIHJlbmRlcmluZywgeW91IG11c3Qgd3JhcCB5b3VyIGFwcGxpY2F0aW9uIGluIGFuIDxTU1JQcm92aWRlcj4gdG8gZW5zdXJlIGNvbnNpc3RlbnQgaWRzIGFyZSBnZW5lcmF0ZWQgYmV0d2VlbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIuXCIpO1xuICAgIGxldCBjb3VudGVyID0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoISFkZWZhdWx0SWQpO1xuICAgIGxldCBwcmVmaXggPSBjdHggPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyBcInJlYWN0LWFyaWFcIiA6IGByZWFjdC1hcmlhJHtjdHgucHJlZml4fWA7XG4gICAgcmV0dXJuIGRlZmF1bHRJZCB8fCBgJHtwcmVmaXh9LSR7Y291bnRlcn1gO1xufVxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZU1vZGVyblNTUlNhZmVJZChkZWZhdWx0SWQpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IGlkID0gKDAsICQ3M1NKeCRyZWFjdCkudXNlSWQoKTtcbiAgICBsZXQgW2RpZFNTUl0gPSAoMCwgJDczU0p4JHVzZVN0YXRlKSgkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNTM1YmQ2Y2E3ZjkwYTI3MygpKTtcbiAgICBsZXQgcHJlZml4ID0gZGlkU1NSIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IFwicmVhY3QtYXJpYVwiIDogYHJlYWN0LWFyaWEkeyRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dC5wcmVmaXh9YDtcbiAgICByZXR1cm4gZGVmYXVsdElkIHx8IGAke3ByZWZpeH0tJHtpZH1gO1xufVxuY29uc3QgJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDYxOTUwMDk1OWZjNDhiMjYgPSB0eXBlb2YgKDAsICQ3M1NKeCRyZWFjdClbXCJ1c2VJZFwiXSA9PT0gXCJmdW5jdGlvblwiID8gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZU1vZGVyblNTUlNhZmVJZCA6ICRiNWUyNTdkNTY5Njg4YWM2JHZhciR1c2VMZWdhY3lTU1JTYWZlSWQ7XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U25hcHNob3QoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHN1YnNjcmliZShvblN0b3JlQ2hhbmdlKSB7XG4gICAgLy8gbm9vcFxuICAgIHJldHVybiAoKT0+e307XG59XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNTM1YmQ2Y2E3ZjkwYTI3MygpIHtcbiAgICAvLyBJbiBSZWFjdCAxOCwgd2UgY2FuIHVzZSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB0byBkZXRlY3QgaWYgd2UncmUgc2VydmVyIHJlbmRlcmluZyBvciBoeWRyYXRpbmcuXG4gICAgaWYgKHR5cGVvZiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCJdID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCJdKCRiNWUyNTdkNTY5Njg4YWM2JHZhciRzdWJzY3JpYmUsICRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTbmFwc2hvdCwgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNlcnZlclNuYXBzaG90KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICByZXR1cm4gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0KTtcbn1cblxuXG5cblxuZXhwb3J0IHskYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkOWY4YWM5NmFmNGIxYjJhZSBhcyBTU1JQcm92aWRlciwgJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDYxOTUwMDk1OWZjNDhiMjYgYXMgdXNlU1NSU2FmZUlkLCAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNTM1YmQ2Y2E3ZjkwYTI3MyBhcyB1c2VJc1NTUn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJDczU0p4JHJlYWN0IiwidXNlQ29udGV4dCIsIiQ3M1NKeCR1c2VDb250ZXh0IiwidXNlU3RhdGUiLCIkNzNTSngkdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJDczU0p4JHVzZU1lbW8iLCJ1c2VMYXlvdXRFZmZlY3QiLCIkNzNTSngkdXNlTGF5b3V0RWZmZWN0IiwidXNlUmVmIiwiJDczU0p4JHVzZVJlZiIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCIsInByZWZpeCIsIlN0cmluZyIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsImN1cnJlbnQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJExlZ2FjeVNTUlByb3ZpZGVyIiwicHJvcHMiLCJjdXIiLCJjb3VudGVyIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIiLCJpc1NTUiIsInNldElzU1NSIiwidmFsdWUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsImNoaWxkcmVuIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIiLCIkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkOWY4YWM5NmFmNGIxYjJhZSIsInByb2Nlc3MiLCJjb25zb2xlIiwid2FybiIsIkZyYWdtZW50IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNhblVzZURPTSIsIkJvb2xlYW4iLCJ3aW5kb3ciLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY29tcG9uZW50SWRzIiwiV2Vha01hcCIsImlzRGlzYWJsZWQiLCJjdHgiLCJyZWYiLCJfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIiLCJfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJjdXJyZW50T3duZXIiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwicHJldkNvbXBvbmVudFZhbHVlIiwiZ2V0Iiwic2V0IiwiaWQiLCJzdGF0ZSIsIm1lbW9pemVkU3RhdGUiLCJkZWxldGUiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTGVnYWN5U1NSU2FmZUlkIiwiZGVmYXVsdElkIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZU1vZGVyblNTUlNhZmVJZCIsInVzZUlkIiwiZGlkU1NSIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDUzNWJkNmNhN2Y5MGEyNzMiLCIkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNjE5NTAwOTU5ZmM0OGIyNiIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTbmFwc2hvdCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTZXJ2ZXJTbmFwc2hvdCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRzdWJzY3JpYmUiLCJvblN0b3JlQ2hhbmdlIiwiU1NSUHJvdmlkZXIiLCJ1c2VTU1JTYWZlSWQiLCJ1c2VJc1NTUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/virtualizer/node_modules/@react-aria/ssr/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/virtualizer/node_modules/@react-aria/utils/dist/import.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/@react-stately/virtualizer/node_modules/@react-aria/utils/dist/import.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RouterProvider: () => (/* binding */ $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb),\n/* harmony export */   chain: () => (/* binding */ $ff5963eb1fccf552$export$e08e3b67e392101e),\n/* harmony export */   clamp: () => (/* reexport safe */ _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.clamp),\n/* harmony export */   filterDOMProps: () => (/* binding */ $65484d02dcb7eb3e$export$457c3d6518dd4c6f),\n/* harmony export */   focusWithoutScrolling: () => (/* binding */ $7215afc6de606d6b$export$de79e2c695e052f3),\n/* harmony export */   getOffset: () => (/* binding */ $ab71dadb03a6fb2e$export$622cea445a1c5b7d),\n/* harmony export */   getOwnerDocument: () => (/* binding */ $431fbd86ca7dc216$export$b204af158042fbac),\n/* harmony export */   getOwnerWindow: () => (/* binding */ $431fbd86ca7dc216$export$f21a1ffae260145a),\n/* harmony export */   getScrollParent: () => (/* binding */ $62d8ded9296f3872$export$cfa2225e87938781),\n/* harmony export */   getSyntheticLinkProps: () => (/* binding */ $ea8dcbcb9ea1b556$export$51437d503373d223),\n/* harmony export */   isAndroid: () => (/* binding */ $c87311424ea30a05$export$a11b0059900ceec8),\n/* harmony export */   isAppleDevice: () => (/* binding */ $c87311424ea30a05$export$e1865c3bedcd822b),\n/* harmony export */   isChrome: () => (/* binding */ $c87311424ea30a05$export$6446a186d09e379e),\n/* harmony export */   isFirefox: () => (/* binding */ $c87311424ea30a05$export$b7d78993b74f766d),\n/* harmony export */   isIOS: () => (/* binding */ $c87311424ea30a05$export$fedb369cb70207f1),\n/* harmony export */   isIPad: () => (/* binding */ $c87311424ea30a05$export$7bef049ce92e4224),\n/* harmony export */   isIPhone: () => (/* binding */ $c87311424ea30a05$export$186c6964ca17d99),\n/* harmony export */   isMac: () => (/* binding */ $c87311424ea30a05$export$9ac100e40613ea10),\n/* harmony export */   isScrollable: () => (/* binding */ $62d8ded9296f3872$export$2bb74740c4e19def),\n/* harmony export */   isVirtualClick: () => (/* binding */ $6a7db85432448f7f$export$60278871457622de),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ $6a7db85432448f7f$export$29bf1b5f2c56cf63),\n/* harmony export */   isWebKit: () => (/* binding */ $c87311424ea30a05$export$78551043582a6a98),\n/* harmony export */   mergeIds: () => (/* binding */ $bdb11010cef70236$export$cd8c9cb68f842629),\n/* harmony export */   mergeProps: () => (/* binding */ $3ef42575df84b30b$export$9d1611c77c2fe928),\n/* harmony export */   mergeRefs: () => (/* binding */ $5dc95899b306f630$export$c9058316764c140e),\n/* harmony export */   openLink: () => (/* binding */ $ea8dcbcb9ea1b556$export$95185d699e05d4d7),\n/* harmony export */   runAfterTransition: () => (/* binding */ $bbed8b41f857bcc0$export$24490316f764c430),\n/* harmony export */   scrollIntoView: () => (/* binding */ $2f04cbc44ee30ce0$export$53a0910f038337bd),\n/* harmony export */   scrollIntoViewport: () => (/* binding */ $2f04cbc44ee30ce0$export$c826860796309d1b),\n/* harmony export */   shouldClientNavigate: () => (/* binding */ $ea8dcbcb9ea1b556$export$efa8c9099e530235),\n/* harmony export */   snapValueToStep: () => (/* reexport safe */ _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.snapValueToStep),\n/* harmony export */   useDeepMemo: () => (/* binding */ $5a387cc49350e6db$export$722debc0e56fea39),\n/* harmony export */   useDescription: () => (/* binding */ $ef06256079686ba0$export$f8aeda7b10753fa1),\n/* harmony export */   useDrag1D: () => (/* binding */ $9cc09df9fd7676be$export$7bbed75feba39706),\n/* harmony export */   useEffectEvent: () => (/* binding */ $8ae05eaa5c114e9c$export$7f54fc3180508a52),\n/* harmony export */   useEvent: () => (/* binding */ $e9faafb641e167db$export$90fc3a17d93f704c),\n/* harmony export */   useFormReset: () => (/* binding */ $99facab73266f662$export$5add1d006293d136),\n/* harmony export */   useGlobalListeners: () => (/* binding */ $03deb23ff14920c4$export$4eaf04e54aa8eed6),\n/* harmony export */   useId: () => (/* binding */ $bdb11010cef70236$export$f680877a34711e37),\n/* harmony export */   useLabels: () => (/* binding */ $313b98861ee5dd6c$export$d6875122194c7b44),\n/* harmony export */   useLayoutEffect: () => (/* binding */ $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c),\n/* harmony export */   useObjectRef: () => (/* binding */ $df56164dff5785e2$export$4338b53315abf666),\n/* harmony export */   useResizeObserver: () => (/* binding */ $9daab02d461809db$export$683480f191c0e3ea),\n/* harmony export */   useRouter: () => (/* binding */ $ea8dcbcb9ea1b556$export$9a302a45f65d0572),\n/* harmony export */   useSlotId: () => (/* binding */ $bdb11010cef70236$export$b4cc09c592e8fdb8),\n/* harmony export */   useSyncRef: () => (/* binding */ $e7801be82b4b2a53$export$4debdb1a3f0fa79e),\n/* harmony export */   useUpdateEffect: () => (/* binding */ $4f58c5f72bcf79f7$export$496315a1608d9602),\n/* harmony export */   useValueEffect: () => (/* binding */ $1dbecbe27a04f9af$export$14d238f342723f25),\n/* harmony export */   useViewportSize: () => (/* binding */ $5df64b3807dc15ee$export$d699905dd57c73ca)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/ssr */ \"(ssr)/./node_modules/@react-stately/virtualizer/node_modules/@react-aria/ssr/dist/import.mjs\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/@react-stately/virtualizer/node_modules/clsx/dist/clsx.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== \"undefined\" ? (0, react__WEBPACK_IMPORTED_MODULE_0__).useLayoutEffect : ()=>{};\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {\n    const ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        ref.current = fn;\n    }, [\n        fn\n    ]);\n    // @ts-ignore\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        const f = ref.current;\n        return f === null || f === void 0 ? void 0 : f(...args);\n    }, []);\n}\nfunction $1dbecbe27a04f9af$export$14d238f342723f25(defaultValue) {\n    let [value1, setValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue);\n    let effect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Store the function in a ref so we can always access the current version\n    // which has the proper `value` in scope.\n    let nextRef = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{\n        if (!effect.current) return;\n        // Run the generator to the next yield.\n        let newValue = effect.current.next();\n        // If the generator is done, reset the effect.\n        if (newValue.done) {\n            effect.current = null;\n            return;\n        }\n        // If the value is the same as the current value,\n        // then continue to the next yield. Otherwise,\n        // set the value in state and wait for the next layout effect.\n        if (value1 === newValue.value) nextRef();\n        else setValue(newValue.value);\n    });\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        // If there is an effect currently running, continue to the next yield.\n        if (effect.current) nextRef();\n    });\n    let queue = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((fn)=>{\n        effect.current = fn(value1);\n        nextRef();\n    });\n    return [\n        value1,\n        queue\n    ];\n}\n// copied from SSRProvider.tsx to reduce exports, if needed again, consider sharing\nlet $bdb11010cef70236$var$canUseDOM = Boolean( false && 0);\nlet $bdb11010cef70236$var$idsUpdaterMap = new Map();\nfunction $bdb11010cef70236$export$f680877a34711e37(defaultId) {\n    let [value1, setValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultId);\n    let nextId = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let res = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__.useSSRSafeId)(value1);\n    let updateValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((val)=>{\n        nextId.current = val;\n    }, []);\n    if ($bdb11010cef70236$var$canUseDOM) $bdb11010cef70236$var$idsUpdaterMap.set(res, updateValue);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        let r = res;\n        return ()=>{\n            $bdb11010cef70236$var$idsUpdaterMap.delete(r);\n        };\n    }, [\n        res\n    ]);\n    // This cannot cause an infinite loop because the ref is updated first.\n    // eslint-disable-next-line\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let newId = nextId.current;\n        if (newId) {\n            nextId.current = null;\n            setValue(newId);\n        }\n    });\n    return res;\n}\nfunction $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {\n    if (idA === idB) return idA;\n    let setIdA = $bdb11010cef70236$var$idsUpdaterMap.get(idA);\n    if (setIdA) {\n        setIdA(idB);\n        return idB;\n    }\n    let setIdB = $bdb11010cef70236$var$idsUpdaterMap.get(idB);\n    if (setIdB) {\n        setIdB(idA);\n        return idA;\n    }\n    return idB;\n}\nfunction $bdb11010cef70236$export$b4cc09c592e8fdb8(depArray = []) {\n    let id = $bdb11010cef70236$export$f680877a34711e37();\n    let [resolvedId, setResolvedId] = (0, $1dbecbe27a04f9af$export$14d238f342723f25)(id);\n    let updateId = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResolvedId(function*() {\n            yield id;\n            yield document.getElementById(id) ? id : undefined;\n        });\n    }, [\n        id,\n        setResolvedId\n    ]);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updateId, [\n        id,\n        updateId,\n        ...depArray\n    ]);\n    return resolvedId;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Calls all functions in the order they were chained with the same arguments.\n */ function $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks) {\n    return (...args)=>{\n        for (let callback of callbacks)if (typeof callback === \"function\") callback(...args);\n    };\n}\nconst $431fbd86ca7dc216$export$b204af158042fbac = (el)=>{\n    var _el_ownerDocument;\n    return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;\n};\nconst $431fbd86ca7dc216$export$f21a1ffae260145a = (el)=>{\n    if (el && \"window\" in el && el.window === el) return el;\n    const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);\n    return doc.defaultView || window;\n};\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $3ef42575df84b30b$export$9d1611c77c2fe928(...args) {\n    // Start with a base clone of the first argument. This is a lot faster than starting\n    // with an empty object and adding properties as we go.\n    let result = {\n        ...args[0]\n    };\n    for(let i = 1; i < args.length; i++){\n        let props = args[i];\n        for(let key in props){\n            let a = result[key];\n            let b = props[key];\n            // Chain events\n            if (typeof a === \"function\" && typeof b === \"function\" && // This is a lot faster than a regex.\n            key[0] === \"o\" && key[1] === \"n\" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(a, b);\n            else if ((key === \"className\" || key === \"UNSAFE_className\") && typeof a === \"string\" && typeof b === \"string\") result[key] = (0, clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a, b);\n            else if (key === \"id\" && a && b) result.id = (0, $bdb11010cef70236$export$cd8c9cb68f842629)(a, b);\n            else result[key] = b !== undefined ? b : a;\n        }\n    }\n    return result;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $5dc95899b306f630$export$c9058316764c140e(...refs) {\n    if (refs.length === 1) return refs[0];\n    return (value1)=>{\n        for (let ref of refs){\n            if (typeof ref === \"function\") ref(value1);\n            else if (ref != null) ref.current = value1;\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $65484d02dcb7eb3e$var$DOMPropNames = new Set([\n    \"id\"\n]);\nconst $65484d02dcb7eb3e$var$labelablePropNames = new Set([\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-describedby\",\n    \"aria-details\"\n]);\n// See LinkDOMProps in dom.d.ts.\nconst $65484d02dcb7eb3e$var$linkPropNames = new Set([\n    \"href\",\n    \"target\",\n    \"rel\",\n    \"download\",\n    \"ping\",\n    \"referrerPolicy\"\n]);\nconst $65484d02dcb7eb3e$var$propRe = /^(data-.*)$/;\nfunction $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, opts = {}) {\n    let { labelable: labelable, isLink: isLink, propNames: propNames } = opts;\n    let filteredProps = {};\n    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($65484d02dcb7eb3e$var$DOMPropNames.has(prop) || labelable && $65484d02dcb7eb3e$var$labelablePropNames.has(prop) || isLink && $65484d02dcb7eb3e$var$linkPropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $65484d02dcb7eb3e$var$propRe.test(prop))) filteredProps[prop] = props[prop];\n    return filteredProps;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $7215afc6de606d6b$export$de79e2c695e052f3(element) {\n    if ($7215afc6de606d6b$var$supportsPreventScroll()) element.focus({\n        preventScroll: true\n    });\n    else {\n        let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element);\n        element.focus();\n        $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);\n    }\n}\nlet $7215afc6de606d6b$var$supportsPreventScrollCached = null;\nfunction $7215afc6de606d6b$var$supportsPreventScroll() {\n    if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {\n        $7215afc6de606d6b$var$supportsPreventScrollCached = false;\n        try {\n            let focusElem = document.createElement(\"div\");\n            focusElem.focus({\n                get preventScroll () {\n                    $7215afc6de606d6b$var$supportsPreventScrollCached = true;\n                    return true;\n                }\n            });\n        } catch (e) {\n        // Ignore\n        }\n    }\n    return $7215afc6de606d6b$var$supportsPreventScrollCached;\n}\nfunction $7215afc6de606d6b$var$getScrollableElements(element) {\n    let parent = element.parentNode;\n    let scrollableElements = [];\n    let rootScrollingElement = document.scrollingElement || document.documentElement;\n    while(parent instanceof HTMLElement && parent !== rootScrollingElement){\n        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({\n            element: parent,\n            scrollTop: parent.scrollTop,\n            scrollLeft: parent.scrollLeft\n        });\n        parent = parent.parentNode;\n    }\n    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({\n        element: rootScrollingElement,\n        scrollTop: rootScrollingElement.scrollTop,\n        scrollLeft: rootScrollingElement.scrollLeft\n    });\n    return scrollableElements;\n}\nfunction $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {\n    for (let { element: element, scrollTop: scrollTop, scrollLeft: scrollLeft } of scrollableElements){\n        element.scrollTop = scrollTop;\n        element.scrollLeft = scrollLeft;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $ab71dadb03a6fb2e$export$622cea445a1c5b7d(element, reverse, orientation = \"horizontal\") {\n    let rect = element.getBoundingClientRect();\n    if (reverse) return orientation === \"horizontal\" ? rect.right : rect.bottom;\n    return orientation === \"horizontal\" ? rect.left : rect.top;\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c87311424ea30a05$var$testUserAgent(re) {\n    var _window_navigator_userAgentData;\n    if (true) return false;\n    return ((_window_navigator_userAgentData = window.navigator[\"userAgentData\"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);\n}\nfunction $c87311424ea30a05$var$testPlatform(re) {\n    var _window_navigator_userAgentData;\n    return  false ? 0 : false;\n}\nfunction $c87311424ea30a05$export$9ac100e40613ea10() {\n    return $c87311424ea30a05$var$testPlatform(/^Mac/i);\n}\nfunction $c87311424ea30a05$export$186c6964ca17d99() {\n    return $c87311424ea30a05$var$testPlatform(/^iPhone/i);\n}\nfunction $c87311424ea30a05$export$7bef049ce92e4224() {\n    return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;\n}\nfunction $c87311424ea30a05$export$fedb369cb70207f1() {\n    return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();\n}\nfunction $c87311424ea30a05$export$e1865c3bedcd822b() {\n    return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();\n}\nfunction $c87311424ea30a05$export$78551043582a6a98() {\n    return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();\n}\nfunction $c87311424ea30a05$export$6446a186d09e379e() {\n    return $c87311424ea30a05$var$testUserAgent(/Chrome/i);\n}\nfunction $c87311424ea30a05$export$a11b0059900ceec8() {\n    return $c87311424ea30a05$var$testUserAgent(/Android/i);\n}\nfunction $c87311424ea30a05$export$b7d78993b74f766d() {\n    return $c87311424ea30a05$var$testUserAgent(/Firefox/i);\n}\nconst $ea8dcbcb9ea1b556$var$RouterContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    isNative: true,\n    open: $ea8dcbcb9ea1b556$var$openSyntheticLink\n});\nfunction $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb(props) {\n    let { children: children, navigate: navigate } = props;\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            isNative: false,\n            open: (target, modifiers)=>{\n                $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>{\n                    if ($ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers)) navigate(link.pathname + link.search + link.hash);\n                    else $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers);\n                });\n            }\n        }), [\n        navigate\n    ]);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($ea8dcbcb9ea1b556$var$RouterContext.Provider, {\n        value: ctx\n    }, children);\n}\nfunction $ea8dcbcb9ea1b556$export$9a302a45f65d0572() {\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($ea8dcbcb9ea1b556$var$RouterContext);\n}\nfunction $ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers) {\n    // Use getAttribute here instead of link.target. Firefox will default link.target to \"_parent\" when inside an iframe.\n    let target = link.getAttribute(\"target\");\n    return (!target || target === \"_self\") && link.origin === location.origin && !link.hasAttribute(\"download\") && !modifiers.metaKey && // open in new tab (mac)\n    !modifiers.ctrlKey && // open in new tab (windows)\n    !modifiers.altKey && // download\n    !modifiers.shiftKey;\n}\nfunction $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {\n    var _window_event_type, _window_event;\n    let { metaKey: metaKey, ctrlKey: ctrlKey, altKey: altKey, shiftKey: shiftKey } = modifiers;\n    // Firefox does not recognize keyboard events as a user action by default, and the popup blocker\n    // will prevent links with target=\"_blank\" from opening. However, it does allow the event if the\n    // Command/Control key is held, which opens the link in a background tab. This seems like the best we can do.\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=257870 and https://bugzilla.mozilla.org/show_bug.cgi?id=746640.\n    if ((0, $c87311424ea30a05$export$b7d78993b74f766d)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith(\"key\")) && target.target === \"_blank\") {\n        if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) metaKey = true;\n        else ctrlKey = true;\n    }\n    // WebKit does not support firing click events with modifier keys, but does support keyboard events.\n    // https://github.com/WebKit/WebKit/blob/c03d0ac6e6db178f90923a0a63080b5ca210d25f/Source/WebCore/html/HTMLAnchorElement.cpp#L184\n    let event = (0, $c87311424ea30a05$export$78551043582a6a98)() && (0, $c87311424ea30a05$export$9ac100e40613ea10)() && !(0, $c87311424ea30a05$export$7bef049ce92e4224)() && true ? new KeyboardEvent(\"keydown\", {\n        keyIdentifier: \"Enter\",\n        metaKey: metaKey,\n        ctrlKey: ctrlKey,\n        altKey: altKey,\n        shiftKey: shiftKey\n    }) : new MouseEvent(\"click\", {\n        metaKey: metaKey,\n        ctrlKey: ctrlKey,\n        altKey: altKey,\n        shiftKey: shiftKey,\n        bubbles: true,\n        cancelable: true\n    });\n    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;\n    (0, $7215afc6de606d6b$export$de79e2c695e052f3)(target);\n    target.dispatchEvent(event);\n    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;\n}\n// https://github.com/parcel-bundler/parcel/issues/8724\n$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;\nfunction $ea8dcbcb9ea1b556$var$getSyntheticLink(target, open) {\n    if (target instanceof HTMLAnchorElement) open(target);\n    else if (target.hasAttribute(\"data-href\")) {\n        let link = document.createElement(\"a\");\n        link.href = target.getAttribute(\"data-href\");\n        if (target.hasAttribute(\"data-target\")) link.target = target.getAttribute(\"data-target\");\n        if (target.hasAttribute(\"data-rel\")) link.rel = target.getAttribute(\"data-rel\");\n        if (target.hasAttribute(\"data-download\")) link.download = target.getAttribute(\"data-download\");\n        if (target.hasAttribute(\"data-ping\")) link.ping = target.getAttribute(\"data-ping\");\n        if (target.hasAttribute(\"data-referrer-policy\")) link.referrerPolicy = target.getAttribute(\"data-referrer-policy\");\n        target.appendChild(link);\n        open(link);\n        target.removeChild(link);\n    }\n}\nfunction $ea8dcbcb9ea1b556$var$openSyntheticLink(target, modifiers) {\n    $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>$ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers));\n}\nfunction $ea8dcbcb9ea1b556$export$51437d503373d223(props) {\n    return {\n        \"data-href\": props.href,\n        \"data-target\": props.target,\n        \"data-rel\": props.rel,\n        \"data-download\": props.download,\n        \"data-ping\": props.ping,\n        \"data-referrer-policy\": props.referrerPolicy\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet $bbed8b41f857bcc0$var$transitionsByElement = new Map();\n// A list of callbacks to call once there are no transitioning elements.\nlet $bbed8b41f857bcc0$var$transitionCallbacks = new Set();\nfunction $bbed8b41f857bcc0$var$setupGlobalEvents() {\n    if (true) return;\n    function isTransitionEvent(event) {\n        return \"propertyName\" in event;\n    }\n    let onTransitionStart = (e)=>{\n        if (!isTransitionEvent(e) || !e.target) return;\n        // Add the transitioning property to the list for this element.\n        let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!transitions) {\n            transitions = new Set();\n            $bbed8b41f857bcc0$var$transitionsByElement.set(e.target, transitions);\n            // The transitioncancel event must be registered on the element itself, rather than as a global\n            // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n            e.target.addEventListener(\"transitioncancel\", onTransitionEnd, {\n                once: true\n            });\n        }\n        transitions.add(e.propertyName);\n    };\n    let onTransitionEnd = (e)=>{\n        if (!isTransitionEvent(e) || !e.target) return;\n        // Remove property from list of transitioning properties.\n        let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!properties) return;\n        properties.delete(e.propertyName);\n        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n        if (properties.size === 0) {\n            e.target.removeEventListener(\"transitioncancel\", onTransitionEnd);\n            $bbed8b41f857bcc0$var$transitionsByElement.delete(e.target);\n        }\n        // If no transitioning elements, call all of the queued callbacks.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {\n            for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks)cb();\n            $bbed8b41f857bcc0$var$transitionCallbacks.clear();\n        }\n    };\n    document.body.addEventListener(\"transitionrun\", onTransitionStart);\n    document.body.addEventListener(\"transitionend\", onTransitionEnd);\n}\nif (typeof document !== \"undefined\") {\n    if (document.readyState !== \"loading\") $bbed8b41f857bcc0$var$setupGlobalEvents();\n    else document.addEventListener(\"DOMContentLoaded\", $bbed8b41f857bcc0$var$setupGlobalEvents);\n}\nfunction $bbed8b41f857bcc0$export$24490316f764c430(fn) {\n    // Wait one frame to see if an animation starts, e.g. a transition on mount.\n    requestAnimationFrame(()=>{\n        // If no transitions are running, call the function immediately.\n        // Otherwise, add it to a list of callbacks to run at the end of the animation.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();\n        else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);\n    });\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /* eslint-disable rulesdir/pure-render */ // Keep track of elements that we are currently handling dragging for via useDrag1D.\n// If there's an ancestor and a descendant both using useDrag1D(), and the user starts\n// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.\nconst $9cc09df9fd7676be$var$draggingElements = [];\nfunction $9cc09df9fd7676be$export$7bbed75feba39706(props) {\n    console.warn(\"useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html\");\n    let { containerRef: containerRef, reverse: reverse, orientation: orientation, onHover: onHover, onDrag: onDrag, onPositionChange: onPositionChange, onIncrement: onIncrement, onDecrement: onDecrement, onIncrementToMax: onIncrementToMax, onDecrementToMin: onDecrementToMin, onCollapseToggle: onCollapseToggle } = props;\n    let getPosition = (e)=>orientation === \"horizontal\" ? e.clientX : e.clientY;\n    let getNextOffset = (e)=>{\n        let containerOffset = (0, $ab71dadb03a6fb2e$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);\n        let mouseOffset = getPosition(e);\n        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;\n        return nextOffset;\n    };\n    let dragging = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let prevPosition = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Keep track of the current handlers in a ref so that the events can access them.\n    let handlers = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        onPositionChange: onPositionChange,\n        onDrag: onDrag\n    });\n    handlers.current.onDrag = onDrag;\n    handlers.current.onPositionChange = onPositionChange;\n    let onMouseDragged = (e)=>{\n        e.preventDefault();\n        let nextOffset = getNextOffset(e);\n        if (!dragging.current) {\n            dragging.current = true;\n            if (handlers.current.onDrag) handlers.current.onDrag(true);\n            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        }\n        if (prevPosition.current === nextOffset) return;\n        prevPosition.current = nextOffset;\n        if (onPositionChange) onPositionChange(nextOffset);\n    };\n    let onMouseUp = (e)=>{\n        const target = e.target;\n        dragging.current = false;\n        let nextOffset = getNextOffset(e);\n        if (handlers.current.onDrag) handlers.current.onDrag(false);\n        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        $9cc09df9fd7676be$var$draggingElements.splice($9cc09df9fd7676be$var$draggingElements.indexOf(target), 1);\n        window.removeEventListener(\"mouseup\", onMouseUp, false);\n        window.removeEventListener(\"mousemove\", onMouseDragged, false);\n    };\n    let onMouseDown = (e)=>{\n        const target = e.currentTarget;\n        // If we're already handling dragging on a descendant with useDrag1D, then\n        // we don't want to handle the drag motion on this target as well.\n        if ($9cc09df9fd7676be$var$draggingElements.some((elt)=>target.contains(elt))) return;\n        $9cc09df9fd7676be$var$draggingElements.push(target);\n        window.addEventListener(\"mousemove\", onMouseDragged, false);\n        window.addEventListener(\"mouseup\", onMouseUp, false);\n    };\n    let onMouseEnter = ()=>{\n        if (onHover) onHover(true);\n    };\n    let onMouseOut = ()=>{\n        if (onHover) onHover(false);\n    };\n    let onKeyDown = (e)=>{\n        switch(e.key){\n            case \"Left\":\n            case \"ArrowLeft\":\n                if (orientation === \"horizontal\") {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case \"Up\":\n            case \"ArrowUp\":\n                if (orientation === \"vertical\") {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case \"Right\":\n            case \"ArrowRight\":\n                if (orientation === \"horizontal\") {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case \"Down\":\n            case \"ArrowDown\":\n                if (orientation === \"vertical\") {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case \"Home\":\n                e.preventDefault();\n                if (onDecrementToMin) onDecrementToMin();\n                break;\n            case \"End\":\n                e.preventDefault();\n                if (onIncrementToMax) onIncrementToMax();\n                break;\n            case \"Enter\":\n                e.preventDefault();\n                if (onCollapseToggle) onCollapseToggle();\n                break;\n        }\n    };\n    return {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        onKeyDown: onKeyDown\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {\n    let globalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    let addGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        // Make sure we remove the listener after it is called with the `once` option.\n        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{\n            globalListeners.current.delete(listener);\n            listener(...args);\n        } : listener;\n        globalListeners.current.set(listener, {\n            type: type,\n            eventTarget: eventTarget,\n            fn: fn,\n            options: options\n        });\n        eventTarget.addEventListener(type, listener, options);\n    }, []);\n    let removeGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        var _globalListeners_current_get;\n        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;\n        eventTarget.removeEventListener(type, fn, options);\n        globalListeners.current.delete(listener);\n    }, []);\n    let removeAllGlobalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        globalListeners.current.forEach((value1, key)=>{\n            removeGlobalListener(value1.eventTarget, value1.type, key, value1.options);\n        });\n    }, [\n        removeGlobalListener\n    ]);\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return removeAllGlobalListeners;\n    }, [\n        removeAllGlobalListeners\n    ]);\n    return {\n        addGlobalListener: addGlobalListener,\n        removeGlobalListener: removeGlobalListener,\n        removeAllGlobalListeners: removeAllGlobalListeners\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $313b98861ee5dd6c$export$d6875122194c7b44(props, defaultLabel) {\n    let { id: id, \"aria-label\": label, \"aria-labelledby\": labelledBy } = props;\n    // If there is both an aria-label and aria-labelledby,\n    // combine them by pointing to the element itself.\n    id = (0, $bdb11010cef70236$export$f680877a34711e37)(id);\n    if (labelledBy && label) {\n        let ids = new Set([\n            id,\n            ...labelledBy.trim().split(/\\s+/)\n        ]);\n        labelledBy = [\n            ...ids\n        ].join(\" \");\n    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\\s+/).join(\" \");\n    // If no labels are provided, use the default\n    if (!label && !labelledBy && defaultLabel) label = defaultLabel;\n    return {\n        id: id,\n        \"aria-label\": label,\n        \"aria-labelledby\": labelledBy\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $df56164dff5785e2$export$4338b53315abf666(forwardedRef) {\n    const objRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            get current () {\n                return objRef.current;\n            },\n            set current (value){\n                objRef.current = value;\n                if (typeof forwardedRef === \"function\") forwardedRef(value);\n                else if (forwardedRef) forwardedRef.current = value;\n            }\n        }), [\n        forwardedRef\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $4f58c5f72bcf79f7$export$496315a1608d9602(effect, dependencies) {\n    const isInitialMount = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const lastDeps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        isInitialMount.current = true;\n        return ()=>{\n            isInitialMount.current = false;\n        };\n    }, []);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isInitialMount.current) isInitialMount.current = false;\n        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();\n        lastDeps.current = dependencies;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, dependencies);\n}\nfunction $9daab02d461809db$var$hasResizeObserver() {\n    return typeof window.ResizeObserver !== \"undefined\";\n}\nfunction $9daab02d461809db$export$683480f191c0e3ea(options) {\n    const { ref: ref, onResize: onResize } = options;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let element = ref === null || ref === void 0 ? void 0 : ref.current;\n        if (!element) return;\n        if (!$9daab02d461809db$var$hasResizeObserver()) {\n            window.addEventListener(\"resize\", onResize, false);\n            return ()=>{\n                window.removeEventListener(\"resize\", onResize, false);\n            };\n        } else {\n            const resizeObserverInstance = new window.ResizeObserver((entries)=>{\n                if (!entries.length) return;\n                onResize();\n            });\n            resizeObserverInstance.observe(element);\n            return ()=>{\n                if (element) resizeObserverInstance.unobserve(element);\n            };\n        }\n    }, [\n        onResize,\n        ref\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (context && context.ref && ref) {\n            context.ref.current = ref.current;\n            return ()=>{\n                if (context.ref) context.ref.current = null;\n            };\n        }\n    });\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $62d8ded9296f3872$export$cfa2225e87938781(node, checkForOverflow) {\n    let scrollableNode = node;\n    if ($62d8ded9296f3872$export$2bb74740c4e19def(scrollableNode, checkForOverflow)) scrollableNode = scrollableNode.parentElement;\n    while(scrollableNode && !$62d8ded9296f3872$export$2bb74740c4e19def(scrollableNode, checkForOverflow))scrollableNode = scrollableNode.parentElement;\n    return scrollableNode || document.scrollingElement || document.documentElement;\n}\nfunction $62d8ded9296f3872$export$2bb74740c4e19def(node, checkForOverflow) {\n    let style = window.getComputedStyle(node);\n    let isScrollable = /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n    if (isScrollable && checkForOverflow) isScrollable = node.scrollHeight !== node.clientHeight || node.scrollWidth !== node.clientWidth;\n    return isScrollable;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // @ts-ignore\nlet $5df64b3807dc15ee$var$visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction $5df64b3807dc15ee$export$d699905dd57c73ca() {\n    let isSSR = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__.useIsSSR)();\n    let [size, setSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>isSSR ? {\n            width: 0,\n            height: 0\n        } : $5df64b3807dc15ee$var$getViewportSize());\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Use visualViewport api to track available height even on iOS virtual keyboard opening\n        let onResize = ()=>{\n            setSize((size)=>{\n                let newSize = $5df64b3807dc15ee$var$getViewportSize();\n                if (newSize.width === size.width && newSize.height === size.height) return size;\n                return newSize;\n            });\n        };\n        if (!$5df64b3807dc15ee$var$visualViewport) window.addEventListener(\"resize\", onResize);\n        else $5df64b3807dc15ee$var$visualViewport.addEventListener(\"resize\", onResize);\n        return ()=>{\n            if (!$5df64b3807dc15ee$var$visualViewport) window.removeEventListener(\"resize\", onResize);\n            else $5df64b3807dc15ee$var$visualViewport.removeEventListener(\"resize\", onResize);\n        };\n    }, []);\n    return size;\n}\nfunction $5df64b3807dc15ee$var$getViewportSize() {\n    return {\n        width: $5df64b3807dc15ee$var$visualViewport && ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.width) || window.innerWidth,\n        height: $5df64b3807dc15ee$var$visualViewport && ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.height) || window.innerHeight\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $ef06256079686ba0$var$descriptionId = 0;\nconst $ef06256079686ba0$var$descriptionNodes = new Map();\nfunction $ef06256079686ba0$export$f8aeda7b10753fa1(description) {\n    let [id, setId] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (!description) return;\n        let desc = $ef06256079686ba0$var$descriptionNodes.get(description);\n        if (!desc) {\n            let id = `react-aria-description-${$ef06256079686ba0$var$descriptionId++}`;\n            setId(id);\n            let node = document.createElement(\"div\");\n            node.id = id;\n            node.style.display = \"none\";\n            node.textContent = description;\n            document.body.appendChild(node);\n            desc = {\n                refCount: 0,\n                element: node\n            };\n            $ef06256079686ba0$var$descriptionNodes.set(description, desc);\n        } else setId(desc.element.id);\n        desc.refCount++;\n        return ()=>{\n            if (desc && --desc.refCount === 0) {\n                desc.element.remove();\n                $ef06256079686ba0$var$descriptionNodes.delete(description);\n            }\n        };\n    }, [\n        description\n    ]);\n    return {\n        \"aria-describedby\": description ? id : undefined\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e9faafb641e167db$export$90fc3a17d93f704c(ref, event, handler, options) {\n    let handleEvent = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(handler);\n    let isDisabled = handler == null;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isDisabled || !ref.current) return;\n        let element = ref.current;\n        element.addEventListener(event, handleEvent, options);\n        return ()=>{\n            element.removeEventListener(event, handleEvent, options);\n        };\n    }, [\n        ref,\n        event,\n        options,\n        isDisabled,\n        handleEvent\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollView, element) {\n    let offsetX = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, \"left\");\n    let offsetY = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, \"top\");\n    let width = element.offsetWidth;\n    let height = element.offsetHeight;\n    let x = scrollView.scrollLeft;\n    let y = scrollView.scrollTop;\n    // Account for top/left border offsetting the scroll top/Left\n    let { borderTopWidth: borderTopWidth, borderLeftWidth: borderLeftWidth } = getComputedStyle(scrollView);\n    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);\n    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);\n    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width\n    let maxX = borderAdjustedX + scrollView.clientWidth;\n    let maxY = borderAdjustedY + scrollView.clientHeight;\n    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);\n    else if (offsetX + width > maxX) x += offsetX + width - maxX;\n    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);\n    else if (offsetY + height > maxY) y += offsetY + height - maxY;\n    scrollView.scrollLeft = x;\n    scrollView.scrollTop = y;\n}\n/**\n * Computes the offset left or top from child to ancestor by accumulating\n * offsetLeft or offsetTop through intervening offsetParents.\n */ function $2f04cbc44ee30ce0$var$relativeOffset(ancestor, child, axis) {\n    const prop = axis === \"left\" ? \"offsetLeft\" : \"offsetTop\";\n    let sum = 0;\n    while(child.offsetParent){\n        sum += child[prop];\n        if (child.offsetParent === ancestor) break;\n        else if (child.offsetParent.contains(ancestor)) {\n            // If the ancestor is not `position:relative`, then we stop at\n            // _its_ offset parent, and we subtract off _its_ offset, so that\n            // we end up with the proper offset from child to ancestor.\n            sum -= ancestor[prop];\n            break;\n        }\n        child = child.offsetParent;\n    }\n    return sum;\n}\nfunction $2f04cbc44ee30ce0$export$c826860796309d1b(targetElement, opts) {\n    if (document.contains(targetElement)) {\n        let root = document.scrollingElement || document.documentElement;\n        let isScrollPrevented = window.getComputedStyle(root).overflow === \"hidden\";\n        // If scrolling is not currently prevented then we arenâ€™t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view\n        if (!isScrollPrevented) {\n            var // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically\n            _targetElement_scrollIntoView;\n            let { left: originalLeft, top: originalTop } = targetElement.getBoundingClientRect();\n            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {\n                block: \"nearest\"\n            });\n            let { left: newLeft, top: newTop } = targetElement.getBoundingClientRect();\n            // Account for sub pixel differences from rounding\n            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {\n                var _opts_containingElement_scrollIntoView, _opts_containingElement, _targetElement_scrollIntoView1;\n                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {\n                    block: \"center\",\n                    inline: \"center\"\n                });\n                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {\n                    block: \"nearest\"\n                });\n            }\n        } else {\n            let scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);\n            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.\n            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){\n                $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollParent, targetElement);\n                targetElement = scrollParent;\n                scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);\n            }\n        }\n    }\n}\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6a7db85432448f7f$export$60278871457622de(event) {\n    // JAWS/NVDA with Firefox.\n    if (event.mozInputSource === 0 && event.isTrusted) return true;\n    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead\n    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check\n    // to detect TalkBack virtual clicks.\n    if ((0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType) return event.type === \"click\" && event.buttons === 1;\n    return event.detail === 0 && !event.pointerType;\n}\nfunction $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {\n    // If the pointer size is zero, then we assume it's from a screen reader.\n    // Android TalkBack double tap will sometimes return a event with width and height of 1\n    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.\n    // Cannot use \"event.pressure === 0\" as the sole check due to Safari pointer events always returning pressure === 0\n    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush\n    // Talkback double tap from Windows Firefox touch screen press\n    return !(0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"mouse\";\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /* eslint-disable rulesdir/pure-render */ function $5a387cc49350e6db$export$722debc0e56fea39(value1, isEqual) {\n    // Using a ref during render is ok here because it's only an optimization â€“ both values are equivalent.\n    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.\n    let lastValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (value1 && lastValue.current && isEqual(value1, lastValue.current)) value1 = lastValue.current;\n    lastValue.current = value1;\n    return value1;\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $99facab73266f662$export$5add1d006293d136(ref, initialValue, onReset) {\n    let resetValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialValue);\n    let handleReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{\n        if (onReset) onReset(resetValue.current);\n    });\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _ref_current;\n        let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;\n        form === null || form === void 0 ? void 0 : form.addEventListener(\"reset\", handleReset);\n        return ()=>{\n            form === null || form === void 0 ? void 0 : form.removeEventListener(\"reset\", handleReset);\n        };\n    }, [\n        ref,\n        handleReset\n    ]);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3V0aWxzL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnSjtBQUM4RztBQUM3SjtBQUNsRTtBQUUvQjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNEOzs7Ozs7Ozs7O0NBVUMsR0FDRCxNQUFNd0IsNENBQTRDLE9BQU9DLGFBQWEsY0FBYyxDQUFDLEdBQUdyQixrQ0FBVyxFQUFHc0IsZUFBZSxHQUFHLEtBQUs7QUFJN0g7Ozs7Ozs7Ozs7Q0FVQyxHQUNEOzs7Ozs7Ozs7O0NBVUMsR0FFRCxTQUFTQywwQ0FBMENDLEVBQUU7SUFDakQsTUFBTUMsTUFBTSxDQUFDLEdBQUdyQix5Q0FBWSxFQUFHO0lBQzlCLElBQUdnQix5Q0FBd0MsRUFBRztRQUMzQ0ssSUFBSUMsT0FBTyxHQUFHRjtJQUNsQixHQUFHO1FBQ0NBO0tBQ0g7SUFDRCxhQUFhO0lBQ2IsT0FBTyxDQUFDLEdBQUdsQiw4Q0FBaUIsRUFBRyxDQUFDLEdBQUdxQjtRQUMvQixNQUFNQyxJQUFJSCxJQUFJQyxPQUFPO1FBQ3JCLE9BQU9FLE1BQU0sUUFBUUEsTUFBTSxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLRDtJQUN0RCxHQUFHLEVBQUU7QUFDVDtBQUdBLFNBQVNFLDBDQUEwQ0MsWUFBWTtJQUMzRCxJQUFJLENBQUNDLFFBQU9DLFNBQVMsR0FBRyxDQUFDLEdBQUc5QiwyQ0FBYyxFQUFHNEI7SUFDN0MsSUFBSUcsU0FBUyxDQUFDLEdBQUc3Qix5Q0FBWSxFQUFHO0lBQ2hDLDBFQUEwRTtJQUMxRSx5Q0FBeUM7SUFDekMsSUFBSThCLFVBQVUsQ0FBQyxHQUFHWCx5Q0FBd0MsRUFBRztRQUN6RCxJQUFJLENBQUNVLE9BQU9QLE9BQU8sRUFBRTtR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O0lBQ0MsSUFBR2xCLDRDQUFlLEVBQUc7UUFDbEIsSUFBSW1ZO1FBQ0osSUFBSUMsT0FBT25YLFFBQVEsUUFBUUEsUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJLENBQUNrWCxlQUFlbFgsSUFBSUMsT0FBTyxNQUFNLFFBQVFpWCxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsYUFBYUMsSUFBSTtRQUNsSkEsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtwTCxnQkFBZ0IsQ0FBQyxTQUFTa0w7UUFDM0UsT0FBTztZQUNIRSxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBSzdLLG1CQUFtQixDQUFDLFNBQVMySztRQUNsRjtJQUNKLEdBQUc7UUFDQ2pYO1FBQ0FpWDtLQUNIO0FBQ0w7QUFLNDBGLENBQzUwRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWR1c2EtbmV4dC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS92aXJ0dWFsaXplci9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9pbXBvcnQubWpzP2JiMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjbGFtcCBhcyAkNDUwNzQ2MWExYjg3MDEyMyRyZV9leHBvcnQkY2xhbXAsIHNuYXBWYWx1ZVRvU3RlcCBhcyAkNDUwNzQ2MWExYjg3MDEyMyRyZV9leHBvcnQkc25hcFZhbHVlVG9TdGVwfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcbmltcG9ydCAkMTJ1R3AkcmVhY3QsIHt1c2VTdGF0ZSBhcyAkMTJ1R3AkdXNlU3RhdGUsIHVzZVJlZiBhcyAkMTJ1R3AkdXNlUmVmLCB1c2VDYWxsYmFjayBhcyAkMTJ1R3AkdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCBhcyAkMTJ1R3AkdXNlRWZmZWN0LCBjcmVhdGVDb250ZXh0IGFzICQxMnVHcCRjcmVhdGVDb250ZXh0LCB1c2VNZW1vIGFzICQxMnVHcCR1c2VNZW1vLCB1c2VDb250ZXh0IGFzICQxMnVHcCR1c2VDb250ZXh0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlU1NSU2FmZUlkIGFzICQxMnVHcCR1c2VTU1JTYWZlSWQsIHVzZUlzU1NSIGFzICQxMnVHcCR1c2VJc1NTUn0gZnJvbSBcIkByZWFjdC1hcmlhL3NzclwiO1xuaW1wb3J0ICQxMnVHcCRjbHN4IGZyb20gXCJjbHN4XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jb25zdCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/ICgwLCAkMTJ1R3AkcmVhY3QpLnVzZUxheW91dEVmZmVjdCA6ICgpPT57fTtcblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIoZm4pIHtcbiAgICBjb25zdCByZWYgPSAoMCwgJDEydUdwJHVzZVJlZikobnVsbCk7XG4gICAgKDAsICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjKSgoKT0+e1xuICAgICAgICByZWYuY3VycmVudCA9IGZuO1xuICAgIH0sIFtcbiAgICAgICAgZm5cbiAgICBdKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICgwLCAkMTJ1R3AkdXNlQ2FsbGJhY2spKCguLi5hcmdzKT0+e1xuICAgICAgICBjb25zdCBmID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIHJldHVybiBmID09PSBudWxsIHx8IGYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGYoLi4uYXJncyk7XG4gICAgfSwgW10pO1xufVxuXG5cbmZ1bmN0aW9uICQxZGJlY2JlMjdhMDRmOWFmJGV4cG9ydCQxNGQyMzhmMzQyNzIzZjI1KGRlZmF1bHRWYWx1ZSkge1xuICAgIGxldCBbdmFsdWUsIHNldFZhbHVlXSA9ICgwLCAkMTJ1R3AkdXNlU3RhdGUpKGRlZmF1bHRWYWx1ZSk7XG4gICAgbGV0IGVmZmVjdCA9ICgwLCAkMTJ1R3AkdXNlUmVmKShudWxsKTtcbiAgICAvLyBTdG9yZSB0aGUgZnVuY3Rpb24gaW4gYSByZWYgc28gd2UgY2FuIGFsd2F5cyBhY2Nlc3MgdGhlIGN1cnJlbnQgdmVyc2lvblxuICAgIC8vIHdoaWNoIGhhcyB0aGUgcHJvcGVyIGB2YWx1ZWAgaW4gc2NvcGUuXG4gICAgbGV0IG5leHRSZWYgPSAoMCwgJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIpKCgpPT57XG4gICAgICAgIGlmICghZWZmZWN0LmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgLy8gUnVuIHRoZSBnZW5lcmF0b3IgdG8gdGhlIG5leHQgeWllbGQuXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IGVmZmVjdC5jdXJyZW50Lm5leHQoKTtcbiAgICAgICAgLy8gSWYgdGhlIGdlbmVyYXRvciBpcyBkb25lLCByZXNldCB0aGUgZWZmZWN0LlxuICAgICAgICBpZiAobmV3VmFsdWUuZG9uZSkge1xuICAgICAgICAgICAgZWZmZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB2YWx1ZSxcbiAgICAgICAgLy8gdGhlbiBjb250aW51ZSB0byB0aGUgbmV4dCB5aWVsZC4gT3RoZXJ3aXNlLFxuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlIGluIHN0YXRlIGFuZCB3YWl0IGZvciB0aGUgbmV4dCBsYXlvdXQgZWZmZWN0LlxuICAgICAgICBpZiAodmFsdWUgPT09IG5ld1ZhbHVlLnZhbHVlKSBuZXh0UmVmKCk7XG4gICAgICAgIGVsc2Ugc2V0VmFsdWUobmV3VmFsdWUudmFsdWUpO1xuICAgIH0pO1xuICAgICgwLCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYykoKCk9PntcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZWZmZWN0IGN1cnJlbnRseSBydW5uaW5nLCBjb250aW51ZSB0byB0aGUgbmV4dCB5aWVsZC5cbiAgICAgICAgaWYgKGVmZmVjdC5jdXJyZW50KSBuZXh0UmVmKCk7XG4gICAgfSk7XG4gICAgbGV0IHF1ZXVlID0gKDAsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKSgoZm4pPT57XG4gICAgICAgIGVmZmVjdC5jdXJyZW50ID0gZm4odmFsdWUpO1xuICAgICAgICBuZXh0UmVmKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHF1ZXVlXG4gICAgXTtcbn1cblxuXG4vLyBjb3BpZWQgZnJvbSBTU1JQcm92aWRlci50c3ggdG8gcmVkdWNlIGV4cG9ydHMsIGlmIG5lZWRlZCBhZ2FpbiwgY29uc2lkZXIgc2hhcmluZ1xubGV0ICRiZGIxMTAxMGNlZjcwMjM2JHZhciRjYW5Vc2VET00gPSBCb29sZWFuKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmxldCAkYmRiMTEwMTBjZWY3MDIzNiR2YXIkaWRzVXBkYXRlck1hcCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRmNjgwODc3YTM0NzExZTM3KGRlZmF1bHRJZCkge1xuICAgIGxldCBbdmFsdWUsIHNldFZhbHVlXSA9ICgwLCAkMTJ1R3AkdXNlU3RhdGUpKGRlZmF1bHRJZCk7XG4gICAgbGV0IG5leHRJZCA9ICgwLCAkMTJ1R3AkdXNlUmVmKShudWxsKTtcbiAgICBsZXQgcmVzID0gKDAsICQxMnVHcCR1c2VTU1JTYWZlSWQpKHZhbHVlKTtcbiAgICBsZXQgdXBkYXRlVmFsdWUgPSAoMCwgJDEydUdwJHVzZUNhbGxiYWNrKSgodmFsKT0+e1xuICAgICAgICBuZXh0SWQuY3VycmVudCA9IHZhbDtcbiAgICB9LCBbXSk7XG4gICAgaWYgKCRiZGIxMTAxMGNlZjcwMjM2JHZhciRjYW5Vc2VET00pICRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwLnNldChyZXMsIHVwZGF0ZVZhbHVlKTtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKCgpPT57XG4gICAgICAgIGxldCByID0gcmVzO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwLmRlbGV0ZShyKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHJlc1xuICAgIF0pO1xuICAgIC8vIFRoaXMgY2Fubm90IGNhdXNlIGFuIGluZmluaXRlIGxvb3AgYmVjYXVzZSB0aGUgcmVmIGlzIHVwZGF0ZWQgZmlyc3QuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBuZXdJZCA9IG5leHRJZC5jdXJyZW50O1xuICAgICAgICBpZiAobmV3SWQpIHtcbiAgICAgICAgICAgIG5leHRJZC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHNldFZhbHVlKG5ld0lkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkY2Q4YzljYjY4Zjg0MjYyOShpZEEsIGlkQikge1xuICAgIGlmIChpZEEgPT09IGlkQikgcmV0dXJuIGlkQTtcbiAgICBsZXQgc2V0SWRBID0gJGJkYjExMDEwY2VmNzAyMzYkdmFyJGlkc1VwZGF0ZXJNYXAuZ2V0KGlkQSk7XG4gICAgaWYgKHNldElkQSkge1xuICAgICAgICBzZXRJZEEoaWRCKTtcbiAgICAgICAgcmV0dXJuIGlkQjtcbiAgICB9XG4gICAgbGV0IHNldElkQiA9ICRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwLmdldChpZEIpO1xuICAgIGlmIChzZXRJZEIpIHtcbiAgICAgICAgc2V0SWRCKGlkQSk7XG4gICAgICAgIHJldHVybiBpZEE7XG4gICAgfVxuICAgIHJldHVybiBpZEI7XG59XG5mdW5jdGlvbiAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkYjRjYzA5YzU5MmU4ZmRiOChkZXBBcnJheSA9IFtdKSB7XG4gICAgbGV0IGlkID0gJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGY2ODA4NzdhMzQ3MTFlMzcoKTtcbiAgICBsZXQgW3Jlc29sdmVkSWQsIHNldFJlc29sdmVkSWRdID0gKDAsICQxZGJlY2JlMjdhMDRmOWFmJGV4cG9ydCQxNGQyMzhmMzQyNzIzZjI1KShpZCk7XG4gICAgbGV0IHVwZGF0ZUlkID0gKDAsICQxMnVHcCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0UmVzb2x2ZWRJZChmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICB5aWVsZCBpZDtcbiAgICAgICAgICAgIHlpZWxkIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA/IGlkIDogdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGlkLFxuICAgICAgICBzZXRSZXNvbHZlZElkXG4gICAgXSk7XG4gICAgKDAsICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjKSh1cGRhdGVJZCwgW1xuICAgICAgICBpZCxcbiAgICAgICAgdXBkYXRlSWQsXG4gICAgICAgIC4uLmRlcEFycmF5XG4gICAgXSk7XG4gICAgcmV0dXJuIHJlc29sdmVkSWQ7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qKlxuICogQ2FsbHMgYWxsIGZ1bmN0aW9ucyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIGNoYWluZWQgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMuXG4gKi8gZnVuY3Rpb24gJGZmNTk2M2ViMWZjY2Y1NTIkZXhwb3J0JGUwOGUzYjY3ZTM5MjEwMWUoLi4uY2FsbGJhY2tzKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKT0+e1xuICAgICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiBjYWxsYmFja3MpaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSBjYWxsYmFjayguLi5hcmdzKTtcbiAgICB9O1xufVxuXG5cbmNvbnN0ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjID0gKGVsKT0+e1xuICAgIHZhciBfZWxfb3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gKF9lbF9vd25lckRvY3VtZW50ID0gZWwgPT09IG51bGwgfHwgZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9lbF9vd25lckRvY3VtZW50ICE9PSB2b2lkIDAgPyBfZWxfb3duZXJEb2N1bWVudCA6IGRvY3VtZW50O1xufTtcbmNvbnN0ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhID0gKGVsKT0+e1xuICAgIGlmIChlbCAmJiBcIndpbmRvd1wiIGluIGVsICYmIGVsLndpbmRvdyA9PT0gZWwpIHJldHVybiBlbDtcbiAgICBjb25zdCBkb2MgPSAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyhlbCk7XG4gICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG59O1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkM2VmNDI1NzVkZjg0YjMwYiRleHBvcnQkOWQxNjExYzc3YzJmZTkyOCguLi5hcmdzKSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIGJhc2UgY2xvbmUgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LiBUaGlzIGlzIGEgbG90IGZhc3RlciB0aGFuIHN0YXJ0aW5nXG4gICAgLy8gd2l0aCBhbiBlbXB0eSBvYmplY3QgYW5kIGFkZGluZyBwcm9wZXJ0aWVzIGFzIHdlIGdvLlxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIC4uLmFyZ3NbMF1cbiAgICB9O1xuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IHByb3BzID0gYXJnc1tpXTtcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gcHJvcHMpe1xuICAgICAgICAgICAgbGV0IGEgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgIGxldCBiID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgIC8vIENoYWluIGV2ZW50c1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGIgPT09IFwiZnVuY3Rpb25cIiAmJiAvLyBUaGlzIGlzIGEgbG90IGZhc3RlciB0aGFuIGEgcmVnZXguXG4gICAgICAgICAgICBrZXlbMF0gPT09IFwib1wiICYmIGtleVsxXSA9PT0gXCJuXCIgJiYga2V5LmNoYXJDb2RlQXQoMikgPj0gLyogJ0EnICovIDY1ICYmIGtleS5jaGFyQ29kZUF0KDIpIDw9IC8qICdaJyAqLyA5MCkgcmVzdWx0W2tleV0gPSAoMCwgJGZmNTk2M2ViMWZjY2Y1NTIkZXhwb3J0JGUwOGUzYjY3ZTM5MjEwMWUpKGEsIGIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoKGtleSA9PT0gXCJjbGFzc05hbWVcIiB8fCBrZXkgPT09IFwiVU5TQUZFX2NsYXNzTmFtZVwiKSAmJiB0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIikgcmVzdWx0W2tleV0gPSAoMCwgJDEydUdwJGNsc3gpKGEsIGIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImlkXCIgJiYgYSAmJiBiKSByZXN1bHQuaWQgPSAoMCwgJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGNkOGM5Y2I2OGY4NDI2MjkpKGEsIGIpO1xuICAgICAgICAgICAgZWxzZSByZXN1bHRba2V5XSA9IGIgIT09IHVuZGVmaW5lZCA/IGIgOiBhO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ1ZGM5NTg5OWIzMDZmNjMwJGV4cG9ydCRjOTA1ODMxNjc2NGMxNDBlKC4uLnJlZnMpIHtcbiAgICBpZiAocmVmcy5sZW5ndGggPT09IDEpIHJldHVybiByZWZzWzBdO1xuICAgIHJldHVybiAodmFsdWUpPT57XG4gICAgICAgIGZvciAobGV0IHJlZiBvZiByZWZzKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHJlZih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNvbnN0ICQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRET01Qcm9wTmFtZXMgPSBuZXcgU2V0KFtcbiAgICBcImlkXCJcbl0pO1xuY29uc3QgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxhYmVsYWJsZVByb3BOYW1lcyA9IG5ldyBTZXQoW1xuICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCIsXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCIsXG4gICAgXCJhcmlhLWRldGFpbHNcIlxuXSk7XG4vLyBTZWUgTGlua0RPTVByb3BzIGluIGRvbS5kLnRzLlxuY29uc3QgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxpbmtQcm9wTmFtZXMgPSBuZXcgU2V0KFtcbiAgICBcImhyZWZcIixcbiAgICBcInRhcmdldFwiLFxuICAgIFwicmVsXCIsXG4gICAgXCJkb3dubG9hZFwiLFxuICAgIFwicGluZ1wiLFxuICAgIFwicmVmZXJyZXJQb2xpY3lcIlxuXSk7XG5jb25zdCAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkcHJvcFJlID0gL14oZGF0YS0uKikkLztcbmZ1bmN0aW9uICQ2NTQ4NGQwMmRjYjdlYjNlJGV4cG9ydCQ0NTdjM2Q2NTE4ZGQ0YzZmKHByb3BzLCBvcHRzID0ge30pIHtcbiAgICBsZXQgeyBsYWJlbGFibGU6IGxhYmVsYWJsZSwgaXNMaW5rOiBpc0xpbmssIHByb3BOYW1lczogcHJvcE5hbWVzIH0gPSBvcHRzO1xuICAgIGxldCBmaWx0ZXJlZFByb3BzID0ge307XG4gICAgZm9yKGNvbnN0IHByb3AgaW4gcHJvcHMpaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcCkgJiYgKCQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRET01Qcm9wTmFtZXMuaGFzKHByb3ApIHx8IGxhYmVsYWJsZSAmJiAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkbGFiZWxhYmxlUHJvcE5hbWVzLmhhcyhwcm9wKSB8fCBpc0xpbmsgJiYgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxpbmtQcm9wTmFtZXMuaGFzKHByb3ApIHx8IChwcm9wTmFtZXMgPT09IG51bGwgfHwgcHJvcE5hbWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wTmFtZXMuaGFzKHByb3ApKSB8fCAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkcHJvcFJlLnRlc3QocHJvcCkpKSBmaWx0ZXJlZFByb3BzW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgcmV0dXJuIGZpbHRlcmVkUHJvcHM7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ3MjE1YWZjNmRlNjA2ZDZiJGV4cG9ydCRkZTc5ZTJjNjk1ZTA1MmYzKGVsZW1lbnQpIHtcbiAgICBpZiAoJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbCgpKSBlbGVtZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIGVsc2Uge1xuICAgICAgICBsZXQgc2Nyb2xsYWJsZUVsZW1lbnRzID0gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJGdldFNjcm9sbGFibGVFbGVtZW50cyhlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkcmVzdG9yZVNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGVFbGVtZW50cyk7XG4gICAgfVxufVxubGV0ICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPSBudWxsO1xuZnVuY3Rpb24gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbCgpIHtcbiAgICBpZiAoJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZCA9PSBudWxsKSB7XG4gICAgICAgICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBmb2N1c0VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZm9jdXNFbGVtLmZvY3VzKHtcbiAgICAgICAgICAgICAgICBnZXQgcHJldmVudFNjcm9sbCAoKSB7XG4gICAgICAgICAgICAgICAgICAgICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZDtcbn1cbmZ1bmN0aW9uICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRnZXRTY3JvbGxhYmxlRWxlbWVudHMoZWxlbWVudCkge1xuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgbGV0IHNjcm9sbGFibGVFbGVtZW50cyA9IFtdO1xuICAgIGxldCByb290U2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHdoaWxlKHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHBhcmVudCAhPT0gcm9vdFNjcm9sbGluZ0VsZW1lbnQpe1xuICAgICAgICBpZiAocGFyZW50Lm9mZnNldEhlaWdodCA8IHBhcmVudC5zY3JvbGxIZWlnaHQgfHwgcGFyZW50Lm9mZnNldFdpZHRoIDwgcGFyZW50LnNjcm9sbFdpZHRoKSBzY3JvbGxhYmxlRWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBlbGVtZW50OiBwYXJlbnQsXG4gICAgICAgICAgICBzY3JvbGxUb3A6IHBhcmVudC5zY3JvbGxUb3AsXG4gICAgICAgICAgICBzY3JvbGxMZWZ0OiBwYXJlbnQuc2Nyb2xsTGVmdFxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChyb290U2Nyb2xsaW5nRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSBzY3JvbGxhYmxlRWxlbWVudHMucHVzaCh7XG4gICAgICAgIGVsZW1lbnQ6IHJvb3RTY3JvbGxpbmdFbGVtZW50LFxuICAgICAgICBzY3JvbGxUb3A6IHJvb3RTY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgICAgc2Nyb2xsTGVmdDogcm9vdFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdFxuICAgIH0pO1xuICAgIHJldHVybiBzY3JvbGxhYmxlRWxlbWVudHM7XG59XG5mdW5jdGlvbiAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkcmVzdG9yZVNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGVFbGVtZW50cykge1xuICAgIGZvciAobGV0IHsgZWxlbWVudDogZWxlbWVudCwgc2Nyb2xsVG9wOiBzY3JvbGxUb3AsIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQgfSBvZiBzY3JvbGxhYmxlRWxlbWVudHMpe1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICRhYjcxZGFkYjAzYTZmYjJlJGV4cG9ydCQ2MjJjZWE0NDVhMWM1YjdkKGVsZW1lbnQsIHJldmVyc2UsIG9yaWVudGF0aW9uID0gXCJob3Jpem9udGFsXCIpIHtcbiAgICBsZXQgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKHJldmVyc2UpIHJldHVybiBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyByZWN0LnJpZ2h0IDogcmVjdC5ib3R0b207XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IHJlY3QubGVmdCA6IHJlY3QudG9wO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQocmUpIHtcbiAgICB2YXIgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB3aW5kb3cubmF2aWdhdG9yID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKChfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhID0gd2luZG93Lm5hdmlnYXRvcltcInVzZXJBZ2VudERhdGFcIl0pID09PSBudWxsIHx8IF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEuYnJhbmRzLnNvbWUoKGJyYW5kKT0+cmUudGVzdChicmFuZC5icmFuZCkpKSB8fCByZS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0ocmUpIHtcbiAgICB2YXIgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YTtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmF2aWdhdG9yICE9IG51bGwgPyByZS50ZXN0KCgoX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9IHdpbmRvdy5uYXZpZ2F0b3JbXCJ1c2VyQWdlbnREYXRhXCJdKSA9PT0gbnVsbCB8fCBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhLnBsYXRmb3JtKSB8fCB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0oL15NYWMvaSk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkMTg2YzY5NjRjYTE3ZDk5KCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFBsYXRmb3JtKC9eaVBob25lL2kpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDdiZWYwNDljZTkyZTQyMjQoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0oL15pUGFkL2kpIHx8IC8vIGlQYWRPUyAxMyBsaWVzIGFuZCBzYXlzIGl0J3MgYSBNYWMsIGJ1dCB3ZSBjYW4gZGlzdGluZ3Vpc2ggYnkgZGV0ZWN0aW5nIHRvdWNoIHN1cHBvcnQuXG4gICAgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAoKSAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGZlZGIzNjljYjcwMjA3ZjEoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQxODZjNjk2NGNhMTdkOTkoKSB8fCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkN2JlZjA0OWNlOTJlNDIyNCgpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGUxODY1YzNiZWRjZDgyMmIoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ5YWMxMDBlNDA2MTNlYTEwKCkgfHwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGZlZGIzNjljYjcwMjA3ZjEoKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3ODU1MTA0MzU4MmE2YTk4KCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvQXBwbGVXZWJLaXQvaSkgJiYgISRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ2NDQ2YTE4NmQwOWUzNzllKCk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNjQ0NmExODZkMDllMzc5ZSgpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQoL0Nocm9tZS9pKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4KCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvQW5kcm9pZC9pKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRiN2Q3ODk5M2I3NGY3NjZkKCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvRmlyZWZveC9pKTtcbn1cblxuXG5cblxuY29uc3QgJGVhOGRjYmNiOWVhMWI1NTYkdmFyJFJvdXRlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovICgwLCAkMTJ1R3AkY3JlYXRlQ29udGV4dCkoe1xuICAgIGlzTmF0aXZlOiB0cnVlLFxuICAgIG9wZW46ICRlYThkY2JjYjllYTFiNTU2JHZhciRvcGVuU3ludGhldGljTGlua1xufSk7XG5mdW5jdGlvbiAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkMzIzZTRmYzJmYTQ3NTNmYihwcm9wcykge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgbmF2aWdhdGU6IG5hdmlnYXRlIH0gPSBwcm9wcztcbiAgICBsZXQgY3R4ID0gKDAsICQxMnVHcCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIGlzTmF0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG9wZW46ICh0YXJnZXQsIG1vZGlmaWVycyk9PntcbiAgICAgICAgICAgICAgICAkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkZ2V0U3ludGhldGljTGluayh0YXJnZXQsIChsaW5rKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JGVmYThjOTA5OWU1MzAyMzUobGluaywgbW9kaWZpZXJzKSkgbmF2aWdhdGUobGluay5wYXRobmFtZSArIGxpbmsuc2VhcmNoICsgbGluay5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNyhsaW5rLCBtb2RpZmllcnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgW1xuICAgICAgICBuYXZpZ2F0ZVxuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkMTJ1R3AkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJGVhOGRjYmNiOWVhMWI1NTYkdmFyJFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGN0eFxuICAgIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5YTMwMmE0NWY2NWQwNTcyKCkge1xuICAgIHJldHVybiAoMCwgJDEydUdwJHVzZUNvbnRleHQpKCRlYThkY2JjYjllYTFiNTU2JHZhciRSb3V0ZXJDb250ZXh0KTtcbn1cbmZ1bmN0aW9uICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCRlZmE4YzkwOTllNTMwMjM1KGxpbmssIG1vZGlmaWVycykge1xuICAgIC8vIFVzZSBnZXRBdHRyaWJ1dGUgaGVyZSBpbnN0ZWFkIG9mIGxpbmsudGFyZ2V0LiBGaXJlZm94IHdpbGwgZGVmYXVsdCBsaW5rLnRhcmdldCB0byBcIl9wYXJlbnRcIiB3aGVuIGluc2lkZSBhbiBpZnJhbWUuXG4gICAgbGV0IHRhcmdldCA9IGxpbmsuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuICAgIHJldHVybiAoIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiYgbGluay5vcmlnaW4gPT09IGxvY2F0aW9uLm9yaWdpbiAmJiAhbGluay5oYXNBdHRyaWJ1dGUoXCJkb3dubG9hZFwiKSAmJiAhbW9kaWZpZXJzLm1ldGFLZXkgJiYgLy8gb3BlbiBpbiBuZXcgdGFiIChtYWMpXG4gICAgIW1vZGlmaWVycy5jdHJsS2V5ICYmIC8vIG9wZW4gaW4gbmV3IHRhYiAod2luZG93cylcbiAgICAhbW9kaWZpZXJzLmFsdEtleSAmJiAvLyBkb3dubG9hZFxuICAgICFtb2RpZmllcnMuc2hpZnRLZXk7XG59XG5mdW5jdGlvbiAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNyh0YXJnZXQsIG1vZGlmaWVycywgc2V0T3BlbmluZyA9IHRydWUpIHtcbiAgICB2YXIgX3dpbmRvd19ldmVudF90eXBlLCBfd2luZG93X2V2ZW50O1xuICAgIGxldCB7IG1ldGFLZXk6IG1ldGFLZXksIGN0cmxLZXk6IGN0cmxLZXksIGFsdEtleTogYWx0S2V5LCBzaGlmdEtleTogc2hpZnRLZXkgfSA9IG1vZGlmaWVycztcbiAgICAvLyBGaXJlZm94IGRvZXMgbm90IHJlY29nbml6ZSBrZXlib2FyZCBldmVudHMgYXMgYSB1c2VyIGFjdGlvbiBieSBkZWZhdWx0LCBhbmQgdGhlIHBvcHVwIGJsb2NrZXJcbiAgICAvLyB3aWxsIHByZXZlbnQgbGlua3Mgd2l0aCB0YXJnZXQ9XCJfYmxhbmtcIiBmcm9tIG9wZW5pbmcuIEhvd2V2ZXIsIGl0IGRvZXMgYWxsb3cgdGhlIGV2ZW50IGlmIHRoZVxuICAgIC8vIENvbW1hbmQvQ29udHJvbCBrZXkgaXMgaGVsZCwgd2hpY2ggb3BlbnMgdGhlIGxpbmsgaW4gYSBiYWNrZ3JvdW5kIHRhYi4gVGhpcyBzZWVtcyBsaWtlIHRoZSBiZXN0IHdlIGNhbiBkby5cbiAgICAvLyBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjU3ODcwIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDY2NDAuXG4gICAgaWYgKCgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYjdkNzg5OTNiNzRmNzY2ZCkoKSAmJiAoKF93aW5kb3dfZXZlbnQgPSB3aW5kb3cuZXZlbnQpID09PSBudWxsIHx8IF93aW5kb3dfZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfd2luZG93X2V2ZW50X3R5cGUgPSBfd2luZG93X2V2ZW50LnR5cGUpID09PSBudWxsIHx8IF93aW5kb3dfZXZlbnRfdHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvd19ldmVudF90eXBlLnN0YXJ0c1dpdGgoXCJrZXlcIikpICYmIHRhcmdldC50YXJnZXQgPT09IFwiX2JsYW5rXCIpIHtcbiAgICAgICAgaWYgKCgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCkoKSkgbWV0YUtleSA9IHRydWU7XG4gICAgICAgIGVsc2UgY3RybEtleSA9IHRydWU7XG4gICAgfVxuICAgIC8vIFdlYktpdCBkb2VzIG5vdCBzdXBwb3J0IGZpcmluZyBjbGljayBldmVudHMgd2l0aCBtb2RpZmllciBrZXlzLCBidXQgZG9lcyBzdXBwb3J0IGtleWJvYXJkIGV2ZW50cy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vV2ViS2l0L1dlYktpdC9ibG9iL2MwM2QwYWM2ZTZkYjE3OGY5MDkyM2EwYTYzMDgwYjVjYTIxMGQyNWYvU291cmNlL1dlYkNvcmUvaHRtbC9IVE1MQW5jaG9yRWxlbWVudC5jcHAjTDE4NFxuICAgIGxldCBldmVudCA9ICgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNzg1NTEwNDM1ODJhNmE5OCkoKSAmJiAoMCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTApKCkgJiYgISgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkN2JlZjA0OWNlOTJlNDIyNCkoKSAmJiB0cnVlID8gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXlkb3duXCIsIHtcbiAgICAgICAga2V5SWRlbnRpZmllcjogXCJFbnRlclwiLFxuICAgICAgICBtZXRhS2V5OiBtZXRhS2V5LFxuICAgICAgICBjdHJsS2V5OiBjdHJsS2V5LFxuICAgICAgICBhbHRLZXk6IGFsdEtleSxcbiAgICAgICAgc2hpZnRLZXk6IHNoaWZ0S2V5XG4gICAgfSkgOiBuZXcgTW91c2VFdmVudChcImNsaWNrXCIsIHtcbiAgICAgICAgbWV0YUtleTogbWV0YUtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgYWx0S2V5OiBhbHRLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3LmlzT3BlbmluZyA9IHNldE9wZW5pbmc7XG4gICAgKDAsICQ3MjE1YWZjNmRlNjA2ZDZiJGV4cG9ydCRkZTc5ZTJjNjk1ZTA1MmYzKSh0YXJnZXQpO1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOTUxODVkNjk5ZTA1ZDRkNy5pc09wZW5pbmcgPSBmYWxzZTtcbn1cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXJjZWwtYnVuZGxlci9wYXJjZWwvaXNzdWVzLzg3MjRcbiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3LmlzT3BlbmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkdmFyJGdldFN5bnRoZXRpY0xpbmsodGFyZ2V0LCBvcGVuKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50KSBvcGVuKHRhcmdldCk7XG4gICAgZWxzZSBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtaHJlZlwiKSkge1xuICAgICAgICBsZXQgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICBsaW5rLmhyZWYgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1ocmVmXCIpO1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpKSBsaW5rLnRhcmdldCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRhcmdldFwiKTtcbiAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlbFwiKSkgbGluay5yZWwgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWxcIik7XG4gICAgICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKFwiZGF0YS1kb3dubG9hZFwiKSkgbGluay5kb3dubG9hZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRvd25sb2FkXCIpO1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtcGluZ1wiKSkgbGluay5waW5nID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcGluZ1wiKTtcbiAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlZmVycmVyLXBvbGljeVwiKSkgbGluay5yZWZlcnJlclBvbGljeSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlZmVycmVyLXBvbGljeVwiKTtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgICBvcGVuKGxpbmspO1xuICAgICAgICB0YXJnZXQucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgfVxufVxuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkdmFyJG9wZW5TeW50aGV0aWNMaW5rKHRhcmdldCwgbW9kaWZpZXJzKSB7XG4gICAgJGVhOGRjYmNiOWVhMWI1NTYkdmFyJGdldFN5bnRoZXRpY0xpbmsodGFyZ2V0LCAobGluayk9PiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3KGxpbmssIG1vZGlmaWVycykpO1xufVxuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDUxNDM3ZDUwMzM3M2QyMjMocHJvcHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBcImRhdGEtaHJlZlwiOiBwcm9wcy5ocmVmLFxuICAgICAgICBcImRhdGEtdGFyZ2V0XCI6IHByb3BzLnRhcmdldCxcbiAgICAgICAgXCJkYXRhLXJlbFwiOiBwcm9wcy5yZWwsXG4gICAgICAgIFwiZGF0YS1kb3dubG9hZFwiOiBwcm9wcy5kb3dubG9hZCxcbiAgICAgICAgXCJkYXRhLXBpbmdcIjogcHJvcHMucGluZyxcbiAgICAgICAgXCJkYXRhLXJlZmVycmVyLXBvbGljeVwiOiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFdlIHN0b3JlIGEgZ2xvYmFsIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCBhcmUgY3VycmVudGx5IHRyYW5zaXRpb25pbmcsXG4vLyBtYXBwZWQgdG8gYSBzZXQgb2YgQ1NTIHByb3BlcnRpZXMgdGhhdCBhcmUgdHJhbnNpdGlvbmluZyBmb3IgdGhhdCBlbGVtZW50LlxuLy8gVGhpcyBpcyBuZWNlc3NhcnkgcmF0aGVyIHRoYW4gYSBzaW1wbGUgY291bnQgb2YgdHJhbnNpdGlvbnMgYmVjYXVzZSBvZiBicm93c2VyXG4vLyBidWdzLCBlLmcuIENocm9tZSBzb21ldGltZXMgZmlyZXMgYm90aCB0cmFuc2l0aW9uZW5kIGFuZCB0cmFuc2l0aW9uY2FuY2VsIHJhdGhlclxuLy8gdGhhbiBvbmUgb3IgdGhlIG90aGVyLiBTbyB3ZSBuZWVkIHRvIHRyYWNrIHdoYXQncyBhY3R1YWxseSB0cmFuc2l0aW9uaW5nIHNvIHRoYXRcbi8vIHdlIGNhbiBpZ25vcmUgdGhlc2UgZHVwbGljYXRlIGV2ZW50cy5cbmxldCAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQgPSBuZXcgTWFwKCk7XG4vLyBBIGxpc3Qgb2YgY2FsbGJhY2tzIHRvIGNhbGwgb25jZSB0aGVyZSBhcmUgbm8gdHJhbnNpdGlvbmluZyBlbGVtZW50cy5cbmxldCAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbkNhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uICRiYmVkOGI0MWY4NTdiY2MwJHZhciRzZXR1cEdsb2JhbEV2ZW50cygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGlzVHJhbnNpdGlvbkV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBcInByb3BlcnR5TmFtZVwiIGluIGV2ZW50O1xuICAgIH1cbiAgICBsZXQgb25UcmFuc2l0aW9uU3RhcnQgPSAoZSk9PntcbiAgICAgICAgaWYgKCFpc1RyYW5zaXRpb25FdmVudChlKSB8fCAhZS50YXJnZXQpIHJldHVybjtcbiAgICAgICAgLy8gQWRkIHRoZSB0cmFuc2l0aW9uaW5nIHByb3BlcnR5IHRvIHRoZSBsaXN0IGZvciB0aGlzIGVsZW1lbnQuXG4gICAgICAgIGxldCB0cmFuc2l0aW9ucyA9ICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudC5nZXQoZS50YXJnZXQpO1xuICAgICAgICBpZiAoIXRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudC5zZXQoZS50YXJnZXQsIHRyYW5zaXRpb25zKTtcbiAgICAgICAgICAgIC8vIFRoZSB0cmFuc2l0aW9uY2FuY2VsIGV2ZW50IG11c3QgYmUgcmVnaXN0ZXJlZCBvbiB0aGUgZWxlbWVudCBpdHNlbGYsIHJhdGhlciB0aGFuIGFzIGEgZ2xvYmFsXG4gICAgICAgICAgICAvLyBldmVudC4gVGhpcyBlbmFibGVzIHVzIHRvIGhhbmRsZSB3aGVuIHRoZSBub2RlIGlzIGRlbGV0ZWQgZnJvbSB0aGUgZG9jdW1lbnQgd2hpbGUgaXQgaXMgdHJhbnNpdGlvbmluZy5cbiAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhlIGNhbmNlbCBldmVudCB3b3VsZCBoYXZlIG5vd2hlcmUgdG8gYnViYmxlIHRvIHNvIHdlIG5lZWQgdG8gaGFuZGxlIGl0IGRpcmVjdGx5LlxuICAgICAgICAgICAgZS50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25jYW5jZWxcIiwgb25UcmFuc2l0aW9uRW5kLCB7XG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNpdGlvbnMuYWRkKGUucHJvcGVydHlOYW1lKTtcbiAgICB9O1xuICAgIGxldCBvblRyYW5zaXRpb25FbmQgPSAoZSk9PntcbiAgICAgICAgaWYgKCFpc1RyYW5zaXRpb25FdmVudChlKSB8fCAhZS50YXJnZXQpIHJldHVybjtcbiAgICAgICAgLy8gUmVtb3ZlIHByb3BlcnR5IGZyb20gbGlzdCBvZiB0cmFuc2l0aW9uaW5nIHByb3BlcnRpZXMuXG4gICAgICAgIGxldCBwcm9wZXJ0aWVzID0gJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50LmdldChlLnRhcmdldCk7XG4gICAgICAgIGlmICghcHJvcGVydGllcykgcmV0dXJuO1xuICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZShlLnByb3BlcnR5TmFtZSk7XG4gICAgICAgIC8vIElmIGVtcHR5LCByZW1vdmUgdHJhbnNpdGlvbmNhbmNlbCBldmVudCwgYW5kIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBsaXN0IG9mIHRyYW5zaXRpb25pbmcgZWxlbWVudHMuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uY2FuY2VsXCIsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgICAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQuZGVsZXRlKGUudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyB0cmFuc2l0aW9uaW5nIGVsZW1lbnRzLCBjYWxsIGFsbCBvZiB0aGUgcXVldWVkIGNhbGxiYWNrcy5cbiAgICAgICAgaWYgKCRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjYiBvZiAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbkNhbGxiYWNrcyljYigpO1xuICAgICAgICAgICAgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25DYWxsYmFja3MuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbnJ1blwiLCBvblRyYW5zaXRpb25TdGFydCk7XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBvblRyYW5zaXRpb25FbmQpO1xufVxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHNldHVwR2xvYmFsRXZlbnRzKCk7XG4gICAgZWxzZSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAkYmJlZDhiNDFmODU3YmNjMCR2YXIkc2V0dXBHbG9iYWxFdmVudHMpO1xufVxuZnVuY3Rpb24gJGJiZWQ4YjQxZjg1N2JjYzAkZXhwb3J0JDI0NDkwMzE2Zjc2NGM0MzAoZm4pIHtcbiAgICAvLyBXYWl0IG9uZSBmcmFtZSB0byBzZWUgaWYgYW4gYW5pbWF0aW9uIHN0YXJ0cywgZS5nLiBhIHRyYW5zaXRpb24gb24gbW91bnQuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XG4gICAgICAgIC8vIElmIG5vIHRyYW5zaXRpb25zIGFyZSBydW5uaW5nLCBjYWxsIHRoZSBmdW5jdGlvbiBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhZGQgaXQgdG8gYSBsaXN0IG9mIGNhbGxiYWNrcyB0byBydW4gYXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uLlxuICAgICAgICBpZiAoJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50LnNpemUgPT09IDApIGZuKCk7XG4gICAgICAgIGVsc2UgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25DYWxsYmFja3MuYWRkKGZuKTtcbiAgICB9KTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLyogZXNsaW50LWRpc2FibGUgcnVsZXNkaXIvcHVyZS1yZW5kZXIgKi8gXG5cbi8vIEtlZXAgdHJhY2sgb2YgZWxlbWVudHMgdGhhdCB3ZSBhcmUgY3VycmVudGx5IGhhbmRsaW5nIGRyYWdnaW5nIGZvciB2aWEgdXNlRHJhZzFELlxuLy8gSWYgdGhlcmUncyBhbiBhbmNlc3RvciBhbmQgYSBkZXNjZW5kYW50IGJvdGggdXNpbmcgdXNlRHJhZzFEKCksIGFuZCB0aGUgdXNlciBzdGFydHNcbi8vIGRyYWdnaW5nIHRoZSBkZXNjZW5kYW50LCB3ZSBkb24ndCB3YW50IHVzZURyYWcxRCBldmVudHMgdG8gZmlyZSBmb3IgdGhlIGFuY2VzdG9yLlxuY29uc3QgJDljYzA5ZGY5ZmQ3Njc2YmUkdmFyJGRyYWdnaW5nRWxlbWVudHMgPSBbXTtcbmZ1bmN0aW9uICQ5Y2MwOWRmOWZkNzY3NmJlJGV4cG9ydCQ3YmJlZDc1ZmViYTM5NzA2KHByb3BzKSB7XG4gICAgY29uc29sZS53YXJuKFwidXNlRHJhZzFEIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYHVzZU1vdmVgIGluc3RlYWQgaHR0cHM6Ly9yZWFjdC1zcGVjdHJ1bS5hZG9iZS5jb20vcmVhY3QtYXJpYS91c2VNb3ZlLmh0bWxcIik7XG4gICAgbGV0IHsgY29udGFpbmVyUmVmOiBjb250YWluZXJSZWYsIHJldmVyc2U6IHJldmVyc2UsIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbiwgb25Ib3Zlcjogb25Ib3Zlciwgb25EcmFnOiBvbkRyYWcsIG9uUG9zaXRpb25DaGFuZ2U6IG9uUG9zaXRpb25DaGFuZ2UsIG9uSW5jcmVtZW50OiBvbkluY3JlbWVudCwgb25EZWNyZW1lbnQ6IG9uRGVjcmVtZW50LCBvbkluY3JlbWVudFRvTWF4OiBvbkluY3JlbWVudFRvTWF4LCBvbkRlY3JlbWVudFRvTWluOiBvbkRlY3JlbWVudFRvTWluLCBvbkNvbGxhcHNlVG9nZ2xlOiBvbkNvbGxhcHNlVG9nZ2xlIH0gPSBwcm9wcztcbiAgICBsZXQgZ2V0UG9zaXRpb24gPSAoZSk9Pm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IGUuY2xpZW50WCA6IGUuY2xpZW50WTtcbiAgICBsZXQgZ2V0TmV4dE9mZnNldCA9IChlKT0+e1xuICAgICAgICBsZXQgY29udGFpbmVyT2Zmc2V0ID0gKDAsICRhYjcxZGFkYjAzYTZmYjJlJGV4cG9ydCQ2MjJjZWE0NDVhMWM1YjdkKShjb250YWluZXJSZWYuY3VycmVudCwgcmV2ZXJzZSwgb3JpZW50YXRpb24pO1xuICAgICAgICBsZXQgbW91c2VPZmZzZXQgPSBnZXRQb3NpdGlvbihlKTtcbiAgICAgICAgbGV0IG5leHRPZmZzZXQgPSByZXZlcnNlID8gY29udGFpbmVyT2Zmc2V0IC0gbW91c2VPZmZzZXQgOiBtb3VzZU9mZnNldCAtIGNvbnRhaW5lck9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5leHRPZmZzZXQ7XG4gICAgfTtcbiAgICBsZXQgZHJhZ2dpbmcgPSAoMCwgJDEydUdwJHVzZVJlZikoZmFsc2UpO1xuICAgIGxldCBwcmV2UG9zaXRpb24gPSAoMCwgJDEydUdwJHVzZVJlZikoMCk7XG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBoYW5kbGVycyBpbiBhIHJlZiBzbyB0aGF0IHRoZSBldmVudHMgY2FuIGFjY2VzcyB0aGVtLlxuICAgIGxldCBoYW5kbGVycyA9ICgwLCAkMTJ1R3AkdXNlUmVmKSh7XG4gICAgICAgIG9uUG9zaXRpb25DaGFuZ2U6IG9uUG9zaXRpb25DaGFuZ2UsXG4gICAgICAgIG9uRHJhZzogb25EcmFnXG4gICAgfSk7XG4gICAgaGFuZGxlcnMuY3VycmVudC5vbkRyYWcgPSBvbkRyYWc7XG4gICAgaGFuZGxlcnMuY3VycmVudC5vblBvc2l0aW9uQ2hhbmdlID0gb25Qb3NpdGlvbkNoYW5nZTtcbiAgICBsZXQgb25Nb3VzZURyYWdnZWQgPSAoZSk9PntcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgbmV4dE9mZnNldCA9IGdldE5leHRPZmZzZXQoZSk7XG4gICAgICAgIGlmICghZHJhZ2dpbmcuY3VycmVudCkge1xuICAgICAgICAgICAgZHJhZ2dpbmcuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMuY3VycmVudC5vbkRyYWcpIGhhbmRsZXJzLmN1cnJlbnQub25EcmFnKHRydWUpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJzLmN1cnJlbnQub25Qb3NpdGlvbkNoYW5nZSkgaGFuZGxlcnMuY3VycmVudC5vblBvc2l0aW9uQ2hhbmdlKG5leHRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UG9zaXRpb24uY3VycmVudCA9PT0gbmV4dE9mZnNldCkgcmV0dXJuO1xuICAgICAgICBwcmV2UG9zaXRpb24uY3VycmVudCA9IG5leHRPZmZzZXQ7XG4gICAgICAgIGlmIChvblBvc2l0aW9uQ2hhbmdlKSBvblBvc2l0aW9uQ2hhbmdlKG5leHRPZmZzZXQpO1xuICAgIH07XG4gICAgbGV0IG9uTW91c2VVcCA9IChlKT0+e1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgZHJhZ2dpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgbmV4dE9mZnNldCA9IGdldE5leHRPZmZzZXQoZSk7XG4gICAgICAgIGlmIChoYW5kbGVycy5jdXJyZW50Lm9uRHJhZykgaGFuZGxlcnMuY3VycmVudC5vbkRyYWcoZmFsc2UpO1xuICAgICAgICBpZiAoaGFuZGxlcnMuY3VycmVudC5vblBvc2l0aW9uQ2hhbmdlKSBoYW5kbGVycy5jdXJyZW50Lm9uUG9zaXRpb25DaGFuZ2UobmV4dE9mZnNldCk7XG4gICAgICAgICQ5Y2MwOWRmOWZkNzY3NmJlJHZhciRkcmFnZ2luZ0VsZW1lbnRzLnNwbGljZSgkOWNjMDlkZjlmZDc2NzZiZSR2YXIkZHJhZ2dpbmdFbGVtZW50cy5pbmRleE9mKHRhcmdldCksIDEpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VEcmFnZ2VkLCBmYWxzZSk7XG4gICAgfTtcbiAgICBsZXQgb25Nb3VzZURvd24gPSAoZSk9PntcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IGhhbmRsaW5nIGRyYWdnaW5nIG9uIGEgZGVzY2VuZGFudCB3aXRoIHVzZURyYWcxRCwgdGhlblxuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGhhbmRsZSB0aGUgZHJhZyBtb3Rpb24gb24gdGhpcyB0YXJnZXQgYXMgd2VsbC5cbiAgICAgICAgaWYgKCQ5Y2MwOWRmOWZkNzY3NmJlJHZhciRkcmFnZ2luZ0VsZW1lbnRzLnNvbWUoKGVsdCk9PnRhcmdldC5jb250YWlucyhlbHQpKSkgcmV0dXJuO1xuICAgICAgICAkOWNjMDlkZjlmZDc2NzZiZSR2YXIkZHJhZ2dpbmdFbGVtZW50cy5wdXNoKHRhcmdldCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VEcmFnZ2VkLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgICB9O1xuICAgIGxldCBvbk1vdXNlRW50ZXIgPSAoKT0+e1xuICAgICAgICBpZiAob25Ib3Zlcikgb25Ib3Zlcih0cnVlKTtcbiAgICB9O1xuICAgIGxldCBvbk1vdXNlT3V0ID0gKCk9PntcbiAgICAgICAgaWYgKG9uSG92ZXIpIG9uSG92ZXIoZmFsc2UpO1xuICAgIH07XG4gICAgbGV0IG9uS2V5RG93biA9IChlKT0+e1xuICAgICAgICBzd2l0Y2goZS5rZXkpe1xuICAgICAgICAgICAgY2FzZSBcIkxlZnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRGVjcmVtZW50ICYmICFyZXZlcnNlKSBvbkRlY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbkluY3JlbWVudCAmJiByZXZlcnNlKSBvbkluY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJVcFwiOlxuICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkRlY3JlbWVudCAmJiAhcmV2ZXJzZSkgb25EZWNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob25JbmNyZW1lbnQgJiYgcmV2ZXJzZSkgb25JbmNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUmlnaHRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkluY3JlbWVudCAmJiAhcmV2ZXJzZSkgb25JbmNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob25EZWNyZW1lbnQgJiYgcmV2ZXJzZSkgb25EZWNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRG93blwiOlxuICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uSW5jcmVtZW50ICYmICFyZXZlcnNlKSBvbkluY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbkRlY3JlbWVudCAmJiByZXZlcnNlKSBvbkRlY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChvbkRlY3JlbWVudFRvTWluKSBvbkRlY3JlbWVudFRvTWluKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChvbkluY3JlbWVudFRvTWF4KSBvbkluY3JlbWVudFRvTWF4KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uQ29sbGFwc2VUb2dnbGUpIG9uQ29sbGFwc2VUb2dnbGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb25Nb3VzZURvd246IG9uTW91c2VEb3duLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZU91dDogb25Nb3VzZU91dCxcbiAgICAgICAgb25LZXlEb3duOiBvbktleURvd25cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQwM2RlYjIzZmYxNDkyMGM0JGV4cG9ydCQ0ZWFmMDRlNTRhYThlZWQ2KCkge1xuICAgIGxldCBnbG9iYWxMaXN0ZW5lcnMgPSAoMCwgJDEydUdwJHVzZVJlZikobmV3IE1hcCgpKTtcbiAgICBsZXQgYWRkR2xvYmFsTGlzdGVuZXIgPSAoMCwgJDEydUdwJHVzZUNhbGxiYWNrKSgoZXZlbnRUYXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKT0+e1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcmVtb3ZlIHRoZSBsaXN0ZW5lciBhZnRlciBpdCBpcyBjYWxsZWQgd2l0aCB0aGUgYG9uY2VgIG9wdGlvbi5cbiAgICAgICAgbGV0IGZuID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbmNlKSA/ICguLi5hcmdzKT0+e1xuICAgICAgICAgICAgZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgICAgICB9IDogbGlzdGVuZXI7XG4gICAgICAgIGdsb2JhbExpc3RlbmVycy5jdXJyZW50LnNldChsaXN0ZW5lciwge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGV2ZW50VGFyZ2V0OiBldmVudFRhcmdldCxcbiAgICAgICAgICAgIGZuOiBmbixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH0sIFtdKTtcbiAgICBsZXQgcmVtb3ZlR2xvYmFsTGlzdGVuZXIgPSAoMCwgJDEydUdwJHVzZUNhbGxiYWNrKSgoZXZlbnRUYXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKT0+e1xuICAgICAgICB2YXIgX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldDtcbiAgICAgICAgbGV0IGZuID0gKChfZ2xvYmFsTGlzdGVuZXJzX2N1cnJlbnRfZ2V0ID0gZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZ2V0KGxpc3RlbmVyKSkgPT09IG51bGwgfHwgX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldC5mbikgfHwgbGlzdGVuZXI7XG4gICAgICAgIGV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xuICAgICAgICBnbG9iYWxMaXN0ZW5lcnMuY3VycmVudC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH0sIFtdKTtcbiAgICBsZXQgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzID0gKDAsICQxMnVHcCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHZhbHVlLmV2ZW50VGFyZ2V0LCB2YWx1ZS50eXBlLCBrZXksIHZhbHVlLm9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyXG4gICAgXSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAoMCwgJDEydUdwJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgcmV0dXJuIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycztcbiAgICB9LCBbXG4gICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVyc1xuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZEdsb2JhbExpc3RlbmVyOiBhZGRHbG9iYWxMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXI6IHJlbW92ZUdsb2JhbExpc3RlbmVyLFxuICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnM6IHJlbW92ZUFsbEdsb2JhbExpc3RlbmVyc1xuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDMxM2I5ODg2MWVlNWRkNmMkZXhwb3J0JGQ2ODc1MTIyMTk0YzdiNDQocHJvcHMsIGRlZmF1bHRMYWJlbCkge1xuICAgIGxldCB7IGlkOiBpZCwgXCJhcmlhLWxhYmVsXCI6IGxhYmVsLCBcImFyaWEtbGFiZWxsZWRieVwiOiBsYWJlbGxlZEJ5IH0gPSBwcm9wcztcbiAgICAvLyBJZiB0aGVyZSBpcyBib3RoIGFuIGFyaWEtbGFiZWwgYW5kIGFyaWEtbGFiZWxsZWRieSxcbiAgICAvLyBjb21iaW5lIHRoZW0gYnkgcG9pbnRpbmcgdG8gdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgIGlkID0gKDAsICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRmNjgwODc3YTM0NzExZTM3KShpZCk7XG4gICAgaWYgKGxhYmVsbGVkQnkgJiYgbGFiZWwpIHtcbiAgICAgICAgbGV0IGlkcyA9IG5ldyBTZXQoW1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAuLi5sYWJlbGxlZEJ5LnRyaW0oKS5zcGxpdCgvXFxzKy8pXG4gICAgICAgIF0pO1xuICAgICAgICBsYWJlbGxlZEJ5ID0gW1xuICAgICAgICAgICAgLi4uaWRzXG4gICAgICAgIF0uam9pbihcIiBcIik7XG4gICAgfSBlbHNlIGlmIChsYWJlbGxlZEJ5KSBsYWJlbGxlZEJ5ID0gbGFiZWxsZWRCeS50cmltKCkuc3BsaXQoL1xccysvKS5qb2luKFwiIFwiKTtcbiAgICAvLyBJZiBubyBsYWJlbHMgYXJlIHByb3ZpZGVkLCB1c2UgdGhlIGRlZmF1bHRcbiAgICBpZiAoIWxhYmVsICYmICFsYWJlbGxlZEJ5ICYmIGRlZmF1bHRMYWJlbCkgbGFiZWwgPSBkZWZhdWx0TGFiZWw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogbGFiZWwsXG4gICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkQnlcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICRkZjU2MTY0ZGZmNTc4NWUyJGV4cG9ydCQ0MzM4YjUzMzE1YWJmNjY2KGZvcndhcmRlZFJlZikge1xuICAgIGNvbnN0IG9ialJlZiA9ICgwLCAkMTJ1R3AkdXNlUmVmKShudWxsKTtcbiAgICByZXR1cm4gKDAsICQxMnVHcCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIGdldCBjdXJyZW50ICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IGN1cnJlbnQgKHZhbHVlKXtcbiAgICAgICAgICAgICAgICBvYmpSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcImZ1bmN0aW9uXCIpIGZvcndhcmRlZFJlZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9yd2FyZGVkUmVmKSBmb3J3YXJkZWRSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgW1xuICAgICAgICBmb3J3YXJkZWRSZWZcbiAgICBdKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNGY1OGM1ZjcyYmNmNzlmNyRleHBvcnQkNDk2MzE1YTE2MDhkOTYwMihlZmZlY3QsIGRlcGVuZGVuY2llcykge1xuICAgIGNvbnN0IGlzSW5pdGlhbE1vdW50ID0gKDAsICQxMnVHcCR1c2VSZWYpKHRydWUpO1xuICAgIGNvbnN0IGxhc3REZXBzID0gKDAsICQxMnVHcCR1c2VSZWYpKG51bGwpO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpc0luaXRpYWxNb3VudC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpc0luaXRpYWxNb3VudC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoaXNJbml0aWFsTW91bnQuY3VycmVudCkgaXNJbml0aWFsTW91bnQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBlbHNlIGlmICghbGFzdERlcHMuY3VycmVudCB8fCBkZXBlbmRlbmNpZXMuc29tZSgoZGVwLCBpKT0+IU9iamVjdC5pcyhkZXAsIGxhc3REZXBzW2ldKSkpIGVmZmVjdCgpO1xuICAgICAgICBsYXN0RGVwcy5jdXJyZW50ID0gZGVwZW5kZW5jaWVzO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBkZXBlbmRlbmNpZXMpO1xufVxuXG5cblxuXG5mdW5jdGlvbiAkOWRhYWIwMmQ0NjE4MDlkYiR2YXIkaGFzUmVzaXplT2JzZXJ2ZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiAkOWRhYWIwMmQ0NjE4MDlkYiRleHBvcnQkNjgzNDgwZjE5MWMwZTNlYShvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZWY6IHJlZiwgb25SZXNpemU6IG9uUmVzaXplIH0gPSBvcHRpb25zO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgZWxlbWVudCA9IHJlZiA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcbiAgICAgICAgaWYgKCEkOWRhYWIwMmQ0NjE4MDlkYiR2YXIkaGFzUmVzaXplT2JzZXJ2ZXIoKSkge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXJJbnN0YW5jZSA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG9uUmVzaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVySW5zdGFuY2Uub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSByZXNpemVPYnNlcnZlckluc3RhbmNlLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uUmVzaXplLFxuICAgICAgICByZWZcbiAgICBdKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkZTc4MDFiZTgyYjRiMmE1MyRleHBvcnQkNGRlYmRiMWEzZjBmYTc5ZShjb250ZXh0LCByZWYpIHtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKCgpPT57XG4gICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQucmVmICYmIHJlZikge1xuICAgICAgICAgICAgY29udGV4dC5yZWYuY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQucmVmKSBjb250ZXh0LnJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JGNmYTIyMjVlODc5Mzg3ODEobm9kZSwgY2hlY2tGb3JPdmVyZmxvdykge1xuICAgIGxldCBzY3JvbGxhYmxlTm9kZSA9IG5vZGU7XG4gICAgaWYgKCQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCQyYmI3NDc0MGM0ZTE5ZGVmKHNjcm9sbGFibGVOb2RlLCBjaGVja0Zvck92ZXJmbG93KSkgc2Nyb2xsYWJsZU5vZGUgPSBzY3JvbGxhYmxlTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHdoaWxlKHNjcm9sbGFibGVOb2RlICYmICEkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkMmJiNzQ3NDBjNGUxOWRlZihzY3JvbGxhYmxlTm9kZSwgY2hlY2tGb3JPdmVyZmxvdykpc2Nyb2xsYWJsZU5vZGUgPSBzY3JvbGxhYmxlTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHJldHVybiBzY3JvbGxhYmxlTm9kZSB8fCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCQyYmI3NDc0MGM0ZTE5ZGVmKG5vZGUsIGNoZWNrRm9yT3ZlcmZsb3cpIHtcbiAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBsZXQgaXNTY3JvbGxhYmxlID0gLyhhdXRvfHNjcm9sbCkvLnRlc3Qoc3R5bGUub3ZlcmZsb3cgKyBzdHlsZS5vdmVyZmxvd1ggKyBzdHlsZS5vdmVyZmxvd1kpO1xuICAgIGlmIChpc1Njcm9sbGFibGUgJiYgY2hlY2tGb3JPdmVyZmxvdykgaXNTY3JvbGxhYmxlID0gbm9kZS5zY3JvbGxIZWlnaHQgIT09IG5vZGUuY2xpZW50SGVpZ2h0IHx8IG5vZGUuc2Nyb2xsV2lkdGggIT09IG5vZGUuY2xpZW50V2lkdGg7XG4gICAgcmV0dXJuIGlzU2Nyb2xsYWJsZTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbi8vIEB0cy1pZ25vcmVcbmxldCAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnZpc3VhbFZpZXdwb3J0O1xuZnVuY3Rpb24gJDVkZjY0YjM4MDdkYzE1ZWUkZXhwb3J0JGQ2OTk5MDVkZDU3YzczY2EoKSB7XG4gICAgbGV0IGlzU1NSID0gKDAsICQxMnVHcCR1c2VJc1NTUikoKTtcbiAgICBsZXQgW3NpemUsIHNldFNpemVdID0gKDAsICQxMnVHcCR1c2VTdGF0ZSkoKCk9PmlzU1NSID8ge1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSA6ICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciRnZXRWaWV3cG9ydFNpemUoKSk7XG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIC8vIFVzZSB2aXN1YWxWaWV3cG9ydCBhcGkgdG8gdHJhY2sgYXZhaWxhYmxlIGhlaWdodCBldmVuIG9uIGlPUyB2aXJ0dWFsIGtleWJvYXJkIG9wZW5pbmdcbiAgICAgICAgbGV0IG9uUmVzaXplID0gKCk9PntcbiAgICAgICAgICAgIHNldFNpemUoKHNpemUpPT57XG4gICAgICAgICAgICAgICAgbGV0IG5ld1NpemUgPSAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkZ2V0Vmlld3BvcnRTaXplKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1NpemUud2lkdGggPT09IHNpemUud2lkdGggJiYgbmV3U2l6ZS5oZWlnaHQgPT09IHNpemUuaGVpZ2h0KSByZXR1cm4gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3U2l6ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoISQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCkgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUpO1xuICAgICAgICBlbHNlICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAoISQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCkgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUpO1xuICAgICAgICAgICAgZWxzZSAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJGdldFZpZXdwb3J0U2l6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ICYmICgkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQgPT09IG51bGwgfHwgJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQud2lkdGgpIHx8IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQ6ICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCAmJiAoJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8ICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0LmhlaWdodCkgfHwgd2luZG93LmlubmVySGVpZ2h0XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmxldCAkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25JZCA9IDA7XG5jb25zdCAkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25Ob2RlcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uICRlZjA2MjU2MDc5Njg2YmEwJGV4cG9ydCRmOGFlZGE3YjEwNzUzZmExKGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IFtpZCwgc2V0SWRdID0gKDAsICQxMnVHcCR1c2VTdGF0ZSkoKTtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKCgpPT57XG4gICAgICAgIGlmICghZGVzY3JpcHRpb24pIHJldHVybjtcbiAgICAgICAgbGV0IGRlc2MgPSAkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25Ob2Rlcy5nZXQoZGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAoIWRlc2MpIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGByZWFjdC1hcmlhLWRlc2NyaXB0aW9uLSR7JGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uSWQrK31gO1xuICAgICAgICAgICAgc2V0SWQoaWQpO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgbm9kZS5pZCA9IGlkO1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICByZWZDb3VudDogMCxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uTm9kZXMuc2V0KGRlc2NyaXB0aW9uLCBkZXNjKTtcbiAgICAgICAgfSBlbHNlIHNldElkKGRlc2MuZWxlbWVudC5pZCk7XG4gICAgICAgIGRlc2MucmVmQ291bnQrKztcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAtLWRlc2MucmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZXNjLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgJGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uTm9kZXMuZGVsZXRlKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGRlc2NyaXB0aW9uXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGRlc2NyaXB0aW9uID8gaWQgOiB1bmRlZmluZWRcbiAgICB9O1xufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIxIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkZTlmYWFmYjY0MWUxNjdkYiRleHBvcnQkOTBmYzNhMTdkOTNmNzA0YyhyZWYsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGhhbmRsZUV2ZW50ID0gKDAsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKShoYW5kbGVyKTtcbiAgICBsZXQgaXNEaXNhYmxlZCA9IGhhbmRsZXIgPT0gbnVsbDtcbiAgICAoMCwgJDEydUdwJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgIXJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIGxldCBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlRXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlRXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcmVmLFxuICAgICAgICBldmVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgaGFuZGxlRXZlbnRcbiAgICBdKTtcbn1cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCQ1M2EwOTEwZjAzODMzN2JkKHNjcm9sbFZpZXcsIGVsZW1lbnQpIHtcbiAgICBsZXQgb2Zmc2V0WCA9ICQyZjA0Y2JjNDRlZTMwY2UwJHZhciRyZWxhdGl2ZU9mZnNldChzY3JvbGxWaWV3LCBlbGVtZW50LCBcImxlZnRcIik7XG4gICAgbGV0IG9mZnNldFkgPSAkMmYwNGNiYzQ0ZWUzMGNlMCR2YXIkcmVsYXRpdmVPZmZzZXQoc2Nyb2xsVmlldywgZWxlbWVudCwgXCJ0b3BcIik7XG4gICAgbGV0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICBsZXQgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IHggPSBzY3JvbGxWaWV3LnNjcm9sbExlZnQ7XG4gICAgbGV0IHkgPSBzY3JvbGxWaWV3LnNjcm9sbFRvcDtcbiAgICAvLyBBY2NvdW50IGZvciB0b3AvbGVmdCBib3JkZXIgb2Zmc2V0dGluZyB0aGUgc2Nyb2xsIHRvcC9MZWZ0XG4gICAgbGV0IHsgYm9yZGVyVG9wV2lkdGg6IGJvcmRlclRvcFdpZHRoLCBib3JkZXJMZWZ0V2lkdGg6IGJvcmRlckxlZnRXaWR0aCB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShzY3JvbGxWaWV3KTtcbiAgICBsZXQgYm9yZGVyQWRqdXN0ZWRYID0gc2Nyb2xsVmlldy5zY3JvbGxMZWZ0ICsgcGFyc2VJbnQoYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG4gICAgbGV0IGJvcmRlckFkanVzdGVkWSA9IHNjcm9sbFZpZXcuc2Nyb2xsVG9wICsgcGFyc2VJbnQoYm9yZGVyVG9wV2lkdGgsIDEwKTtcbiAgICAvLyBJZ25vcmUgZW5kL2JvdHRvbSBib3JkZXIgdmlhIGNsaWVudEhlaWdodC9XaWR0aCBpbnN0ZWFkIG9mIG9mZnNldEhlaWdodC9XaWR0aFxuICAgIGxldCBtYXhYID0gYm9yZGVyQWRqdXN0ZWRYICsgc2Nyb2xsVmlldy5jbGllbnRXaWR0aDtcbiAgICBsZXQgbWF4WSA9IGJvcmRlckFkanVzdGVkWSArIHNjcm9sbFZpZXcuY2xpZW50SGVpZ2h0O1xuICAgIGlmIChvZmZzZXRYIDw9IHgpIHggPSBvZmZzZXRYIC0gcGFyc2VJbnQoYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG4gICAgZWxzZSBpZiAob2Zmc2V0WCArIHdpZHRoID4gbWF4WCkgeCArPSBvZmZzZXRYICsgd2lkdGggLSBtYXhYO1xuICAgIGlmIChvZmZzZXRZIDw9IGJvcmRlckFkanVzdGVkWSkgeSA9IG9mZnNldFkgLSBwYXJzZUludChib3JkZXJUb3BXaWR0aCwgMTApO1xuICAgIGVsc2UgaWYgKG9mZnNldFkgKyBoZWlnaHQgPiBtYXhZKSB5ICs9IG9mZnNldFkgKyBoZWlnaHQgLSBtYXhZO1xuICAgIHNjcm9sbFZpZXcuc2Nyb2xsTGVmdCA9IHg7XG4gICAgc2Nyb2xsVmlldy5zY3JvbGxUb3AgPSB5O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgb2Zmc2V0IGxlZnQgb3IgdG9wIGZyb20gY2hpbGQgdG8gYW5jZXN0b3IgYnkgYWNjdW11bGF0aW5nXG4gKiBvZmZzZXRMZWZ0IG9yIG9mZnNldFRvcCB0aHJvdWdoIGludGVydmVuaW5nIG9mZnNldFBhcmVudHMuXG4gKi8gZnVuY3Rpb24gJDJmMDRjYmM0NGVlMzBjZTAkdmFyJHJlbGF0aXZlT2Zmc2V0KGFuY2VzdG9yLCBjaGlsZCwgYXhpcykge1xuICAgIGNvbnN0IHByb3AgPSBheGlzID09PSBcImxlZnRcIiA/IFwib2Zmc2V0TGVmdFwiIDogXCJvZmZzZXRUb3BcIjtcbiAgICBsZXQgc3VtID0gMDtcbiAgICB3aGlsZShjaGlsZC5vZmZzZXRQYXJlbnQpe1xuICAgICAgICBzdW0gKz0gY2hpbGRbcHJvcF07XG4gICAgICAgIGlmIChjaGlsZC5vZmZzZXRQYXJlbnQgPT09IGFuY2VzdG9yKSBicmVhaztcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQub2Zmc2V0UGFyZW50LmNvbnRhaW5zKGFuY2VzdG9yKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGFuY2VzdG9yIGlzIG5vdCBgcG9zaXRpb246cmVsYXRpdmVgLCB0aGVuIHdlIHN0b3AgYXRcbiAgICAgICAgICAgIC8vIF9pdHNfIG9mZnNldCBwYXJlbnQsIGFuZCB3ZSBzdWJ0cmFjdCBvZmYgX2l0c18gb2Zmc2V0LCBzbyB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBlbmQgdXAgd2l0aCB0aGUgcHJvcGVyIG9mZnNldCBmcm9tIGNoaWxkIHRvIGFuY2VzdG9yLlxuICAgICAgICAgICAgc3VtIC09IGFuY2VzdG9yW3Byb3BdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5mdW5jdGlvbiAkMmYwNGNiYzQ0ZWUzMGNlMCRleHBvcnQkYzgyNjg2MDc5NjMwOWQxYih0YXJnZXRFbGVtZW50LCBvcHRzKSB7XG4gICAgaWYgKGRvY3VtZW50LmNvbnRhaW5zKHRhcmdldEVsZW1lbnQpKSB7XG4gICAgICAgIGxldCByb290ID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGxldCBpc1Njcm9sbFByZXZlbnRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJvb3QpLm92ZXJmbG93ID09PSBcImhpZGRlblwiO1xuICAgICAgICAvLyBJZiBzY3JvbGxpbmcgaXMgbm90IGN1cnJlbnRseSBwcmV2ZW50ZWQgdGhlbiB3ZSBhcmVu4oCZdCBpbiBhIG92ZXJsYXkgbm9yIGlzIGEgb3ZlcmxheSBvcGVuLCBqdXN0IHVzZSBlbGVtZW50LnNjcm9sbEludG9WaWV3IHRvIGJyaW5nIHRoZSBlbGVtZW50IGludG8gdmlld1xuICAgICAgICBpZiAoIWlzU2Nyb2xsUHJldmVudGVkKSB7XG4gICAgICAgICAgICB2YXIgLy8gdXNlIHNjcm9sbEludG9WaWV3KHtibG9jazogJ25lYXJlc3QnfSkgaW5zdGVhZCBvZiAuZm9jdXMgdG8gY2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgZnVsbHkgaW4gdmlldyBvciBub3Qgc2luY2UgLmZvY3VzKClcbiAgICAgICAgICAgIC8vIHdvbid0IGNhdXNlIGEgc2Nyb2xsIGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCBhbmQgZG9lc24ndCBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gYW4gZWxlbWVudCBpcyBwYXJ0aWFsbHkgb3V0IG9mIHZpZXcgaG9yaXpvbnRhbGx5IHZzIHZlcnRpY2FsbHlcbiAgICAgICAgICAgIF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3O1xuICAgICAgICAgICAgbGV0IHsgbGVmdDogb3JpZ2luYWxMZWZ0LCB0b3A6IG9yaWdpbmFsVG9wIH0gPSB0YXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9PT0gbnVsbCB8fCB0YXJnZXRFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXcgPSB0YXJnZXRFbGVtZW50LnNjcm9sbEludG9WaWV3KSA9PT0gbnVsbCB8fCBfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXcuY2FsbCh0YXJnZXRFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCB7IGxlZnQ6IG5ld0xlZnQsIHRvcDogbmV3VG9wIH0gPSB0YXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgLy8gQWNjb3VudCBmb3Igc3ViIHBpeGVsIGRpZmZlcmVuY2VzIGZyb20gcm91bmRpbmdcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhvcmlnaW5hbExlZnQgLSBuZXdMZWZ0KSA+IDEgfHwgTWF0aC5hYnMob3JpZ2luYWxUb3AgLSBuZXdUb3ApID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBfb3B0c19jb250YWluaW5nRWxlbWVudF9zY3JvbGxJbnRvVmlldywgX29wdHNfY29udGFpbmluZ0VsZW1lbnQsIF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MTtcbiAgICAgICAgICAgICAgICBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfb3B0c19jb250YWluaW5nRWxlbWVudCA9IG9wdHMuY29udGFpbmluZ0VsZW1lbnQpID09PSBudWxsIHx8IF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX29wdHNfY29udGFpbmluZ0VsZW1lbnRfc2Nyb2xsSW50b1ZpZXcgPSBfb3B0c19jb250YWluaW5nRWxlbWVudC5zY3JvbGxJbnRvVmlldykgPT09IG51bGwgfHwgX29wdHNfY29udGFpbmluZ0VsZW1lbnRfc2Nyb2xsSW50b1ZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50X3Njcm9sbEludG9WaWV3LmNhbGwoX29wdHNfY29udGFpbmluZ0VsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZTogXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIChfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldzEgPSB0YXJnZXRFbGVtZW50LnNjcm9sbEludG9WaWV3KSA9PT0gbnVsbCB8fCBfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MS5jYWxsKHRhcmdldEVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsUGFyZW50ID0gKDAsICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCRjZmEyMjI1ZTg3OTM4NzgxKSh0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgIC8vIElmIHNjcm9sbGluZyBpcyBwcmV2ZW50ZWQsIHdlIGRvbid0IHdhbnQgdG8gc2Nyb2xsIHRoZSBib2R5IHNpbmNlIGl0IG1pZ2h0IG1vdmUgdGhlIG92ZXJsYXkgcGFydGlhbGx5IG9mZnNjcmVlbiBhbmQgdGhlIHVzZXIgY2FuJ3Qgc2Nyb2xsIGl0IGJhY2sgaW50byB2aWV3LlxuICAgICAgICAgICAgd2hpbGUodGFyZ2V0RWxlbWVudCAmJiBzY3JvbGxQYXJlbnQgJiYgdGFyZ2V0RWxlbWVudCAhPT0gcm9vdCAmJiBzY3JvbGxQYXJlbnQgIT09IHJvb3Qpe1xuICAgICAgICAgICAgICAgICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCQ1M2EwOTEwZjAzODMzN2JkKHNjcm9sbFBhcmVudCwgdGFyZ2V0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IHNjcm9sbFBhcmVudDtcbiAgICAgICAgICAgICAgICBzY3JvbGxQYXJlbnQgPSAoMCwgJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JGNmYTIyMjVlODc5Mzg3ODEpKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDYwMjc4ODcxNDU3NjIyZGUoZXZlbnQpIHtcbiAgICAvLyBKQVdTL05WREEgd2l0aCBGaXJlZm94LlxuICAgIGlmIChldmVudC5tb3pJbnB1dFNvdXJjZSA9PT0gMCAmJiBldmVudC5pc1RydXN0ZWQpIHJldHVybiB0cnVlO1xuICAgIC8vIEFuZHJvaWQgVGFsa0JhY2sncyBkZXRhaWwgdmFsdWUgdmFyaWVzIGRlcGVuZGluZyBvbiB0aGUgZXZlbnQgbGlzdGVuZXIgcHJvdmlkaW5nIHRoZSBldmVudCBzbyB3ZSBoYXZlIHNwZWNpZmljIGxvZ2ljIGhlcmUgaW5zdGVhZFxuICAgIC8vIElmIHBvaW50ZXJUeXBlIGlzIGRlZmluZWQsIGV2ZW50IGlzIGZyb20gYSBjbGljayBsaXN0ZW5lci4gRm9yIGV2ZW50cyBmcm9tIG1vdXNlZG93biBsaXN0ZW5lciwgZGV0YWlsID09PSAwIGlzIGEgc3VmZmljaWVudCBjaGVja1xuICAgIC8vIHRvIGRldGVjdCBUYWxrQmFjayB2aXJ0dWFsIGNsaWNrcy5cbiAgICBpZiAoKDAsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4KSgpICYmIGV2ZW50LnBvaW50ZXJUeXBlKSByZXR1cm4gZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbnMgPT09IDE7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCA9PT0gMCAmJiAhZXZlbnQucG9pbnRlclR5cGU7XG59XG5mdW5jdGlvbiAkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkMjliZjFiNWYyYzU2Y2Y2MyhldmVudCkge1xuICAgIC8vIElmIHRoZSBwb2ludGVyIHNpemUgaXMgemVybywgdGhlbiB3ZSBhc3N1bWUgaXQncyBmcm9tIGEgc2NyZWVuIHJlYWRlci5cbiAgICAvLyBBbmRyb2lkIFRhbGtCYWNrIGRvdWJsZSB0YXAgd2lsbCBzb21ldGltZXMgcmV0dXJuIGEgZXZlbnQgd2l0aCB3aWR0aCBhbmQgaGVpZ2h0IG9mIDFcbiAgICAvLyBhbmQgcG9pbnRlclR5cGUgPT09ICdtb3VzZScgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgYSBzcGVjaWZpYyBjb21iaW5hdGlvbiBvZiBldmVudCBhdHRyaWJ1dGVzLlxuICAgIC8vIENhbm5vdCB1c2UgXCJldmVudC5wcmVzc3VyZSA9PT0gMFwiIGFzIHRoZSBzb2xlIGNoZWNrIGR1ZSB0byBTYWZhcmkgcG9pbnRlciBldmVudHMgYWx3YXlzIHJldHVybmluZyBwcmVzc3VyZSA9PT0gMFxuICAgIC8vIGluc3RlYWQgb2YgLjUsIHNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA2MjE2LiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyBpcyB0byBkaXN0aW5ndXNoXG4gICAgLy8gVGFsa2JhY2sgZG91YmxlIHRhcCBmcm9tIFdpbmRvd3MgRmlyZWZveCB0b3VjaCBzY3JlZW4gcHJlc3NcbiAgICByZXR1cm4gISgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYTExYjAwNTk5MDBjZWVjOCkoKSAmJiBldmVudC53aWR0aCA9PT0gMCAmJiBldmVudC5oZWlnaHQgPT09IDAgfHwgZXZlbnQud2lkdGggPT09IDEgJiYgZXZlbnQuaGVpZ2h0ID09PSAxICYmIGV2ZW50LnByZXNzdXJlID09PSAwICYmIGV2ZW50LmRldGFpbCA9PT0gMCAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiO1xufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qIGVzbGludC1kaXNhYmxlIHJ1bGVzZGlyL3B1cmUtcmVuZGVyICovIFxuZnVuY3Rpb24gJDVhMzg3Y2M0OTM1MGU2ZGIkZXhwb3J0JDcyMmRlYmMwZTU2ZmVhMzkodmFsdWUsIGlzRXF1YWwpIHtcbiAgICAvLyBVc2luZyBhIHJlZiBkdXJpbmcgcmVuZGVyIGlzIG9rIGhlcmUgYmVjYXVzZSBpdCdzIG9ubHkgYW4gb3B0aW1pemF0aW9uIOKAkyBib3RoIHZhbHVlcyBhcmUgZXF1aXZhbGVudC5cbiAgICAvLyBJZiBhIHJlbmRlciBpcyB0aHJvd24gYXdheSwgaXQnbGwgc3RpbGwgd29yayB0aGUgc2FtZSBubyBtYXR0ZXIgaWYgdGhlIG5leHQgcmVuZGVyIGlzIHRoZSBzYW1lIG9yIG5vdC5cbiAgICBsZXQgbGFzdFZhbHVlID0gKDAsICQxMnVHcCR1c2VSZWYpKG51bGwpO1xuICAgIGlmICh2YWx1ZSAmJiBsYXN0VmFsdWUuY3VycmVudCAmJiBpc0VxdWFsKHZhbHVlLCBsYXN0VmFsdWUuY3VycmVudCkpIHZhbHVlID0gbGFzdFZhbHVlLmN1cnJlbnQ7XG4gICAgbGFzdFZhbHVlLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkOTlmYWNhYjczMjY2ZjY2MiRleHBvcnQkNWFkZDFkMDA2MjkzZDEzNihyZWYsIGluaXRpYWxWYWx1ZSwgb25SZXNldCkge1xuICAgIGxldCByZXNldFZhbHVlID0gKDAsICQxMnVHcCR1c2VSZWYpKGluaXRpYWxWYWx1ZSk7XG4gICAgbGV0IGhhbmRsZVJlc2V0ID0gKDAsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKSgoKT0+e1xuICAgICAgICBpZiAob25SZXNldCkgb25SZXNldChyZXNldFZhbHVlLmN1cnJlbnQpO1xuICAgIH0pO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICB2YXIgX3JlZl9jdXJyZW50O1xuICAgICAgICBsZXQgZm9ybSA9IHJlZiA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfcmVmX2N1cnJlbnQgPSByZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlZl9jdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVmX2N1cnJlbnQuZm9ybTtcbiAgICAgICAgZm9ybSA9PT0gbnVsbCB8fCBmb3JtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZm9ybSA9PT0gbnVsbCB8fCBmb3JtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByZWYsXG4gICAgICAgIGhhbmRsZVJlc2V0XG4gICAgXSk7XG59XG5cblxuXG5cbmV4cG9ydCB7JGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGY2ODA4NzdhMzQ3MTFlMzcgYXMgdXNlSWQsICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRjZDhjOWNiNjhmODQyNjI5IGFzIG1lcmdlSWRzLCAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkYjRjYzA5YzU5MmU4ZmRiOCBhcyB1c2VTbG90SWQsICRmZjU5NjNlYjFmY2NmNTUyJGV4cG9ydCRlMDhlM2I2N2UzOTIxMDFlIGFzIGNoYWluLCAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyBhcyBnZXRPd25lckRvY3VtZW50LCAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkZjIxYTFmZmFlMjYwMTQ1YSBhcyBnZXRPd25lcldpbmRvdywgJDNlZjQyNTc1ZGY4NGIzMGIkZXhwb3J0JDlkMTYxMWM3N2MyZmU5MjggYXMgbWVyZ2VQcm9wcywgJDVkYzk1ODk5YjMwNmY2MzAkZXhwb3J0JGM5MDU4MzE2NzY0YzE0MGUgYXMgbWVyZ2VSZWZzLCAkNjU0ODRkMDJkY2I3ZWIzZSRleHBvcnQkNDU3YzNkNjUxOGRkNGM2ZiBhcyBmaWx0ZXJET01Qcm9wcywgJDcyMTVhZmM2ZGU2MDZkNmIkZXhwb3J0JGRlNzllMmM2OTVlMDUyZjMgYXMgZm9jdXNXaXRob3V0U2Nyb2xsaW5nLCAkYWI3MWRhZGIwM2E2ZmIyZSRleHBvcnQkNjIyY2VhNDQ1YTFjNWI3ZCBhcyBnZXRPZmZzZXQsICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3IGFzIG9wZW5MaW5rLCAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkNTE0MzdkNTAzMzczZDIyMyBhcyBnZXRTeW50aGV0aWNMaW5rUHJvcHMsICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQzMjNlNGZjMmZhNDc1M2ZiIGFzIFJvdXRlclByb3ZpZGVyLCAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkZWZhOGM5MDk5ZTUzMDIzNSBhcyBzaG91bGRDbGllbnROYXZpZ2F0ZSwgJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDlhMzAyYTQ1ZjY1ZDA1NzIgYXMgdXNlUm91dGVyLCAkYmJlZDhiNDFmODU3YmNjMCRleHBvcnQkMjQ0OTAzMTZmNzY0YzQzMCBhcyBydW5BZnRlclRyYW5zaXRpb24sICQ5Y2MwOWRmOWZkNzY3NmJlJGV4cG9ydCQ3YmJlZDc1ZmViYTM5NzA2IGFzIHVzZURyYWcxRCwgJDAzZGViMjNmZjE0OTIwYzQkZXhwb3J0JDRlYWYwNGU1NGFhOGVlZDYgYXMgdXNlR2xvYmFsTGlzdGVuZXJzLCAkMzEzYjk4ODYxZWU1ZGQ2YyRleHBvcnQkZDY4NzUxMjIxOTRjN2I0NCBhcyB1c2VMYWJlbHMsICRkZjU2MTY0ZGZmNTc4NWUyJGV4cG9ydCQ0MzM4YjUzMzE1YWJmNjY2IGFzIHVzZU9iamVjdFJlZiwgJDRmNThjNWY3MmJjZjc5ZjckZXhwb3J0JDQ5NjMxNWExNjA4ZDk2MDIgYXMgdXNlVXBkYXRlRWZmZWN0LCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYyBhcyB1c2VMYXlvdXRFZmZlY3QsICQ5ZGFhYjAyZDQ2MTgwOWRiJGV4cG9ydCQ2ODM0ODBmMTkxYzBlM2VhIGFzIHVzZVJlc2l6ZU9ic2VydmVyLCAkZTc4MDFiZTgyYjRiMmE1MyRleHBvcnQkNGRlYmRiMWEzZjBmYTc5ZSBhcyB1c2VTeW5jUmVmLCAkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkY2ZhMjIyNWU4NzkzODc4MSBhcyBnZXRTY3JvbGxQYXJlbnQsICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCQyYmI3NDc0MGM0ZTE5ZGVmIGFzIGlzU2Nyb2xsYWJsZSwgJDVkZjY0YjM4MDdkYzE1ZWUkZXhwb3J0JGQ2OTk5MDVkZDU3YzczY2EgYXMgdXNlVmlld3BvcnRTaXplLCAkZWYwNjI1NjA3OTY4NmJhMCRleHBvcnQkZjhhZWRhN2IxMDc1M2ZhMSBhcyB1c2VEZXNjcmlwdGlvbiwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAgYXMgaXNNYWMsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQxODZjNjk2NGNhMTdkOTkgYXMgaXNJUGhvbmUsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3YmVmMDQ5Y2U5MmU0MjI0IGFzIGlzSVBhZCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGZlZGIzNjljYjcwMjA3ZjEgYXMgaXNJT1MsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRlMTg2NWMzYmVkY2Q4MjJiIGFzIGlzQXBwbGVEZXZpY2UsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3ODU1MTA0MzU4MmE2YTk4IGFzIGlzV2ViS2l0LCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNjQ0NmExODZkMDllMzc5ZSBhcyBpc0Nocm9tZSwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGExMWIwMDU5OTAwY2VlYzggYXMgaXNBbmRyb2lkLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYjdkNzg5OTNiNzRmNzY2ZCBhcyBpc0ZpcmVmb3gsICRlOWZhYWZiNjQxZTE2N2RiJGV4cG9ydCQ5MGZjM2ExN2Q5M2Y3MDRjIGFzIHVzZUV2ZW50LCAkMWRiZWNiZTI3YTA0ZjlhZiRleHBvcnQkMTRkMjM4ZjM0MjcyM2YyNSBhcyB1c2VWYWx1ZUVmZmVjdCwgJDJmMDRjYmM0NGVlMzBjZTAkZXhwb3J0JDUzYTA5MTBmMDM4MzM3YmQgYXMgc2Nyb2xsSW50b1ZpZXcsICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCRjODI2ODYwNzk2MzA5ZDFiIGFzIHNjcm9sbEludG9WaWV3cG9ydCwgJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JGNsYW1wIGFzIGNsYW1wLCAkNDUwNzQ2MWExYjg3MDEyMyRyZV9leHBvcnQkc25hcFZhbHVlVG9TdGVwIGFzIHNuYXBWYWx1ZVRvU3RlcCwgJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDYwMjc4ODcxNDU3NjIyZGUgYXMgaXNWaXJ0dWFsQ2xpY2ssICQ2YTdkYjg1NDMyNDQ4ZjdmJGV4cG9ydCQyOWJmMWI1ZjJjNTZjZjYzIGFzIGlzVmlydHVhbFBvaW50ZXJFdmVudCwgJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIgYXMgdXNlRWZmZWN0RXZlbnQsICQ1YTM4N2NjNDkzNTBlNmRiJGV4cG9ydCQ3MjJkZWJjMGU1NmZlYTM5IGFzIHVzZURlZXBNZW1vLCAkOTlmYWNhYjczMjY2ZjY2MiRleHBvcnQkNWFkZDFkMDA2MjkzZDEzNiBhcyB1c2VGb3JtUmVzZXR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNsYW1wIiwiJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JGNsYW1wIiwic25hcFZhbHVlVG9TdGVwIiwiJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JHNuYXBWYWx1ZVRvU3RlcCIsIiQxMnVHcCRyZWFjdCIsInVzZVN0YXRlIiwiJDEydUdwJHVzZVN0YXRlIiwidXNlUmVmIiwiJDEydUdwJHVzZVJlZiIsInVzZUNhbGxiYWNrIiwiJDEydUdwJHVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwiJDEydUdwJHVzZUVmZmVjdCIsImNyZWF0ZUNvbnRleHQiLCIkMTJ1R3AkY3JlYXRlQ29udGV4dCIsInVzZU1lbW8iLCIkMTJ1R3AkdXNlTWVtbyIsInVzZUNvbnRleHQiLCIkMTJ1R3AkdXNlQ29udGV4dCIsInVzZVNTUlNhZmVJZCIsIiQxMnVHcCR1c2VTU1JTYWZlSWQiLCJ1c2VJc1NTUiIsIiQxMnVHcCR1c2VJc1NTUiIsIiQxMnVHcCRjbHN4IiwiJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMiLCJkb2N1bWVudCIsInVzZUxheW91dEVmZmVjdCIsIiQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyIiwiZm4iLCJyZWYiLCJjdXJyZW50IiwiYXJncyIsImYiLCIkMWRiZWNiZTI3YTA0ZjlhZiRleHBvcnQkMTRkMjM4ZjM0MjcyM2YyNSIsImRlZmF1bHRWYWx1ZSIsInZhbHVlIiwic2V0VmFsdWUiLCJlZmZlY3QiLCJuZXh0UmVmIiwibmV3VmFsdWUiLCJuZXh0IiwiZG9uZSIsInF1ZXVlIiwiJGJkYjExMDEwY2VmNzAyMzYkdmFyJGNhblVzZURPTSIsIkJvb2xlYW4iLCJ3aW5kb3ciLCJjcmVhdGVFbGVtZW50IiwiJGJkYjExMDEwY2VmNzAyMzYkdmFyJGlkc1VwZGF0ZXJNYXAiLCJNYXAiLCIkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkZjY4MDg3N2EzNDcxMWUzNyIsImRlZmF1bHRJZCIsIm5leHRJZCIsInJlcyIsInVwZGF0ZVZhbHVlIiwidmFsIiwic2V0IiwiciIsImRlbGV0ZSIsIm5ld0lkIiwiJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGNkOGM5Y2I2OGY4NDI2MjkiLCJpZEEiLCJpZEIiLCJzZXRJZEEiLCJnZXQiLCJzZXRJZEIiLCIkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkYjRjYzA5YzU5MmU4ZmRiOCIsImRlcEFycmF5IiwiaWQiLCJyZXNvbHZlZElkIiwic2V0UmVzb2x2ZWRJZCIsInVwZGF0ZUlkIiwiZ2V0RWxlbWVudEJ5SWQiLCJ1bmRlZmluZWQiLCIkZmY1OTYzZWIxZmNjZjU1MiRleHBvcnQkZTA4ZTNiNjdlMzkyMTAxZSIsImNhbGxiYWNrcyIsImNhbGxiYWNrIiwiJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGIyMDRhZjE1ODA0MmZiYWMiLCJlbCIsIl9lbF9vd25lckRvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsIiQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhIiwiZG9jIiwiZGVmYXVsdFZpZXciLCIkM2VmNDI1NzVkZjg0YjMwYiRleHBvcnQkOWQxNjExYzc3YzJmZTkyOCIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJwcm9wcyIsImtleSIsImEiLCJiIiwiY2hhckNvZGVBdCIsIiQ1ZGM5NTg5OWIzMDZmNjMwJGV4cG9ydCRjOTA1ODMxNjc2NGMxNDBlIiwicmVmcyIsIiQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRET01Qcm9wTmFtZXMiLCJTZXQiLCIkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkbGFiZWxhYmxlUHJvcE5hbWVzIiwiJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxpbmtQcm9wTmFtZXMiLCIkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkcHJvcFJlIiwiJDY1NDg0ZDAyZGNiN2ViM2UkZXhwb3J0JDQ1N2MzZDY1MThkZDRjNmYiLCJvcHRzIiwibGFiZWxhYmxlIiwiaXNMaW5rIiwicHJvcE5hbWVzIiwiZmlsdGVyZWRQcm9wcyIsInByb3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJoYXMiLCJ0ZXN0IiwiJDcyMTVhZmM2ZGU2MDZkNmIkZXhwb3J0JGRlNzllMmM2OTVlMDUyZjMiLCJlbGVtZW50IiwiJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbCIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsInNjcm9sbGFibGVFbGVtZW50cyIsIiQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRnZXRTY3JvbGxhYmxlRWxlbWVudHMiLCIkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkcmVzdG9yZVNjcm9sbFBvc2l0aW9uIiwiJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZCIsImZvY3VzRWxlbSIsImUiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwicm9vdFNjcm9sbGluZ0VsZW1lbnQiLCJzY3JvbGxpbmdFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJvZmZzZXRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInNjcm9sbFdpZHRoIiwicHVzaCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCIkYWI3MWRhZGIwM2E2ZmIyZSRleHBvcnQkNjIyY2VhNDQ1YTFjNWI3ZCIsInJldmVyc2UiLCJvcmllbnRhdGlvbiIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ0b3AiLCIkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCIsInJlIiwiX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSIsIm5hdmlnYXRvciIsImJyYW5kcyIsInNvbWUiLCJicmFuZCIsInVzZXJBZ2VudCIsIiRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0iLCJwbGF0Zm9ybSIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ5YWMxMDBlNDA2MTNlYTEwIiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDE4NmM2OTY0Y2ExN2Q5OSIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3YmVmMDQ5Y2U5MmU0MjI0IiwibWF4VG91Y2hQb2ludHMiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkZmVkYjM2OWNiNzAyMDdmMSIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRlMTg2NWMzYmVkY2Q4MjJiIiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDc4NTUxMDQzNTgyYTZhOTgiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNjQ0NmExODZkMDllMzc5ZSIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4IiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGI3ZDc4OTkzYjc0Zjc2NmQiLCIkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkUm91dGVyQ29udGV4dCIsImlzTmF0aXZlIiwib3BlbiIsIiRlYThkY2JjYjllYTFiNTU2JHZhciRvcGVuU3ludGhldGljTGluayIsIiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQzMjNlNGZjMmZhNDc1M2ZiIiwiY2hpbGRyZW4iLCJuYXZpZ2F0ZSIsImN0eCIsInRhcmdldCIsIm1vZGlmaWVycyIsIiRlYThkY2JjYjllYTFiNTU2JHZhciRnZXRTeW50aGV0aWNMaW5rIiwibGluayIsIiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCRlZmE4YzkwOTllNTMwMjM1IiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwiJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDk1MTg1ZDY5OWUwNWQ0ZDciLCJQcm92aWRlciIsIiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5YTMwMmE0NWY2NWQwNTcyIiwiZ2V0QXR0cmlidXRlIiwib3JpZ2luIiwibG9jYXRpb24iLCJoYXNBdHRyaWJ1dGUiLCJtZXRhS2V5IiwiY3RybEtleSIsImFsdEtleSIsInNoaWZ0S2V5Iiwic2V0T3BlbmluZyIsIl93aW5kb3dfZXZlbnRfdHlwZSIsIl93aW5kb3dfZXZlbnQiLCJldmVudCIsInR5cGUiLCJzdGFydHNXaXRoIiwiS2V5Ym9hcmRFdmVudCIsImtleUlkZW50aWZpZXIiLCJNb3VzZUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJpc09wZW5pbmciLCJkaXNwYXRjaEV2ZW50IiwiSFRNTEFuY2hvckVsZW1lbnQiLCJocmVmIiwicmVsIiwiZG93bmxvYWQiLCJwaW5nIiwicmVmZXJyZXJQb2xpY3kiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwiJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDUxNDM3ZDUwMzM3M2QyMjMiLCIkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQiLCIkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbkNhbGxiYWNrcyIsIiRiYmVkOGI0MWY4NTdiY2MwJHZhciRzZXR1cEdsb2JhbEV2ZW50cyIsImlzVHJhbnNpdGlvbkV2ZW50Iiwib25UcmFuc2l0aW9uU3RhcnQiLCJ0cmFuc2l0aW9ucyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblRyYW5zaXRpb25FbmQiLCJvbmNlIiwiYWRkIiwicHJvcGVydHlOYW1lIiwicHJvcGVydGllcyIsInNpemUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2IiLCJjbGVhciIsImJvZHkiLCJyZWFkeVN0YXRlIiwiJGJiZWQ4YjQxZjg1N2JjYzAkZXhwb3J0JDI0NDkwMzE2Zjc2NGM0MzAiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCIkOWNjMDlkZjlmZDc2NzZiZSR2YXIkZHJhZ2dpbmdFbGVtZW50cyIsIiQ5Y2MwOWRmOWZkNzY3NmJlJGV4cG9ydCQ3YmJlZDc1ZmViYTM5NzA2IiwiY29uc29sZSIsIndhcm4iLCJjb250YWluZXJSZWYiLCJvbkhvdmVyIiwib25EcmFnIiwib25Qb3NpdGlvbkNoYW5nZSIsIm9uSW5jcmVtZW50Iiwib25EZWNyZW1lbnQiLCJvbkluY3JlbWVudFRvTWF4Iiwib25EZWNyZW1lbnRUb01pbiIsIm9uQ29sbGFwc2VUb2dnbGUiLCJnZXRQb3NpdGlvbiIsImNsaWVudFgiLCJjbGllbnRZIiwiZ2V0TmV4dE9mZnNldCIsImNvbnRhaW5lck9mZnNldCIsIm1vdXNlT2Zmc2V0IiwibmV4dE9mZnNldCIsImRyYWdnaW5nIiwicHJldlBvc2l0aW9uIiwiaGFuZGxlcnMiLCJvbk1vdXNlRHJhZ2dlZCIsInByZXZlbnREZWZhdWx0Iiwib25Nb3VzZVVwIiwic3BsaWNlIiwiaW5kZXhPZiIsIm9uTW91c2VEb3duIiwiY3VycmVudFRhcmdldCIsImVsdCIsImNvbnRhaW5zIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZU91dCIsIm9uS2V5RG93biIsIiQwM2RlYjIzZmYxNDkyMGM0JGV4cG9ydCQ0ZWFmMDRlNTRhYThlZWQ2IiwiZ2xvYmFsTGlzdGVuZXJzIiwiYWRkR2xvYmFsTGlzdGVuZXIiLCJldmVudFRhcmdldCIsImxpc3RlbmVyIiwib3B0aW9ucyIsInJlbW92ZUdsb2JhbExpc3RlbmVyIiwiX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldCIsInJlbW92ZUFsbEdsb2JhbExpc3RlbmVycyIsImZvckVhY2giLCIkMzEzYjk4ODYxZWU1ZGQ2YyRleHBvcnQkZDY4NzUxMjIxOTRjN2I0NCIsImRlZmF1bHRMYWJlbCIsImxhYmVsIiwibGFiZWxsZWRCeSIsImlkcyIsInRyaW0iLCJzcGxpdCIsImpvaW4iLCIkZGY1NjE2NGRmZjU3ODVlMiRleHBvcnQkNDMzOGI1MzMxNWFiZjY2NiIsImZvcndhcmRlZFJlZiIsIm9ialJlZiIsIiQ0ZjU4YzVmNzJiY2Y3OWY3JGV4cG9ydCQ0OTYzMTVhMTYwOGQ5NjAyIiwiZGVwZW5kZW5jaWVzIiwiaXNJbml0aWFsTW91bnQiLCJsYXN0RGVwcyIsImRlcCIsImlzIiwiJDlkYWFiMDJkNDYxODA5ZGIkdmFyJGhhc1Jlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCIkOWRhYWIwMmQ0NjE4MDlkYiRleHBvcnQkNjgzNDgwZjE5MWMwZTNlYSIsIm9uUmVzaXplIiwicmVzaXplT2JzZXJ2ZXJJbnN0YW5jZSIsImVudHJpZXMiLCJvYnNlcnZlIiwidW5vYnNlcnZlIiwiJGU3ODAxYmU4MmI0YjJhNTMkZXhwb3J0JDRkZWJkYjFhM2YwZmE3OWUiLCJjb250ZXh0IiwiJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JGNmYTIyMjVlODc5Mzg3ODEiLCJub2RlIiwiY2hlY2tGb3JPdmVyZmxvdyIsInNjcm9sbGFibGVOb2RlIiwiJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JDJiYjc0NzQwYzRlMTlkZWYiLCJwYXJlbnRFbGVtZW50Iiwic3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiaXNTY3JvbGxhYmxlIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsIiQ1ZGY2NGIzODA3ZGMxNWVlJHZhciR2aXN1YWxWaWV3cG9ydCIsInZpc3VhbFZpZXdwb3J0IiwiJDVkZjY0YjM4MDdkYzE1ZWUkZXhwb3J0JGQ2OTk5MDVkZDU3YzczY2EiLCJpc1NTUiIsInNldFNpemUiLCJ3aWR0aCIsImhlaWdodCIsIiQ1ZGY2NGIzODA3ZGMxNWVlJHZhciRnZXRWaWV3cG9ydFNpemUiLCJuZXdTaXplIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiJGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uSWQiLCIkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25Ob2RlcyIsIiRlZjA2MjU2MDc5Njg2YmEwJGV4cG9ydCRmOGFlZGE3YjEwNzUzZmExIiwiZGVzY3JpcHRpb24iLCJzZXRJZCIsImRlc2MiLCJkaXNwbGF5IiwidGV4dENvbnRlbnQiLCJyZWZDb3VudCIsInJlbW92ZSIsIiRlOWZhYWZiNjQxZTE2N2RiJGV4cG9ydCQ5MGZjM2ExN2Q5M2Y3MDRjIiwiaGFuZGxlciIsImhhbmRsZUV2ZW50IiwiaXNEaXNhYmxlZCIsIiQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCQ1M2EwOTEwZjAzODMzN2JkIiwic2Nyb2xsVmlldyIsIm9mZnNldFgiLCIkMmYwNGNiYzQ0ZWUzMGNlMCR2YXIkcmVsYXRpdmVPZmZzZXQiLCJvZmZzZXRZIiwieCIsInkiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlckFkanVzdGVkWCIsInBhcnNlSW50IiwiYm9yZGVyQWRqdXN0ZWRZIiwibWF4WCIsIm1heFkiLCJhbmNlc3RvciIsImNoaWxkIiwiYXhpcyIsInN1bSIsIm9mZnNldFBhcmVudCIsIiQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCRjODI2ODYwNzk2MzA5ZDFiIiwidGFyZ2V0RWxlbWVudCIsInJvb3QiLCJpc1Njcm9sbFByZXZlbnRlZCIsIl90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3Iiwib3JpZ2luYWxMZWZ0Iiwib3JpZ2luYWxUb3AiLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwibmV3TGVmdCIsIm5ld1RvcCIsIk1hdGgiLCJhYnMiLCJfb3B0c19jb250YWluaW5nRWxlbWVudF9zY3JvbGxJbnRvVmlldyIsIl9vcHRzX2NvbnRhaW5pbmdFbGVtZW50IiwiX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXcxIiwiY29udGFpbmluZ0VsZW1lbnQiLCJpbmxpbmUiLCJzY3JvbGxQYXJlbnQiLCIkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkNjAyNzg4NzE0NTc2MjJkZSIsIm1veklucHV0U291cmNlIiwiaXNUcnVzdGVkIiwicG9pbnRlclR5cGUiLCJidXR0b25zIiwiZGV0YWlsIiwiJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDI5YmYxYjVmMmM1NmNmNjMiLCJwcmVzc3VyZSIsIiQ1YTM4N2NjNDkzNTBlNmRiJGV4cG9ydCQ3MjJkZWJjMGU1NmZlYTM5IiwiaXNFcXVhbCIsImxhc3RWYWx1ZSIsIiQ5OWZhY2FiNzMyNjZmNjYyJGV4cG9ydCQ1YWRkMWQwMDYyOTNkMTM2IiwiaW5pdGlhbFZhbHVlIiwib25SZXNldCIsInJlc2V0VmFsdWUiLCJoYW5kbGVSZXNldCIsIl9yZWZfY3VycmVudCIsImZvcm0iLCJ1c2VJZCIsIm1lcmdlSWRzIiwidXNlU2xvdElkIiwiY2hhaW4iLCJnZXRPd25lckRvY3VtZW50IiwiZ2V0T3duZXJXaW5kb3ciLCJtZXJnZVByb3BzIiwibWVyZ2VSZWZzIiwiZmlsdGVyRE9NUHJvcHMiLCJmb2N1c1dpdGhvdXRTY3JvbGxpbmciLCJnZXRPZmZzZXQiLCJvcGVuTGluayIsImdldFN5bnRoZXRpY0xpbmtQcm9wcyIsIlJvdXRlclByb3ZpZGVyIiwic2hvdWxkQ2xpZW50TmF2aWdhdGUiLCJ1c2VSb3V0ZXIiLCJydW5BZnRlclRyYW5zaXRpb24iLCJ1c2VEcmFnMUQiLCJ1c2VHbG9iYWxMaXN0ZW5lcnMiLCJ1c2VMYWJlbHMiLCJ1c2VPYmplY3RSZWYiLCJ1c2VVcGRhdGVFZmZlY3QiLCJ1c2VSZXNpemVPYnNlcnZlciIsInVzZVN5bmNSZWYiLCJnZXRTY3JvbGxQYXJlbnQiLCJ1c2VWaWV3cG9ydFNpemUiLCJ1c2VEZXNjcmlwdGlvbiIsImlzTWFjIiwiaXNJUGhvbmUiLCJpc0lQYWQiLCJpc0lPUyIsImlzQXBwbGVEZXZpY2UiLCJpc1dlYktpdCIsImlzQ2hyb21lIiwiaXNBbmRyb2lkIiwiaXNGaXJlZm94IiwidXNlRXZlbnQiLCJ1c2VWYWx1ZUVmZmVjdCIsInNjcm9sbEludG9WaWV3cG9ydCIsImlzVmlydHVhbENsaWNrIiwiaXNWaXJ0dWFsUG9pbnRlckV2ZW50IiwidXNlRWZmZWN0RXZlbnQiLCJ1c2VEZWVwTWVtbyIsInVzZUZvcm1SZXNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/virtualizer/node_modules/@react-aria/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/virtualizer/node_modules/clsx/dist/clsx.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@react-stately/virtualizer/node_modules/clsx/dist/clsx.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: () => (/* binding */ clsx),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction r(e) {\n    var t, f, n = \"\";\n    if (\"string\" == typeof e || \"number\" == typeof e) n += e;\n    else if (\"object\" == typeof e) if (Array.isArray(e)) {\n        var o = e.length;\n        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += \" \"), n += f);\n    } else for(f in e)e[f] && (n && (n += \" \"), n += f);\n    return n;\n}\nfunction clsx() {\n    for(var e, t, f = 0, n = \"\", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += \" \"), n += t);\n    return n;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clsx);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLFNBQVNBLEVBQUVDLENBQUM7SUFBRSxJQUFJQyxHQUFFQyxHQUFFQyxJQUFFO0lBQUcsSUFBRyxZQUFVLE9BQU9ILEtBQUcsWUFBVSxPQUFPQSxHQUFFRyxLQUFHSDtTQUFPLElBQUcsWUFBVSxPQUFPQSxHQUFFLElBQUdJLE1BQU1DLE9BQU8sQ0FBQ0wsSUFBRztRQUFDLElBQUlNLElBQUVOLEVBQUVPLE1BQU07UUFBQyxJQUFJTixJQUFFLEdBQUVBLElBQUVLLEdBQUVMLElBQUlELENBQUMsQ0FBQ0MsRUFBRSxJQUFHQyxDQUFBQSxJQUFFSCxFQUFFQyxDQUFDLENBQUNDLEVBQUUsTUFBS0UsQ0FBQUEsS0FBSUEsQ0FBQUEsS0FBRyxHQUFFLEdBQUdBLEtBQUdELENBQUFBO0lBQUUsT0FBTSxJQUFJQSxLQUFLRixFQUFFQSxDQUFDLENBQUNFLEVBQUUsSUFBR0MsQ0FBQUEsS0FBSUEsQ0FBQUEsS0FBRyxHQUFFLEdBQUdBLEtBQUdELENBQUFBO0lBQUcsT0FBT0M7QUFBQztBQUFRLFNBQVNLO0lBQU8sSUFBSSxJQUFJUixHQUFFQyxHQUFFQyxJQUFFLEdBQUVDLElBQUUsSUFBR0csSUFBRUcsVUFBVUYsTUFBTSxFQUFDTCxJQUFFSSxHQUFFSixJQUFJLENBQUNGLElBQUVTLFNBQVMsQ0FBQ1AsRUFBRSxLQUFJRCxDQUFBQSxJQUFFRixFQUFFQyxFQUFDLEtBQUtHLENBQUFBLEtBQUlBLENBQUFBLEtBQUcsR0FBRSxHQUFHQSxLQUFHRixDQUFBQTtJQUFHLE9BQU9FO0FBQUM7QUFBQyxpRUFBZUssSUFBSUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3ZpcnR1YWxpemVyL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanM/NWNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIG89ZS5sZW5ndGg7Zm9yKHQ9MDt0PG87dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKX1lbHNlIGZvcihmIGluIGUpZVtmXSYmKG4mJihuKz1cIiBcIiksbis9Zik7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiLG89YXJndW1lbnRzLmxlbmd0aDtmPG87ZisrKShlPWFyZ3VtZW50c1tmXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyJdLCJuYW1lcyI6WyJyIiwiZSIsInQiLCJmIiwibiIsIkFycmF5IiwiaXNBcnJheSIsIm8iLCJsZW5ndGgiLCJjbHN4IiwiYXJndW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/virtualizer/node_modules/clsx/dist/clsx.mjs\n");

/***/ })

};
;